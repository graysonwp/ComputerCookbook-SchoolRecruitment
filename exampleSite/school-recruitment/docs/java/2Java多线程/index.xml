<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-Runnable%E5%92%8C-Thread%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-Runnable%E5%92%8C-Thread%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Runnable和 Thread的区别 #  Runnable 和 Thread 本身并没有实质的区别，除此之外，主要有以下区别：
 Runnable 的使用方式是实现其接口，Thread 的使用方式是继承其类，二者都需要实现 run 方法。 Runnable 接口支持多继承，但基本上用不到。 Thread 实现了 Runnable 接口并进行了扩展，而 Thread 和 Runnable 的市值是实现的关系，不是同类的东西，所以 Runnable 和 Thread 本身并没有可比性。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84start%E5%92%8Crun%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84start%E5%92%8Crun%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>Thread类中的start()和run()方法有什么区别 #    通过 start()方法来启动一个线程，此时线程处于就绪状态，可以被 JVM 来调度执行，在调度过程中，JVM 通过调用线程类的 run()方法来完成实际的业务逻辑，当 run()方法结束后，此线程就会终止，所以通过 start()方法可以达到多线程的目的。
  如果直接调用线程类的 run()方法，会被当做一个普通的函数调用，程序中仍然只有主线程这一个线程，即 start()方法呢能够异步的调用 run()方法，但是直接调用 run()方法确实同步的，无法达到多线程的目的。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</guid>
      <description>Java多线程中调用wait()和sleep()方法有什么不同 #  相同点：
 他们都是在多线程的环境下，都可以在程序的调用出阻塞指定的毫秒数，并返回。 二者都可以通过 interrupt()方法打断现成的暂停状态，从而使线程立刻抛出 InterruptedException。 不同点： wait()属于 Object 类的方法，sleep()属于 Thread 类的方法。 每个对象都有一个锁来控制同步访问，Synchronized 关键字可以和对象的锁交互，来实现现成的同步。sleep()方法没有释放锁，而 wait()方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait()方法只能在同步控制方法或者同步控制块里面使用，而 sleep()可以在任何地方使用。 sleep()方法必须捕获异常，而 wait()方法不需要捕获异常。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>ReentrantLock和Synchronized的区别 #  相同点：
两者都是可重入锁，他们的加锁方式都是同步，而且都是阻塞式的同步，也就是说当一个线程获得了对象锁，进入了同步块，其它访问概统不快的线程都必须阻塞在同步块外面等待。
不同点：
 原始构成：Synchronized是Java语言的关键字，是原生层面的互斥，需要jvm实现；而ReentrantLock是JDK1.5之后提供的API层面的互斥锁类。 实现：Synchronized是通过JVM来加锁和解锁；ReentrantLock是API层面的加锁和解锁。 代码编写：Synchronied不需要用户去手动释放锁，当Synchronied方法或者代码块执行完之后，系统会自动让线程释放对锁的占用，更安全；而ReentrantLock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致死锁现象。 等待可中断：Sychronied不可中断，直到代码执行完，才正常释放锁，除非抛出异常，由JVM退出等待；ReentrantLock在持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以通过tryLock来设置超时时间，时间过了之后就放弃等待，同时可以将lockInterruptibly()方代码块中，调用interrupt()方法来中断，但是Synchronied不行。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-volatile%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-volatile%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>volatile适用于高并发的什么场景 #  volidate最适合一个线程写，多个线程读的场景，如果有多个线程并发写操作，仍然需要使用锁或者线程安全的容器或者原子变量来替代。我们只能在有限的一些场景下使用volidate变量来替代锁，要使volidate变量提供理想的线程安全，必须同时满足下面两个条件：
 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>多线程join方法用于什么场景 #  主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法。join方法的作用是等待线程对象被销毁。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>多个线程间如何共享数据 #   如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据。2. 将共享数据封装成另一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上，这样容易实现针对数据进行各个操作的互斥和通信。 将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法页封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>线程的状态有哪些，各自的使用场景是什么 #   新状态：线程被创建出来，但是还没有调用start()方法。2. 可运行状态：线程有资格运行，但调度程序还没有把它选定为运行线程时所处的状态，此时正在等待操作系统分配资源、等待IO；连接，当satrt()方法调用时，线程首先进入可运行状态，在线程运行之后或者从阻塞、等待、睡眠状态回来后，也返回到可运行状态。 Running(运行状态)：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。 等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态，实际上这三个状态组合为一种，其共同点是线程仍旧是获得，但是当前没有条件运行，等待某件事件出现时，他可能返回到可运行状态。 死亡状态：线程的run()方法完成时所处的状态。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-Java%E8%87%AA%E5%B8%A6%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-Java%E8%87%AA%E5%B8%A6%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>Java自带哪几种线程池 #   newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。如果长时间没有往线程池中提交任务，则该工作线程将自动终止。终止后，如果又提交了新的任务，则线程池重新创建一个工作线程。因此，在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。 newFixedThreadPool(典型且优秀的线程池)：创建一个指定工作线程数量的线程池。每当提交一个任务时就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。它具有提高程序效率和节省创建线程时所耗开销的优点。但是，在线程池空闲时，他不会释放工作线程，还会占用一定的系统资源。 newSingleThreadExecutor：创建一个单线程化的 Executor，即只创建唯一的工作线程来执行任务，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。如果这个线程异常结束，会有另一个取代他，保证顺序执行，单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.10-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.10-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>Java内存模型 #   Java 内存模型（Java Memory Model, JMM）本身是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式。 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，用于存储线程私有的数据，而 Java 内存模型中规定都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行： 首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成后再将变量写回到主内存，不能直接操作主内存中的变量。 工作内存中存储着主内存中的变量副本拷贝，因为工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成。  ![]../../media/202105//1621914599.8081136.png)
参考文献 #    全面理解 Java 内存模型(JMM)及 volatile 关键字。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</guid>
      <description>并发编程的三大特性 #  并发编程主要包含三大特性，分别是 原子性、可见性 和 有序性。
1 原子性 #  1.1 概念 #  原子性是指在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。
1.2 示例 #  i = 0; //1 j = i ; //2 i++; //3 i = j + 1; //4 上面的四个操作中，只有 1 是原子操作，其余绝不是：
 1 在 Java 中，对基本数据类型的变量的赋值操作都是原子性。 2 中包含了两个操作：  读取 i。 将 i 结果赋值给 j。   3 中包含了三个操作：  读取 i。 i+1。 将加 1 结果赋值给 i。   4 中同 3 一样。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.12-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.12-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</guid>
      <description>指令重排 #  在 Java 中看似顺序的代码在 JVM 中，可能会出现编译器或者 CPU 对这些操作指令进行了重新排序，在特定情况下，指令重排会给我们的程序带来不确定的结果。
1 概念 #  在虚拟机层面，为了尽可能减少内存操作速度远慢于CPU运行速度所带来的的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱，即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码可能会后执行，以尽可能充分的利用CPU，从 Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
 编译器优化重排序： 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行重排序： 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统重排序： 处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。   2 数据依赖性 #   如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。     名称 代码示例 说明     写后读 a = 1;b = 1 写一个变量之后，再读这个变量   写后写 a = 1;a = 2; 写一个变量之后，再写这个变量   读后写 a = b;b = 1; 读一个变量之后，再写这个变量    上面 3 中情况中，只要将两个操作的顺序进行重排序，程序的执行结果就会被改变。 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。不过这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  3 as-if-serial 语义 #  3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.13-Volatile%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.13-Volatile%E5%8E%9F%E7%90%86/</guid>
      <description>Volatile原理 #  1 定义 #   Volatile 可以保证线程的可见性、有序性，但是无法保证线程的原子性。 加入Volatile 关键字时，会多出一个 lock 前缀指令，该指令实际相当于一个内存屏障，他会提供 3 个功能：  确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在他前面的操作已经全部完成。 他会强制将缓存的修改操作立即写入主内存。 如果是写操作，他会导致其他 CPU 中对应的缓存行无效。    2 实现原理 #  2.1 可见性 #   如果对声明了 Volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀指令，将这个变量所在的缓存行的数据写回到系统内存，这一步确保了如果有其他线程对声明了 Volatile 变量进行修改时，则立即更新主内存中的数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理器会通过嗅探在总线上的传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里，这一步确保了其他线程获得的声明了 Volatile 变量都是从主内存中获取最新的。  2.2 有序性 #   Lock 前缀指令实际上相当于一个内存屏障，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在他前面的操作已经全部完成。  3 示例 #  3.1 保证可见性 #  先看一段代码，假如线程 1 先执行，线程 2 后执行：
//线程 1 boolean stop = false; while(!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.14-CAS%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.14-CAS%E5%8E%9F%E7%90%86/</guid>
      <description>CAS原理 #  1 CAS 含义 #    CAS 全称是 Compare and Swap，即比较并交换。
  它是一种无锁原子算法，同时也是一种乐观机制。
  CAS 映射到操作系统就是一条 CPU 原子指令，实现方式是基于硬件平台的汇编指令，在 Intel 的 CPU 中，使用的是 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。
  CAS 包含 3 个参数 V、E、N：
 V： Value，即要更新的值。 E： Expect，即预期值。 N：New，即新值。  只有当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程完成更新，则当前线程什么都不做，最后 CAS 返回当前 V 的真实值。
  当多个线程同时使用 CAS 操作一个变量时，最多只会有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试（自旋），当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以避免其他线程对当前线程的干扰。
  与锁相比，使用 CAS 会使程序看起来更加复杂一些，但是使用无锁的方式完全没有锁竞争带来的线程间频繁调度的开销和阻塞，他对死锁问题天生免疫，因此他要比基于锁的方式拥有更好的性能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.15-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.15-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/</guid>
      <description>Java的4种引用级别 #  1 介绍 #  从 JDK 1.2 版本开始，对象的引用被划分为 4 中级别，从而使程序能更加灵活地控制对象的生命周期，这 4 中级别从高到低依次为强引用（FinalReference）、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。
![]../../media/202105//1621914616.5661292.png)
2 具体划分 #  2.1 强引用（FinalReference） #    强引用是使用最普遍的引用，如果一个对象具有强引用，那么垃圾回收器绝对不会回收他，如下：
Object finalReference = new Object();   当空间不足时，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
  如果强引用对象不使用时，需要弱化从而使 GC 能够回收，显示地设置 finalReference 为 null，或让其超出对象的生命周期范围，则 GC 认为该对象不存在引用，这时就可以回收这个对象，具体什么时候回收取决于 GC 算法。
finalReference = null;   如果一个方法内部有一个强引用（局部变量），这个引用保存在 Java 栈中，真正的引用内容（Object）保存在 Java 堆中，当这个方法运行完成后，就会退出方法栈，则引用对象的引用数就会变为 0，这个对象就会被回收。
public void test() { Object finalReference = new Object(); // 省略其他操作 }   如果这个变量为全局变量时，就需要在不用这个对象时赋值为 null，因为强引用不会被垃圾回收。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.16-Java%E4%B8%AD%E7%9A%84%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.16-Java%E4%B8%AD%E7%9A%84%E9%94%81/</guid>
      <description>Java中的锁 #  1 公平锁和非公平锁 #  1.1 基本概念 #  1.1.1 公平锁 #  1.1.1.1 含义 #  公平锁是指多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列里面的第一位才能得到锁。
1.1.1.2 优缺点 #  1.1.1.2.1 优点 #   所有的线程都能得到资源，不会饿死在队列中。  1.1.1.2.2 缺点 #   吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，CPU唤醒阻塞线程的开销会很大。  1.1.2 非公平锁 #  1.1.2.1 含义 #   非公平锁是指多个线程区获取锁的时候，会直接去尝试，获取不到，再去进入等待队列，如果能获取到，则直接获取锁。 ReentrantLock默认是非公平锁， 如果要使用公平锁，可以使用ReentrantLock lock = new ReentrantLock(true);  ![]../../media/202105//1621914616.920087.png)
1.1.2.2 优缺点 #  1.1.2.2.1 优点 #   可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点，CPU 也不必去唤醒所有线程，会减少唤醒线程的数量。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.17-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.17-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>Synchronized实现原理 #  1 特性 #  Synchronized 具有 原子性、 可见性、 有序性、 可重入性。
2 用法 #  Synchronized 可以修饰静态方法、成员函数，同时还可以直接定义代码块，但是归根结底他上锁的资源只有两类，一个是对象，一个是类。
 关于 static 需要注意以下地方：
 static修饰的静态方法、静态属性都是归类所有，同时该类的所有实例对象都可以访问。 普通成员属性、成员方法是归实例化的对象所有，必须实例化之后才能访问，这也是为什么静态方法不能访问非静态属性的原因。   2.1 修饰成员函数 #   下面的代码均定义在 SynchronizedTest 类中，且该类中的变量定义如下：
private int i = 0; private static int j = 0; private final SynchronizedTest instance = new SynchronizedTest();    具体的代码如下：
// 对成员函数加锁，必须获得该类的实例对象的锁才能进入同步块 public synchronized void add1() { i++; }   该方法没有被 static 修饰，也就是说该方法是归实例化的对象所有，那么这个锁就是加给 SynchronizedTest 类所实例化的对象。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>线程池实现原理 #  1 前言 #  1.1 什么是线程池 #   线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如 MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。 线程池维护多个线程，等待监督管理者分配可并发执行的任务，这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。  1.2 线程池有哪些优点 #   降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能，比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。  1.3 线程池解决的问题是什么 #   线程池解决的核心问题就是资源管理问题，在并发环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入，这种不确定性将带来以下若干问题：  频繁申请、销毁资源和调度资源，将带来额外的损耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。   为解决资源分配这个问题，线程池采用了池化（Pooling）思想，即为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 除了线程池以外，池化思想在计算机领域的其他比较典型的几种使用策略包括：  内存池（Memory Pooling）：预先申请内存，提升内存申请速度，减少内存碎片。 连接池（Connection Pooling）：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池（Object Pooling）：循环使用对象，减少资源在初始化和释放时的昂贵损耗。    2 核心设计与实现 #  在前文中，我们了解到线程池是一种通过池化思想，帮助我们管理线程而获取并发性的工具，在 Java 中的体现是 ThreadPoolExecutor，下面我们将详细介绍该类的设计与实现。
 如无特殊说明，下面内容的叙述基于的 JDK 版本为 JDK 1.8.0_181。
 2.1 总体设计 #  ThreadPoolExecutor 的继承关系如下图所示：</description>
    </item>
    
  </channel>
</rss>
