<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>序 on Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/</link>
    <description>Recent content in 序 on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</guid>
      <description>三次握手 #  1 什么是三次握手 #    第一次握手：Client 将SYN 置为 1，随机产生一个初始序列号seq 发送给Server，进入SYN_SENT 状态。 第二次握手：Server 收到Client 的SYN=1 后，知道客户端请求建立连接，将自己的SYN 置为 1，ACK 置为 1，产生一个acknowledge number = seq + 1，并随机产生一个自己的初始序列号，发送给客户端，进入SYN_RCVD 状态。 第三次握手： 客户端检查acknowledge number 是否为序列号 +1，ACK 是否为 1，检查正确之后，将自己的ACK 置为 1，产生一个acknowledge number = 服务器发的序列号 + 1，发送给服务器，进入ESTBLISHED 状态；服务器检查ACK 为 1，acknowledge number = 序列号 + 1 之后，也进入ESTBLISHED 状态，完成三次握手，连接建立。  2 三次握手的必要性 #   第一次握手：客户端发送网络包，服务端收到了，这样服务端就能得出结论，客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发送网络包，客户端收到了，这样客户端就能得出结论，服务端的接收能力、发送能力、客户端的接收、发送能力是正常的，不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发送网络包，服务端收到了，这样服务器就能得出结论，客户端的接收能力、服务端的接收能力是正常的。  3 TCP 连接可以两次握手吗 #  不可以，主要有两个原因：
 可能会出现已失效的连接请求报文段又传到了服务器端。  Client 发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间的滞留了，以延误到连接释放以后的某个时间才到达Server。 本来这是一个早已失效的报文段，但Server 收到此失效的连接请求报文段后，就误认为是Client 再次发出的一个新的连接请求，于是就向Client 发出确认报文段，同意建立连接。 如果不采用三次握手，那么只要Server 发出确认，新的连接就建立了。 由于现在Client 并没有发出建立连接的请求，因此不会理睬Server 的确认，也不会向Server 发送数据，但Server 却认为新的连接已经建立，并一直等待Client 发来数据，这样，Server 的很多资源就白白浪费掉了。 采用三次握手的办法就可以防止上述现象发生，就像刚才那种情况，Client 不会向Server 的确认发出确认，Server 由于收不到确认，就知道Client 并没有要求建立连接。   无法保证 Client 正确接收第二次握手的报文（Server 无法确认 Client 是否收到），也无法保证 Client 和 Server 之间成功互换初始序列号。  4 可以采用四次握手吗 #  可以，但是会降低传输的效率。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>HTTP和HTTPS的区别 #  1 HTTP和HTTPS有什么区别 #   端口不同：HTTP使用80端口，HTTPS使用443端口。 HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL（Secure Socket Layer）之上，添加了加密和认证机制，更加安全。 HTTPS由于加密解密会带来更大的CPU和内存开销。 HTTPS通信需要证书，一般需向证书颁发机构购买。  2 HTTPS的连接过程 #   客户端向服务器发出请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）。 服务器从中选取一种加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址、加密公钥（用于非对称加密）以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）。 客户端验证服务器的合法性，包括证书是否过期、CA是否可靠、发行者证书的公钥能否正确解开服务器证书的发行者的数字签名、服务器证书的域名是否和服务器的实际域名相匹配。 如果证书受信任，或者用户接受了不受信任的证书，浏览器会生成一个随机密钥，并用于服务器提供的公钥加密，然后使用HASH算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密，最后将加密后的随机密钥和摘要一起发送给服务器。 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出HASH摘要值，并验证握手消息是否一致，如果一致，服务器使用对称加密的密钥加密握手消息发送给浏览器。 浏览器解密并验证摘要，若一致，则握手结束，之后的数据传送都使用对称加密的密钥进行加密。    非对称加密算法用于在握手过程中加密生成的密码。 对称加密算法用于对真正传输的数据进行加密。 HASH算法主要用于验证数据的完整性。   3 输入www.baidu.com，怎么变成https://www.baidu.com，怎么确定用HTTP还是HTTPS #   一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS，但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，返回的302报文中有这样一条Strict-Transport-Security: max-age=31536000，其含义是强制浏览器在max-age到期之前，把所有的http://www.baidu.com自动转换成https://www.baidu.com，这是浏览器实现的URL转换，不用每次访问两次服务器，避免了302跳转到80再跳转到443的中间人劫持的问题，所以只有第一次的时候会出现302，以后访问就不会出现了。  4 什么是对称加密、非对称加密，区别是什么 #   对称加密：  加密和解密采用相同的密钥，如DES、RC2、RC4。   非对称加密：  需要两个密钥：公钥和私钥。 如果用公钥加密，需要用私钥才能解密，如RSA。   区别：  对称加密速度更快，通常用于大量数据的加密。 非对称加密安全性更高（不需要传送私钥）。    5 数字签名、报文摘要的原理 #   发送者A用私钥进行签名，接收者B用公钥验证签名，因为除A外没有人有私钥，所以B相信签名是来自A，A不可抵赖，B也不能伪造报文。 摘要算法： MD5、SHA。  6 参考文献 #    HTTP和HTTPS有什么区别？  输入网址的时候，浏览器是如何判断你是http协议还是https协议的。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
      <description>IP地址的分类 #   两级的 IP 地址通常由网络号和主机号组成：  第一个字段是网络号，标志着主机所连接到的网络，一个网络号在整个因特网范围内必须是唯一的。 第二个字段是主机号，它标志着主机，一个主机号在他前面所指明的网络范围内必须是唯一的。   IP 地址分为五大类，分别为 A 类、B 类、C 类、D 类和 E 类，具体如下：  A 类地址： 以0开头，第一个字节范围是1~126（1.0.0.0 - 126.255.255.255）。 B 类地址： 以10开头，第一个字节范围是128~191（128.0.0.0 - 191.255.255.255）。 C 类地址： 以110开头，第一个字节范围是192~223（192.0.0.0 - 223.255.255.255）。 D 类地址： 以1110开头，第一个字节范围是224~239（224.0.0.0 - 239.255.255.255）（作为多播使用）。 E 类地址： 保留。   A、B、C 是基本类，D、E 作为多播和保留使用。 留用的内部私有地址如下：  A 类地址：10.0.0.0&amp;ndash;10.255.255.255。 B 类地址：172.16.0.0&amp;ndash;172.31.255.255。 C 类地址： 192.168.0.0&amp;ndash;192.168.255.255。   IP 地址与子网掩码相与得到网络号。 主机号全为 0的是网络号（例如：192.168.2.0），主机号全为 1的是广播地址（例如：192.168.2.255）。   参考文献 #    IP 地址的分类？  IP 地址分类详解。  IP地址的分类。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>进程和线程的区别 #  1 进程和线程有哪些区别 #   进程（Process）是系统进行资源分配和调度的基本单位，线程是CPU 调度和分配的基本单位。 线程依赖于进程而存在，一个进程至少有一个线程。 进程有自己的独立地址空间，线程共享所属进程的地址空间。 进程是拥有系统资源的一个独立单位，而线程基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），和其他线程共享本进程的相关资源如内存、I/O、CPU 等。 在进程切换时，涉及到整个当前进程 CPU 环境的设置以及新被调度运行的 CPU 环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换时的开销远大于线程切换的开销。 线程间的通信更方便，同一进程下的线程共享全局变量等数据，而进程间的通信需要以进程间通信（IPC）的方式进行。 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其他进程造成影响，因为进程有自己独立的地址空间，因此，多进程更加健壮。  2 同一进程中的线程可以共享哪些变量 #   进程代码块。 进程的公有数据（全局变量、静态变量&amp;hellip;）。 进程打开的文件描述符。 进程的当前目录。 信号处理器/信号处理函数：对收到的信号的处理方式。 进程 ID与进程组 ID。  3 线程独占哪些资源 #   线程 ID。 一组寄存器的值。 线程自身的栈（堆是共享的）。 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其他线程修改。 信号掩码/信号屏蔽字：表示是否屏蔽/阻塞相应的信号（SIGKILL 和 SIGSTOP 除外）。  参考文献 #    进程和线程有什么区别？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/</guid>
      <description>分页和分段 #  1 分页存储 #   分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为页面加以编号，从0开始，如第0页、第1页等。 同样，也把内存空间分成与页面相同大小的若干个存储块，称为块或页框，也为他们加以编号，如0#块、1#块等。 在为进程分配内存时，以块为单位将进程中的若干页分别装入到多个可以不相邻接的物理块中。 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为页内碎片。  2 分段存储 #   在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段、栈段等，每个段都从0开始编址，并采用一段连续的地址空间。 段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。 整个作业的地址空间由于是分成多个段，因而是二维的，其逻辑地址由段号和段内地址所组成。  3 段页式存储 #   用户进程先按段划分，段内再按页划分。 内存划分和分配按页划分。  4 分页存储和分段存储的区别 #   目的不同： 分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需求，使程序和数据可以被划分为逻辑上独立的地址空间。 大小不同： 段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定。 地址空间维度不同： 分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）。 共享： 分段很方便按照逻辑模块实现信息的共享和保护；分页管理不方便按照逻辑模块实现信息的共享和保护。 碎片： 分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片。  参考文献 #    分页和分段有什么区别？  分页存储管理和分段存储管理。  操作系统——段式存储管理、段页式存储管理。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/</guid>
      <description>三范式 #  数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明确的，同时不会发生插入（insert）、删除（delete）、和更新（update）操作异常。
1 第一范式（1NF） #  1.1 含义 #   符合 1NF 的关系中每个属性都不可再分。 1NF 是所有关系型数据库的最基本要求。  1.2 示例 #   下图所示的表就不符合 1NF 的要求：  为了满足 1NF 的要求，上面的表应该改为下图的形式：   1.3 存在的问题 #  如果仅仅符合 1NF 的设计，仍然会存在数据冗余过大、插入异常、删除异常、修改异常的问题，例如对于下图中表的设计：
  数据冗余过大：  每一名学生的学号、姓名、系名、系主任这些数据重复多次。 每个系与对应的系主任的数据也重复多次。   插入异常：  假如学校新建了一个系，但是暂时还没有招收任何学生（比如 3 月份就新建了，但要等到 8 月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的。   删除异常：  假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。   修改异常：  假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。    2 第二范式（2NF） #   正因为仅符合 1NF 的数据库设计存在着上面提到的那些问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>四次挥手 #  1 什么是四次挥手 #    第一次挥手：Client 将FIN 置为 1，发送一个序列号seq 给Server，进入FIN_WAIT_1 状态。 第二次挥手：Server 收到FIN 之后，发送一个ACK=1，acknowledge number=收到的序列号 +1，进入CLOSE_WAIT 状态，此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。 第三次挥手：Server 将FIN 置为 1，发送一个序列号给Client，进入LAST_ACK 状态。 第四次挥手：Client 收到服务器的FIN 之后，进入TIME_WAIT 状态，接着将ACK 置为 1，发送一个acknowledge number=序列号 +1 给服务器，服务器收到后，确认acknowledge number 后，变为CLOSED 状态，不再向客户端发送数据，客户端等待2*MSL（报文段最长寿命） 时间后，也进入CLOSED 状态，完成四次挥手。   MSL 是什么？
 MSL（Maximum Segment Lifetime），即报文段最长寿命，指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。 如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。   2 CLOSE_WAIT #  2.1 服务器端 CLOSE_WAIT 状态意义是什么（为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手） #   因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。 等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>GET和POST的区别 #   GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的。 GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源。 GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中。 GET请求可被缓存、收藏、保留到历史记录，且其数据明文出现在URL中；POST请求的参数不会被保存，安全性相对较高。 GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据。 GET长度有限制（操作系统或者浏览器），而POST数据大小无限制。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/</guid>
      <description>划分子网 #  1 为什么要划分子网 #   简单地说就是一个公司不可能使用 254 个公网地址，A 公司想用 6 个地址，B 公司也想用 6 个地址，如果把这两个公司的地址都放在一个大网段里，这两个公司的地址就能够直接互通。  2 什么是划分子网 #   子网划分就是通过借用 IP 地址的若干位主机位来充当子网地址，从而将原来的网络分为若干个彼此隔离的子网。 通过划分子网，我们可以按照我们的需要将网络分割成小网络，这样也有助于降低流量和隐藏网络的复杂性。 子网掩码对应的网络号和子网号都为1，主机号为0，通过将子网掩码和与操作，可以得到对应的网络地址。 划分子网后，数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网，然后再将子网掩码与目标地址逐位与操作，若结果为某个子网的网络地址，则送到该子网。   3 子网划分的优点 #   减少网络流量。 提高网络性能。 简化管理。 易于扩大地理范围。  4 参考文献 #    什么叫划分子网？  网络基础知识&amp;ndash;子网划分。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid>
      <description>进程间通信方式 #  进程间的通信方式主要有六种，分别是管道、消息队列、共享内存、信号量、信号（Signal）、套接字（Socket）。
1 管道 #  管道分为两种，分别为匿名管道（Pipe）和命名管道（FIFO）。
1.1 匿名管道 #  1.1.1 含义 #   匿名管道是一种半双工的方式，数据只能单向流动，也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。 只能在具有亲缘关系的进程间使用，进程的亲缘关系一般指父子关系。 当一个进程创建了一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道，子进程关闭写管道，这样就提供了两个进程间数据流动的一种方式。  1.1.2 优缺点 #  1.1.2.1 优点 #   简单方便。  1.1.2.2 缺点 #   这个管道只能在具有亲缘关系的进程之间通信。 他只能实现一个进程写另一个进程读，而如果需要两者同时进行，就得重新打开一个管道。  1.2 命名管道 #  1.2.1 含义 #   为了使任意两个进程之间通信，就提出了命名管道。 与管道的区别是提出了一个路径名与之关联，以 FIFO 的形式存储于文件系统中，能够实现任何两个进程之间通信，而匿名管道对于文件系统是不可见的，只限于在父子进程之间的通信。 FIFO 是一个设备文件，在文件系统中以文件名的形式存在，因此，即使进程与创建 FIFO 的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。 FIFO 遵循先进先出原则，即第一个进来的数据会第一个被读走。  1.2.2 优缺点 #  1.2.2.1 优点 #   可以实现任意关系的进程间的通信。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>虚拟内存 #  1 什么是虚拟内存 #   每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，然后被映射到物理内存。 但是不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。 这样，对于程序来说，逻辑上似乎有很大的的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。  2 如何进行地址空间到物理内存的映射 #   内存管理单元（MMU）管理着逻辑地址到物理地址的转换。 其中的页表存储着页（逻辑地址）和页框（物理地址）的映射表，页表中还包含有效位（是在内存还是在磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。  3 参考文献 #    什么是虚拟内存？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</guid>
      <description>多表连接方式 #  1 实验表 #  1.1 学生表 #  -- ---------------------------- -- Table structure for student -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_bin DEFAULT NULL, `sex` varchar(255) COLLATE utf8_bin DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_bin; -- ---------------------------- -- Records of student -- ---------------------------- BEGIN; INSERT INTO `student` VALUES (1, &amp;#39;小强&amp;#39;, &amp;#39;男&amp;#39;, 8); INSERT INTO `student` VALUES (2, &amp;#39;小花&amp;#39;, &amp;#39;女&amp;#39;, 5); INSERT INTO `student` VALUES (3, &amp;#39;小名&amp;#39;, &amp;#39;女&amp;#39;, 6); INSERT INTO `student` VALUES (4, &amp;#39;小五&amp;#39;, &amp;#39;女&amp;#39;, 6); INSERT INTO `student` VALUES (5, &amp;#39;小星&amp;#39;, &amp;#39;男&amp;#39;, 30); COMMIT; 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</guid>
      <description>流量控制 #  1 TCP如何实现流量控制 #    TCP使用滑动窗口协议来实现流量控制，防止发送方发送速率太快，接收方缓存区不够导致溢出。 接收方会维护一个接收窗口，其大小是根据自己的资源情况动态调整的，在返回ACK时将接收窗口大小放在 TCP报文中的窗口字段告知发送方。 发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口左移。 发送窗口的上限为接收窗口和拥塞窗口的最小值，接收窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。  2 什么是零窗口（接收窗口为0时会怎样） #   如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。 如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Session与Cookie的区别 #   Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案。 Cookie保存在客户端本地，客户请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态，保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把Sessionid保存在URL中）。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/</guid>
      <description>什么是ARP协议 #   ARP协议完成了IP地址和物理地址的映射。 每一个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器的IP地址到硬件地址的映射表。 当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址：  如果有，就直接将数据包发送到这个MAC地址。 如果没有，就向所在局域网发起一个ARP请求的广播包（在发送自己的ARP请求时，同样会带上自己的IP地址到硬件地址的映射）。   收到请求的主机检查自己的IP地址和目的主机IP地址是否一致，如果一致，则保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。 源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。 如果源主机一直没有收到响应，表示ARP查询失败。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>进程同步问题 #   进程的同步是目的，而进程间通信是实现进程同步的手段。
 1 管程 #  1.1 含义 #   管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定功能接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源，使用完之后必须释放管程并唤醒入口等待队列中的进程。 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复。 管程使用锁确保了在任何情况下管程中只有一个活跃的线程，即确保线程互斥访问临界区。 管程使用条件变量提供的等待队列实现线程间协作，当线程暂时不能获得所需资源时，进入队列等待，当线程可以获得所需资源时，从等待队列中唤醒。  1.2 组成 #  管程主要有三部分组成，具体如下：
 一个锁： 控制管程代码的互斥访问。 入口队列： 每次只能有一个线程进入。 条件变量： 管理数据的并发访问。   1.3 条件变量 #   条件变量是管程内的等待机制。 每个条件变量表示一种等待原因，对应一个等待队列。 条件变量有两种操作：  wait() 操作：  将自己阻塞在队列中。 唤醒一个等待者或者释放管程的互斥访问（即允许另外一个线程进入管程）。   signal() 操作：  将等待队列中的一个线程唤醒。 如果等待队列为空，这就相当于是一个空操作。      1.4 语义 #  事实上管程一共有三种语义：
 Hoare 语义。 Mesa 语义。 Hansen 语义。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</guid>
      <description>页面置换算法 #  1 含义 #   在程序运行过程中，如果要访问的页面不在内存中，就会发生缺页中断从而将该页调入内存中。 此时如果内存中已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。  2 分类 #  2.1 最佳置换算法（Optimal Replacement Algorithm, OPT） #   最佳置换算法的基本思想是置换以后不需要或者最远的将来才需要的页面，这样可以保证获得最低的缺页率。 但是由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再访问的，因而该算法是一种理论上的算法，也是最优的一种算法。  2.2 先进先出法（FIFO） #   先进先出法会优先置换在内存中驻留时间最长的页面。 该算法会产生贝拉迪（Belay）异常，也就是当所分配的物理块数增大而页故障数不减反增的异常现象。 该算法的缺点是将那些经常被访问的页面置换出，从而使缺页率升高。  2.3 第二次机会置换法（Second Chance Replacement, SCR） #   该算法是对 FIFO 算法的改进，每个页面访问 2 次后再淘汰。 具体实现上是设置页面访问位，每次检查队首的页面访问位：  如果该位为 0，则将该页置换出。 如果该位为 1，将该位设置为 0，然后将其移到队尾，看成新装入的页。   该算法的优点是能在一定程度上避免把经常使用的页面置换出去。   2.4 时钟置换法（Clock） #   该算法是对第二次机会置换法的改进。 第二次机会置换法需要在链表中移动页面，而时钟置换法将页面保存在环形链表中，只需要后移队头指针，就相当于是把原来的队头放队尾了。 该算法的优点是避免了移动链表节点的开销。   2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>存储过程 #  1 含义 #   存储过程是在数据库中定义一些完成特定功能的 SQL 语句的集合，经过编译后存储在数据库中。 存储过程可以包含流程控制语句以及各种 SQL 语句，他可以接受参数、输出参数。  2 优缺点 #  2.1 优点 #  在 MySQL 中使用存储过程，而不是用存储在客户端计算机本地的 SQL 程序，相比有以下几点优点：
 增强了 SQL 语言的功能和灵活性：  存储过程可以使用流程控制语句编写，有很强的的灵活性，可以完成复杂的判断和较复杂的计算。   允许标准组件式变成：  存储过程被创建后，可以在程序中被多次调用，而不用重新编写该存储过程的SQL语句。 数据库专业人员可以随时对存储过程进行修改，对应用程序代码毫无影响。   能实现较快的执行速度：  如果某一操作包含大量的SQL代码或被分多次执行，那么存储过程要比批处理的执行速度快很多，因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器会对其进行分析优化，并且给出最终被存储在系统表中的执行计划，而批处理的SQL语句在每次运行时都要进行编译和优化，速度相对较慢。   减少网络流量：  针对同一数据库对象的操作（比如查询、修改），如果这一操作所涉及的SQL语句被组织成存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少了网络流量并降低了网络负载。   可被当做一种安全机制来充分利用：  系统管理员通过对执行某一存储过程的权限进行限制，进而实现对响应数据的访问权限的限制，避免了非授权用户对数据的访问。    2.2 缺点 #   可移植性差： 存储过程将应用程序绑定到了数据库上。 开发调试复杂： 没有好的IDE。 修改复杂： 需要重新编译，有时候还需要更新程序中的代码以更新调用。  参考文献 #    什么是存储过程？有哪些优缺点？  数据库原理之存储过程和函数。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/</guid>
      <description>从输入网址到获得页面的过程（越详细越好） #   域名解析，即浏览器查询 DNS，获取域名对应的 IP 地址，具体可参考 1.2.8 DNS。 建立 TCP 连接，即浏览器获得域名对应的 IP 地址以后，向服务器请求建立链接，发起三次握手，这里使用五层协议更详细的描述如何建立这个 TCP 连接的：  使用应用层发起 HTTP 请求，这个可以根据我们本身输入的 URL 访问时，用的什么协议就发起对应协议去进行请求。 然后是传输层的 TCP 协议为传输报文提供可靠的字节流服务，这里使用了TCP 三次握手。 接着是网络层把 TCP 分隔好的各种数据包传送给接收方，而且要保证确实能传到接收方还需要接收方的 MAC 地址，也就是物理地址。 最后是链路层将数据发送到数据链路层传输。 至此，请求报文已发出，客户端发送请求的阶段结束。 然后是服务端接收请求处理阶段，将数据按照原路进行处理，即 $ 链路层 \rightarrow 网络层 \rightarrow 传输层 \rightarrow 应用层 $，然后响应客户端的发送报文。   TCP/IP 链接建立起来后，浏览器向服务器发送 HTTP 请求。 服务器收到这个请求之后，根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。 浏览器解析并渲染视图，若遇到对 js、css 及图片等静态资源的引用时，则重复上述步骤并向服务器请求这些资源。 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面  参考文献 #    HTTP 和 HTTPS 有什么区别？  （3）字节跳动面试题：从输入网址到获得页面的网络请求的过程，请详细说一下。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/</guid>
      <description>NAT协议 #  1 什么是NAT协议 #   NAT，Network Address Translation，即网络地址转换协议。 主要用于解决内网中的主机要和因特网上的主机通信，由NAT路由器将主机的本地IP地址转换为全球IP地址。 NAT不仅能解决IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 NAT主要分为两种，一种是静态NAT，一种是动态NAT，具体如下：  静态NAT： 将内部网络中的每个主机都永久映射成外部网络中的某个合法的地址，多用于服务器。 动态NAT： 在外部网络中定义了一个或多个合法地址，采用动态分配的方法映射到内部网络。    2 参考文献 #    什么是NAT (网络地址转换)？  网络地址转换协议NAT功能详解及NAT基础知识介绍。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/</guid>
      <description>进程有哪几种状态 #   1 进程的三种状态 #   就绪状态： 进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。 运行状态： 进程正在处理器上运行，在单处理器环境下，每个时刻最多只有一个进程处于运行状态。 阻塞状态： 进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入输出完成，此时即使处理器空闲，该进程也不能运行。  2 进程三种状态之间的切换 #   当一个就绪进程获得处理器时，其状态就由就绪变为运行。 当一个运行进程被剥夺处理器时，如用完系统分给他的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪。 当一个运行进程因为某件事情受阻时，如所申请资源被占用、启动I/O传输未完成，其状态就会由运行变为阻塞。 当一个阻塞进程所等待事情发生时，如得到申请资源、I/O传输完成，其状态就会由阻塞变为就绪。  3 参考文献 #    进程有哪几种状态？  进程的几种状态。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/</guid>
      <description>局部性原理 #   一个优秀的程序、优美的代码，往往具有良好的局部性。
 1 什么是局部性原理 #  1.1 原理 #   程序局部性原理是指程序在执行时呈现出局部规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分；相应的，执行所访问的存储空间也局限于某个内存区域。 局部性通常由两种形式，分别是时间局部性和空间局部性：  时间局部性： 被引用过一次的存储器位置在未来会被多次引用（通常在循环中）。 空间局部性： 如果一个存储器的位置被引用，那么他附近的位置也会被引用。   局部性可以提高程序的运行效率。  1.2 示例 #  //求数组元素之和，v为数组名，n为数组大小， int sum(int *v, int n) { int i = 0; int sum = 0; for (i=0; i&amp;lt;n; ++i) { sum+=v[i]; } return sum; }   数组在内存中是按照上图的方式连续存放的。 对于sum变量：  具有良好的时间局部性，因为在for循环结束之前，每次执行循环体都有对 sum的访问， 没有空间局部性，因为sum是标量，通过 sum这个地址只能得到一个值。   对于v变量：  具有良好的空间局部性，因为数组v是按照顺序存放在内存中，每次访问 v[i]总是在 v[i-1]的下一个位置。 没有时间局部性，因为在循环体中，每个元素 v[i]只会被访问一次。    2 为什么局部性可以提高程序的运行效率 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>DELETE、TRUNCATE和DROP的区别 #  1 DELETE #   操作可以针对 table，也可以针对 view。 仅删除表中的数据。 数据库操作语言（DML），删除时是每次从表中删除一行，所以会很慢，操作会放到rollback segment，并且会将其作为事务记录在日志中保存以便进行回滚操作，事务提交之后才生效。 如果有相应的触发器，执行的时候会被触发。 不会减少表或索引所占用的空间。  2 TRUNCATE #   只能针对 table。 删除表中的所有行，但表结构、列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。 数据库定义语言（DDL），操作立即生效，原数据不放到 rollback segment中，不能回滚。 操作不能触发触发器。 会将表和索引所占用的空间恢复到初始大小。 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 不能对以下表使用truncate：  由 FOREIGN KEY约束引用的表。 参与索引视图的表。 通过使用事务复制或合并复制发布的表。    3 DROP #   只能针对 table。 删除表结构、列、约束、触发器、索引，依赖于该表的存储过程和函数将被保留，但是会变为 invalid状态。 数据库定义语言（DDL），操作立即生效，原数据不放到 rollback segment中，不能回滚。 操作不能触发触发器。 会将表占用的空间全释放掉。  参考文献 #    Drop/Delete/Truncate的区别？  SQL中drop、truncate和delete的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</guid>
      <description>拥塞控制 #  1 TCP 的拥塞控制是怎么实现的 #   拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion Voidance）、快重传（Fast Retransmit）、快恢复（Fast Recovery）：
 慢启动： 刚开始发送数据时，先把拥塞窗口（Congestion Window）设置为 1 个最大的报文段MSS 的数值，每收到 1 个新的确认报文之后，就把拥塞窗口加 1 个MSS，这样每经过一个传输轮次（或者说每经过一个往返时间RTT），拥塞窗口的大小就会加倍。 拥塞避免： 当拥塞窗口的大小达到慢开始门限（Slow Start Threshold）时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次，只增加 1 个MSS。  无论在慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限设置为出现拥塞时的发送方窗口的一半（但不能小于 2），然后把拥塞窗口重新设置为 1，执行慢开始算法。
  快重传： 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认，为的是使发送方尽早知道有报文段没有到达对方，而不要等到自己发送数据时捎带确认，快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复： 当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法，不执行慢开始的原因是如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。  2 参考文献 #    TCP 的拥塞控制是怎么实现的？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>HTTP请求有哪些常见的状态码 #    2xx： 操作成功，200 OK。
  3xx： 重定向，301 永久重定向，302 暂时重定向。
  4xx： 客户端错误，400 Bad Request，401 Unauthorized，403 Forbidden；404 Not Found。
 401 Unauthorized：用来表示缺失或错误的认证，可以修改后重试。
403 Forbidden：用户认证后，权限不足，无法对该资源进行操作。
   5xx： 服务端错误，500 服务器内部错误，501 服务不可用。
  参考资料 #    HTTP请求有哪些常见状态码？  HTTP 状态码 401 和 403 的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</guid>
      <description>进程调度策略 #  1 批处理系统 #  1.1 先来先服务（first-come first-service，FCFS） #  1.1.1 含义 #   先来先服务调度算法是一种非抢占式的算法，先进入就绪队列的进程，先分配处理器运行。 一个进程一旦占有了处理器，他就一直运行下去，直到该进程完成工作或者因为等待某事件发生而不能继续运行时才释放处理器。  1.1.2 优缺点 #  1.1.2.1 优点 #   非抢占式，开销小，无饥饿问题。  1.1.2.2 缺点 #   响应时间不确定，可能很慢。 对长进程有利，对短进程不利。 对CPU 繁忙型进程有利，对I/O 繁忙型进程不利。   为什么 FCFS 对 I/O 繁忙型进程不利？
 因为每次进行 I/O 操作都会进入阻塞态，I/O 完成之后变成就绪态，会重新进入就绪队列队尾。 因为是 FCFS，所以会重新排队。 然而每次调度这个进程只会运行很短时间就又需要 I/O，然后又到队尾，如此往复，所以效率很低。   1.2 最短作业优先（shortest job first，SJF） #  1.2.1 含义 #   最短作业优先调度算法将每个进程与其下次 CPU 执行时间关联起来，当 CPU 变为空闲时，他会被赋予给具有最短 CPU 执行的进程。 如果两个进程具有同样长度的 CPU 执行时间，那么可以由FCFS处理。 SJF 算法是对 FCFS 算法的改进，其目标是减少平均周转时间。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</guid>
      <description>缓冲区溢出 #  1 什么是缓冲区溢出 #   C 语言使用运行时栈来存储过程信息。 每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。 C 语言对数组引用不进行任何边界检查，因此对越界的数组元素的写操作会破坏存储在栈中的状态信息，这种现象称为缓冲区溢出。 缓冲区溢出会破坏程序运行，也可以被用来攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。  2 缓冲区溢出示例 #  /** * 测试缓冲区溢出 */ void test_cache_overflow() { char str[8]; char input[256]; gets(input); strcpy(str,input); printf(&amp;#34;%s&amp;#34;, str); }   上面这段代码存在一个经典的缓冲区溢出漏洞strcpy。 我们为str分配了8个字节的空间，输入小于等于8个字符，没问题。 但当我们输入超长的数据时，就会出现问题，程序直接终止执行了。  3 防范缓冲区溢出攻击的方法 #  防范缓冲区溢出攻击的方法有三种，分别是随机化、栈保护和限制可执行代码区域。
3.1 随机化 #   使用缓冲区溢出进行攻击，需要知道攻击代码的地址，因此常见的方法有：  栈随机化： 程序开始时在栈上分配一段随机大小的空间。 地址空间布局随机化（Address-Space Layout Randomization, ASLR）： 每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会加载到内存空间的不同区域。   但是攻击者依然可以使用蛮力克服随机化，这种方式称为“空操作雪橇（Nop Sled）”，即在实际的攻击代码前插入很长的一段 nop指令序列，执行这条指令只会移动到下一条指令。 因此只要攻击者能够猜中这段序列的某个地址，程序就会最终经过这段序列，到达攻击代码。 因此栈随机化和ASLR只能增加攻击一个系统的难度，但不能保证安全。  3.2 栈保护 #   在发生缓冲区溢出，造成任何有害结果之前，尝试检测到他。 常用的栈破坏检测方法是栈保护机制，即在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（Canary）。 在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。  3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>触发器 #  1 含义 #   触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。 触发器在数据库中以独立的对象存储，用于保证数据完整性（比如在写入数据表前，强制检验或转换数据）。 触发器只能创建在永久表上，不能对临时表创建触发器。 MySQL的触发器是针对每一行执行，比如向一张表中插入500条数据，就会触发500次触发器。 MySQL中定义了NEW和OLD用来表示触发器所在表中触发了触发器的那一行数据：  NEW表示新数据，OLD表示旧数据。 NEW可以在触发器中使用 SET赋值，这样不会再次触发触发器，而OLD是只读的。    2 四要素 #   监视地点：TABLE。 监视事件：INSERT、UPDATE、DELETE。 触发时间：AFTER、BEFORE。 触发事件：INSERT、UPDATE、DELETE。  3 注意事项 #   因为在MySQL中触发器是针对行的，因此对于增、删、改非常频繁的表上切记不要使用触发器，因为他会非常消耗资源。  4 相关操作 #  4.1 创建触发器 #  4.1.1 基本语法 #  CREATE [DEFINER = { user | CURRENT_USER }] TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW [trigger_order] trigger_body trigger_time: { BEFORE | AFTER } trigger_event: { INSERT | UPDATE | DELETE } trigger_order: { FOLLOWS | PRECEDES } other_trigger_name  BEFORE和AFTER参数指定了触发执行的时间，在事件之前还是事件之后。 FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器，也就是说触发器的触发频率是针对每一行数据触发一次。 trigger_event：  INSERT型触发器：插入某一行时触发触发器，可能通过INSERT、LOAD DATA、REPLACE语句触发（LOAD DATA语句用于将一个文件装入到一个数据表中，相当于一系列的INSERT操作）。 UPDATE型触发器：更改某一行时触发触发器，可能通过UPDATE语句触发。 DELETE型触发器：删除某一行时触发触发器，可能通过DELETE、REPLACE语句触发。   trigger_order：MySQL 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>TCP和UDP的区别 #  1 TCP与UDP的区别有哪些 #    TCP是面向连接的，UDP是无连接的，即UDP发送数据之前不需要建立连接。
  TCP是可靠的，UDP是不可靠的，这是因为UDP接收方收到报文后，不需要给出任何确认。
  TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
  TCP是面向字节流的，UDP是面向报文的：
 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
   TCP有拥塞控制机制，UDP没有，网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信、游戏。
  TCP首部开销（20字节）比UDP首部开销（8字节）要大。
  UDP的主机不需要维持复杂的连接状态表。
  2 什么时候选择TCP，什么时候选择UDP #   对某些实时性要求比较高的情况，选择UDP，比如游戏、媒体通信、实时视频流（直播），即使出现传输错误也可以容忍。 其他大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失。  3 HTTP可以使用UDP吗 #   HTTP3.0之前使用TCP协议，而HTTP3.0使用基于UDP协议的QUIC协议组成。 此变化主要是为了解决HTTP2.0中存在的对头阻塞问题，由于HTTP2.0在单个TCP连接上使用了多路复用，受到TCP拥塞控制的影响，少量的丢包就可能导致整个TCP连接上的所有流被阻塞。  4 面向连接和无连接的区别 #   面向连接的网络服务（虚电路服务）：  首先建立连接，所有的数据包经过相同的路径，服务质量有较好地保证。   无连接的网络服务（数据报服务）：  每个数据包含目的地址，数据路由相互独立，路径可能变化。 网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付。 网络发生拥塞时，可能会将一些分组丢弃。    参考文献 #    TCP与UDP的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>什么是RIP，算法是什么 #  1 简介 #   RIP全称是Routing Information Protocol，即路由信息协议，是一种较为简单的内部网关协议（Interior Gateway Protocol）。 他通过UDP报文进行路由信息的交换，使用的端口号是520。  2 原理 #   RIP是一种基于距离矢量（DIstance-Vector）算法的协议，使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。 RIP属于网络层，主要应用于规模较小的，可靠性要求较低的网络，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。 在RIP网络中，缺省情况下，设备到他直接连接网络的跳数为0，通过一个设备可达的网络跳数为1，其余以此类推，也就是说，度量值等于从本网络到达目的网络间的设备数量。 为限制收敛时间，RIP规定度量值取0~15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达，由于这个限制，使得RIP不可能在大型网络中得到应用。  3 RIP路由表的形成过程 #  RIP启动时的初始路由表仅包含本设备的一些直连接口路由，通过相邻设备互相学习路由表项，才能实现各网段路由互通。
 RIP路由表形成过程如上图所示：
 RIP协议启动之后，RouterA会向相邻的路由器广播一个Request报文。 当RouterB从接口接收到RouterA发送的Request报文后，把自己的RIP路由表封装在Response报文内，然后向该接口对应的网络广播。 RouterA根据RouterB发送的Response报文，形成自己的路由表。  4 优缺点 #  4.1 优点 #    实现简单，开销较小。  4.2 缺点 #   RIP限制了网路的规模，它能使用的最大距离为15（16表示不可达）。 路由器之间交换的路由信息是路由器中的完成路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间更长，即当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器。  5 RIP协议中，为什么会出现坏消息传播的慢 #    我们可以假设三个网络通道由两个路由器互联起来，并且都已建立了各自的路由表，图中路由器的交换信息只给出了我们感兴趣的一行内容：路由器$R_1$中的 1，1，直接表示到网1的距离是1，直接交付，路由器$R_2$中的 1，2，R1表示到网1的距离是2，下一跳经过R1。 现在假定路由器$R_1$到网1的链路出现了故障，$R_1$无法到达网1，于是路由器$R_1$把到网1的距离改为16（表示到网1不可达），因而在$R_1$的路由表中的相应项目变为 1，16，直接。 但是，很可能要经过30秒中后$R_1$才把更新信息发送给$R_2$，然而$R_2$可能已经先把自己的路由表发送给了$R_1$，其中有 1，2，R1。 $R_1$收到$R_2$的更新报文之后，误认为可经过$R_2$到达网1，于是把收到的路由信息 1，2，R1修改为1，3，R2，表明我到网1的距离是3，下一条经过R2，并把更新后的信息发送给$R_2$。 同理，$R_2$接着又更新自己的路由表为 1，4，R1，以为我到网1的距离是4，下一跳经过R1。 这样的更新一直持续下去，直到$R_1$和$R_2$到网1的距离都增大到16时，$R_1$和$R_2$才知道原来网1是不可达的。 RIP协议的这一特点叫做“好消息传播得快，坏消息传播得慢”，网络出故障的传播时间往往需要较长的时间（例如数分钟）。 为了使坏消息传播得快些，可以采取多种措施，例如让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送。  6 参考文献 #    什么是RIP (距离矢量路由协议)?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</guid>
      <description>僵尸进程和孤儿进程 #  1 僵尸进程 #  1.1 含义 #   当一个子进程结束运行（一般是调用 exit、运行时发生致命错误或收到终止信号导致）时，其退出状态会汇报给操作系统，系统则以 SIGCHLD 信号将子进程被结束的事件告知父进程，此时，子进程的进程控制块（PCB）仍驻留在内存中。 一般来说，收到 SIGCHLD 后，父进程会使用 wait 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB。 如果父进程没有调用 wait 或 waitpid 获取子进程的状态信息时，子进程的 PCB 就会一直驻留在内存中，成为僵尸进程。  1.2 特点 #   僵尸进程是一个死亡的进程，但是并没有真正被销毁。 他已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程 ID、终止状态以及资源利用信息（CPU 时间，内存使用量等）供父进程收集，除此之外，僵尸进程不再占用任何内存空间。 这个僵尸进程可能会一直留在系统中，直到系统重启。  1.3 危害 #   占用进程号，而系统所能使用的进程号是有限的，如果产生大量的僵尸进程，就会因为没有可用的进程号而导致系统不能产生新的进程。  1.4 如何杀死僵尸进程 #   重启服务器。 找到该僵尸进程的父进程，并将该进程的父进程杀掉，则此僵尸进程会自动消失。   查找僵尸进程的方法：ps aux | grep -w &#39;Z&#39;
 1.5 如何避免僵尸进程 #   父进程在创建子进程之前，就调用 signal(SIGCHLD,SIG_IGN) 向系统申明自己不会对这个子进程的 exit 动作进行任何关注行为，这样子进程一旦退出，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。 父进程创建子进程后调用 wait 或 waitpid 等待子进程结束，但是这会导致父进程挂起。 父进程在创建子进程的时候，连续调用两次 fork()，而且使紧跟的子进程退出，使其孙子进程成为孤儿进程，从而 init 进程将代替父进程来接手，负责清除这个孤儿进程，于是父进程就无须进行任何的清理行为，系统会自动处理。 采用信号量处理函数，父进程首先注册一个信号处理函数 signal(SIGCHLD, sig_chld_handler)，然后每当子进程退出的时候，父进程都会收到 SIGCHLD，然后在 sig_chld_handler 中调用 wait 函数等待子进程的退出。  2 孤儿进程 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/</guid>
      <description>视图 #  1 含义 #   视图是一种虚拟存在的逻辑表，本身并不包含数据，只是作为一个 select 语句保存在数据字典中。 视图数据来自定义视图的查询中使用的表，使用视图动态生成，因此基表数据发生了改变时，视图也会跟着改变，同时对视图数据的修改也会影响基表的数据。  2 优点 #   简单： 使用视图的用户完全不需要关心后面对应的表结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全： 使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单实现。 数据独立： 一旦视图的结构定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响，源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。  3 相关操作 #  3.1 创建视图 #  3.1.1 语法 #  -- 创建视图 CREATE VIWE 视图名称 AS SQL 语句 -- 完整 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED|MERGE|TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED|LOCAL] CHECK OPTION] 3.1.2 注意事项 #   创建视图需要 CREATE VIEW 的权限，并且对于查询涉及的列有 SELECT 权限，如果使用 CREATE OR REPLACE 或者 ALTER 修改视图，那么还需要该视图的 DROP 权限。 OR REPLACE：在视图存在的情况下可对视图进行修改，视图不存在的情况下可创建视图。 ALGORITHM：表示视图选择算法：  MERGE：  将引用视图语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。   假设有如下视图定义语句：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</guid>
      <description>TCP如何保证传输的可靠性 #   数据包校验。 对失序数据包重新排序（TCP报文具有序列号）。 丢弃重复数据。 应答机制：接收方收到数据之后，会发送一个确认。 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据。 流量控制：确保接收端能够接收发送方的数据，而不会出现缓冲区溢出的情况。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</guid>
      <description>HTTP1.0、HTTP1.1和HTTP2.0的主要区别 #  1 HTTP1.0 和 HTTP1.1 的区别 #    缓存处理：
 在 HTTP1.0 中主要使用header 里的If-Modified-Since,Expires 来作为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。    带宽优化及网络连接的使用：
 HTTP1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象都送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头中添加了range 字段，他允许只请求资源的某个部分，这样就方便了开发者自由的选择，以便于充分的利用带宽。    错误通知的管理：
 在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Confilct）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。    Host 头处理：
 在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求头中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个 IP 地址，HTTP1.1 的请求消息和响应消息都应该支持 Host 字段，请求消息中如果没有 Host 字段会报 400（Bad Request）。    长连接：
  HTTP1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid>
      <description>线程同步 #  1 为什么需要线程同步 #   线程有时候会和其他线程共享一些资源，比如内存、数据库等。 当多个线程同时读写一份共享资源的时候，可能会发生冲突，因此需要线程的同步，多个线程按顺序访问资源。  2 线程同步有哪些方式 #  线程同步主要有四种方式，分别是互斥量（Mutex）、信号量（Semaphore）、事件（Event）、临界区（Critical Section）。
2.1 互斥量 #   互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。 因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问。 当前拥有互斥对象的线程处理完任务后，必须将互斥对象交出，以便其他线程访问该资源。  2.2 信号量 #   信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1。 只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。 线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1. 如果信号量的取值只能是0或1，那么信号量就成了互斥量。  2.3 事件 #   事件允许一个线程在处理完任务后，主动唤醒另外一个线程执行任务。 事件分为手动重置事件和自动重置事件：  手动重置事件被设为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。 自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。    2.4 临界区 #   临界区是一段代码，这段代码使用来访问临界资源的。 任意时刻只允许一个线程对临界资源进行访问。 拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，临界区被释放后，其它线程可继续抢占该临界区。 临界区是一种轻量级的同步机制，是用户态下的对象，即只能在同一进程中实现线程互斥，因此无需在用户态和核心态切换，工作效率比互斥来说要高很多。  3 互斥量和临界区有什么区别 #   互斥量是可以命名的，可以用于不同进程之间的同步。 临界区只能用于同一进程中线程的同步。 创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。  参考文献 #    线程同步有哪些方式？  临界区与互斥量区别。  [多线程] 互斥量和临界区的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</guid>
      <description>TCP长连接和短连接 #  TCP的具体介绍可参考 1.1.1 三次握手和 1.1.2 四次挥手，下面主要介绍TCP的短连接、长连接及其二者的优缺点。
1 短连接 #  1.1 含义 #   短连接是指通信双方有数据交互时，就建立TCP连接，数据发送完成后，则断开此TCP连接。 短连接的模式是$连接 \rightarrow 数据传输 \rightarrow 关闭连接&amp;hellip;建立连接 \rightarrow 数据传输 \rightarrow 关闭连接$。  1.2 优缺点 #  1.2.1 优点 #   管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。  1.2.2 缺点 #   如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。  1.3 适用场景 #   适用于像WEB网站的HTTP服务，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知，所以并发量大，但每个用户无需频繁操作情况下使用短连接比较好。  2 长连接 #  2.1 含义 #   长连接是指在一个TCP连接上可以连续发送多个数据包。 在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。 如果一个给定的连接在两小时内没有任何动作，则服务器就向客户端发送一个探测报文段，客户端必须处于以下4个状态之一：  客户端依然正常运行，并从服务器可达，客户端的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。 客户端已经崩溃，并且关闭或者正在重新启动，在任何一种情况下，客户端的TCP都没有响应，服务器将不能收到对探测的响应，并在75秒后超时，服务器总共发送10个这样的探测，每个间隔75秒，如果服务器没有收到一个响应，他就认为客户端已经关闭并终止连接。 客户端崩溃并已经重新启动，服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户端正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。    2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/</guid>
      <description>DNS #  1 含义 #   DNS，就是 Domain Name System，即域名系统，是互联网上作为域名和 IP 地址相互映射的一个分布式数据库。 DNS 能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。  2 域名解析过程 #    网络客户端就是我们平常使用的电脑，打开浏览器，输入一个域名，比如www.163.com，这时，我们的电脑会发出一个 DNS 请求到本地 DNS 服务器，本地 DNS 服务器一般都是我们的网络接入服务器商提供，比如中国电信、中国移动。 查询www.163.com 的DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询他的缓存记录，如果缓存中有此条记录，就可以直接返回结果，如果没有，本地 DNS 服务器还要向 DNS 根服务器进行查询。 根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。 本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是 .com 域服务器，.com 域服务器收到请求之后，也不会直接返回域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你的域名的解析服务器的地址。 最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址的对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。  3 DNS 劫持 #  3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/</guid>
      <description>协程 #  1 含义 #   协程是一种轻量级线程，位于用户态，完全由用户自己控制。   2 特点 #   线程的切换由操作系统负责调度，协程由用户进行调度，因此减少了上下文切换，提高了效率。 线程的默认栈大小是1M，而协程更轻量，接近1K，因此可以在相同的内存中开启更多的协程。 由于在同一个线程上，可以避免竞争关系而使用锁。 适用于 I/O密集型的场景，不适用于计算密集型的场景。  3 注意事项 #  3.1 协程中不能调用导致线程阻塞的操作 #   假设协程运行在线程之上，并且协程调用了一个阻塞IO操作。 由于操作系统并不知道协程的存在，只知道线程，因此在协程调用阻塞IO的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度。 因此，在协程中不能调用导致线程阻塞的操作，也就是说，协程只有和异步IO结合起来，才能发挥最大的作用。  3.2 在协程中调用阻塞IO操作的处理方式 #   在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，同时将当前协程休眠（让出执行权），等执行完成之后，再唤醒协程，让协程去读取结果，这其实和多线程没有太大区别。 对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。  4 线程与协程的比较 #   线程占用的资源初始时是1MB，固定不可变，协程占用的资源初始时一般为2KB，可随需求而增大。 线程的调度是由操作系统的内核完成，协程的调度是由用户来完成。 线程资源占用太高，频繁创建销毁会带来严重的性能问题，协程资源占用小，不会带来严重的性能问题。 线程需要用锁来保证数据的一致性和可见性，协程不需要多线程的锁机制，因为只有一个线程，所以不存在同时写变量冲突，所以执行效率比多线程高很多。  5 参考文献 #    什么是协程？  一文读懂什么是进程、线程、协程。  什么是协程？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</guid>
      <description>HTTPS加密和认证过程 #  1 为什么要加密 #   因为HTTP 的内容是明文传输的，明文数据会经过中间代理服务器、路由器、WIFI 热点、通信服务运行商等多个物理节点。 如果信息在传输过程中被劫持，传输的内容就完全暴露了，同时劫持者还可以篡改传输的信息切不被对方察觉，这就是中间人攻击。 所以我们才需要对信息进行加密。  2 常见的加密算法 #  常见的加密算法可以分成三类，分别是对称加密算法、非对称加密算法和Hash 算法。
2.1 对称加密算法 #  2.1.1 含义 #    对称加密算法指加密和解密使用相同密钥的加密算法，简单说就是有一个密钥，他可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。 对称加密的优缺点为：  优点：  加解密的效率高、加密速度快。   缺点：  对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。      2.1.2 常用算法 #  常用的对称加密算法包括DES、3DES、AES、DESX、Blowfish、RC4、RC5、RC6，下面以 DES、3DES、AES 为例进行简单介绍：
 DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）：基于 DES，对一块数据采用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快、安全级别高。  2.1.3 对称加密用于 HTTPS 连接是否可行 #   如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以保证的。 然而最大的问题就是这个密钥怎么让传输的双方都知晓，同时不被别人知道，如果由服务器生成一个密钥并传输给浏览器，那么在这个传输过程中密钥被别人劫持到手了怎么办，因为之后他就能用密钥解开双方传输的任何内容，所以这么做当然不行。 换种思路，试想一下，如果浏览器内部就预存了网站 A 的密钥，且可以确保除了浏览器和网站 A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有 HTTPS 网站的密钥就行了，这么做显然不现实，所以我们就需要 非对称加密。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>异常控制流 #  1 什么是控制流 #   假设在计算机运行过程中，其指令序列为 $a_1,a_2,&amp;hellip;,a_n$，则每次从 $a_n$ 到 $a_{n+1}$ 的过渡叫做**控制转移**，而 $a_1,a_2,&amp;hellip;,a_n$ 这条**完整的控制转移序列**叫做处理器的**控制流**。 所以，控制流说白了就是CPU 执行指令的序列。  2 什么是控制流的异常 #   程序在加载进内存时指令序列也会跟着一同被加载。 指令序列在内存中是相邻的，程序计数器在通常情况下会依次加载这些相邻的指令交给 CPU 执行。 但是在某些情况下可能会发生突变，从而打破 CPU 本应该顺序执行这些指令序列的预期行为，这种突变就叫做控制流的异常，简称ECF（Exception Control Flow）。  3 理解异常控制流的必要性 #   ECF 是操作系统用来实现 I/O、进程和虚拟内存的基本机制。 陷阱和系统调用都是 ECF 的一种。 操作系统实现并发机制依靠的也是 ECF。 类似于 Java 的 try/catch 异常机制，属于应用层的 ECF。  4 异常处理程序 #  4.1 基本概念 #   异常处理程序就是处理异常的程序。 相关物理含义：  CPU 的状态：  CPU 的状态就是指其内部特定范围的一些数据位和电信号，CPU 状态的变化可以理解为这些数据位或电信号的变化。 CPU 状态的变化可能与当前执行的应用程序的指令有关，比如虚拟内存缺页、算术溢出、除以 0 等，也有可能与当前执行的指令无关，比如I/O 请求完成。   CPU 的事件：  CPU 的状态变化就是 CPU 的事件。   异常表：  在任何情况下，当 CPU 检测到有事件发生时，会通过一张映射表，找到一个被设计用来专门处理这类事件的操作系统的子程序，这个子程序就是异常处理程序。 而记录不同类型的异常处理程序之间的映射关系的映射表就是异常表。 异常表中对于每种可能类型的异常都分配了一个唯一的非负整数的异常号。 其中一些号码是由CPU 的设计者设计的，比如零除异常、缺页异常、内存访问违规异常、算术运算溢出异常，这些属于系统无关的异常。 而有一些异常号码则是由操作系统内核的设计者分配的，比如系统调用和IO 设备的信号，这些属于系统相关的异常。 操作系统在启动时会整合 CPU 异常和内核异常，并且将其记录成一张完整的异常表加载到内存中，然后将其起始地址放在一个叫做异常表基址寄存器的一个特殊的 CPU 寄存器里。      异常处理的基本过程：  假设当前 CPU 正在执行的指令为lcurr，此时CPU 检测到一个异常发生，进而 CPU 转去执行异常处理程序的相关指令。 当异常处理程序执行完之后，根据其处理结果可能有几种动作：  继续执行异常发生时正在执行的应用程序的指令 lcurr。 执行异常发生时正在执行的应用程序的指令 lcurr 的下一条指令 lnext。 该应用程序直接被终止，不再执行其指令。     无论是硬件触发了异常还是软件触发了异常，剩下的工作都是由异常处理程序在软件中完成。 在处理程序处理完事件之后，可以通过执行一条特殊的“从中断返回”的指令可选的返回到被中断的程序。  4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</guid>
      <description>常见网络攻击 #  常见的网络攻击主要包括跨站脚本攻击（XSS）、注入攻击、模糊测试、零日攻击、路径（目录）遍历攻击、分布式拒绝服务攻击（DDos）、中间人攻击、暴力破解攻击、使用未知代码或第三方代码攻击、网络钓鱼攻击。
1 跨站脚本攻击（XSS） #  1.1 含义 #   跨站脚本攻击，Cross-Site Scripting，简称 XSS，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行，利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 XSS 的本质是恶意代码未经过滤，与正常的代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行，而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 在部分情况下，由于输入的限制，注入的恶意脚本比较短，但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。 在处理输入时，以下内容都不可信：  来自用户的 UGC 信息。 来自第三方的链接。 URL 参数。 POST 参数。 Refer（可能来自不可信的来源）。 Cookie（可能来自其他子域注入）。    1.2 分类 #  根据攻击的来源，XSS 攻击可分为存储型、反射型和DOM 型三种。
1.2.1 存储型 XSS #   存储型 XSS 的攻击步骤为：  攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。   这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。  1.2.2 反射型 XSS #   反射型 XSS 的攻击步骤为：  攻击者构造特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。   反射型 XSS 和存储型 XSS 的区别是存储型 XSS 的恶意代码在数据库里，反射型 XSS 的代码在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等，由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>IO多路复用 #  1 什么是文件描述符 #   文件描述符在形式上是一个非负整数。 实际上，他是一个索引值，指向内核为每一个进程所维护该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符。  2 水平触发和边缘触发 #  2.1 含义 #   水平触发（LT, Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知。 边缘触发（ET, Edge Trigger）模式下，当文件描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪。  2.2 区别 #   边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。  2.3 为什么边缘触发一定要用非阻塞 IO #   避免由于一个描述符的阻塞读/写操作让处理其他描述符的任务出现饥饿状态。  3 五种 IO 模型 #  常见的 IO 模型主要有五种，分别是阻塞 IO（Blocking IO, BIO）、非阻塞 IO（NoneBlocking IO, NIO）、IO 多路复用（IO Multiplexing）、信号驱动 IO（Signal Driven IO）、异步 IO（Asynchronous IO, AIO）。
3.1 阻塞 IO #   阻塞 IO 是一种最传统的 IO 模型，在读写数据过程中会发生阻塞现象。 当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，此时用户线程就会处于阻塞状态，同时用户线程会交出 CPU。 当数据就绪之后，内核会将数据拷贝到用户线程，此时用户线程才会解除阻塞状态。 比如 A 同学排队买票，他只能排队买上票才可以离开，这一过程就可以看成是使用了阻塞 IO 模型，因为在没买到票之前，他不能离开队伍做别的事情。 很显然，阻塞 IO 模型是同步的。   3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/</guid>
      <description>REST #  1 含义 #   REST 这个词，是Roy Thomas Fielding 在他 2000 年的博士论文中提到的。 Fielding 将他对互联网软件的架构原则，定义为 REST（Representational State Transfer），即表现层状态转化，如果一个架构符合 REST 原则，就称它为 RESTful 架构。 要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，他的每一个词代表了什么涵义，如果我们把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计了。 REST 架构主要有三个关键词，分别是资源（Resources）、表现层（Representation）、状态转化（State Transfer）：  资源：  REST 的名称表现层状态转化中，省略了主语，表现层其实指的是资源的表现层。 所谓资源，就是网络上的一个实体，或者说是网络上的一个具体信息，他可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。 我们可以用一个 URI（统一资源标识符）指向他，每种资源对应一个特定的 URI，要获取这个资源，访问他的 URI 就可以，因此URI 就成了每一个资源的地址或独一无二的标识符。   表现层：  资源是一种信息实体，他可以有多种外在表现形式，我们把资源具体呈现出来的形式，叫做他的表现层。 比如，文本可以用 TXT 格式表现，也可以用 HTML、XML、JSON 格式表现，甚至可以采用二进制格式。 URI 只代表资源的位置，他的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对表现层的描述。   状态转化：  访问一个网站，就代表了客户端和服务器的一个互动过程，在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP 协议，是一个无状态的协议，这意味着，所有的状态都保存在服务器端，因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生状态转化，而这种转化是建立在表现层之上的，所以就是表现层状态转化。     综合上面的解释，我们总结一下什么是 RESTful 架构：  每一个 URI 代表一种资源。 客户端和服务器之间，传递这种资源的某种表现层。 客户端通过四个 HTTP 动词（GET 获取资源、POST 新建或更新资源、PUT 更新资源、DELETE 删除资源），对服务器端资源进行操作，实现表现层状态转化。    2 特点 #    客户-服务器：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</guid>
      <description>用户态和内核态 #  1 什么是用户态和内核态 #   为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，CPU划分了用户态和内核态两个权限等级：  用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他程序获取。 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。   所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换回用户态并返回系统调用的结果。  2 为什么要区分用户态和内核态 #   主要是为了区别执行特权指令和非特权指令。 在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如清内存、设置时钟等。 所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。  3 用户态和内核态之间如何切换 #  用户态和内核态之间的切换主要有三种方式，分别是系统调用、中断、异常。
3.1 系统调用 #   这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。 而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现的。  3.2 中断 #   当外围设备完成用户请求操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。 如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换，比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作。  3.3 异常 #   当CPU在执行运行在用户态下的程序时，发生了某些事不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。  参考文献 #    什么是用户态和内核态？  用户态和核心态的概念以及为什么要区别？以及两者之间的切换？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/</guid>
      <description>索引 #  1 含义 #   索引是存储数据库表中的一列或多列的值并对其进行排序的一种数据结构，他通过缩小一张表中需要查询的记录的数目来加快搜索的速度，如果没有索引，数据库将不得不进行全表扫描。 索引相当于图书中的目录，可以根据目录上的页码快速找到所需的内容，提高查询速度。  2 优缺点 #  2.1 优点 #   通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，避免进行全表的数据扫描，大大减少遍历匹配的行数，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。  2.2 缺点 #   创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占用物理空间，数据量越大，占用空间越大。 会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护。  3 在哪些列建立索引 #   在经常需要搜索的列上，可以加快搜索的速度。 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。 在经常需要根据范围进行搜索的列上，因为索引已经排序，其指定的范围是连续的。 在经常需要排序的列上，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 在经常使用在 where 子句的列上，因为这样可以加快条件的判断速度。 在经常需要统计或分组的列上。  4 不在哪些列创建索引 #   对于那些在查询中很少使用的列不应该创建索引，因为既然这些列很少使用到，因此有索引或者无索引并不能提高查询速度，相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少取值的列也不应该创建索引，因为由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大，增加索引并不能明显加快检索速度。 对于那些定义为 text、image、bit 数据类型的列不应该创建索引，因为这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是互相矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能，当减少索引时，会提高修改性能，但是会降低检索性能。  5 什么情况下索引会失效 #    在 where 子句中进行 null 值判断：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/</guid>
      <description>概述 #  1 设计模式分类 #   设计模式可以分为三大类，分别是创建型模式、结构型模式、行为型模式。
1.1 创建型模式 #  创建型模式共五种，分别是：
 工厂模式。 抽象工厂模式。 单例模式。 建造者模式。 原型模式。  1.2 结构型模式 #  结构型模式共七种，分别是：
 适配器模式。 装饰器模式。 代理模式。 外观模式。 桥接模式。 组合模式。 享元模式。  1.3 行为型模式 #  行为型模式共十一种，分别是：
 策略模式。 模板模式。 观察者模式。 迭代子模式。 责任链模式。 命令模式。 备忘录模式。 状态模式。 访问者模式。 中介者模式。 解释器模式。  参考文献 #    设计模式面试题（总结最全面的面试题！！！）。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</guid>
      <description>B 树、B+树索引算法原理 #  1 为什么要用 B 树、B+ 树索引 #    常用的数据结构如二叉查找树（Binary Search Tree, BST）的每个节点只能容纳一个数据，导致树的高度很高，逻辑上挨着的节点的数据可能离得很远，如果在内存中操作数据的话，这样问题并不大，但是由于读写磁盘的速度相比内存慢很多，每次读写磁盘的单位要比读写内存的最小单位大很多。
  因此，对应的数据结构应该尽量的满足局部性原理，即当一个数据被用到时，其附近的数据也通常会马上被使用，因此，逻辑上相邻的数据在物理上也尽量存储在一起，这样才能减少读写磁盘的数量。
  因此，对比起一个节点只能存储一个数据的 BST 类数据结构来说，要求这种数据结构在形状上更胖，更加扁平，即每个节点能容纳更多的数据，这样就能降低树的高度，同时让相邻的数据都能尽量的存储在物理上也相邻的硬盘空间上，减少磁盘读写。
  以下图为例，图中从根节点出发，查找数据 14 的过程中，经过的第二节点中有键值 [3,7,13]，这三个值在逻辑上是相邻的，如果他们在磁盘上的存储也能做到在物理上相邻，那么只需要一次读操作就能把这个节点的数据从磁盘上加载到内存中进行数据比较，这样整个过程就只需要两次磁盘读操作，这种数据结构具有两个特点：
 高扇出： 临近键值的数据局部性更好。 低高度： 遍历期间的寻道次数更少。     B 树和 B+ 树就是两种利用磁盘局部性原理进行优化的树结构。
  2 B 树 #  2.1 B 树的定义及性质 #    在 B 树种，分为两种节点：
 内部节点（Internal Node）： 存储了数据以及指向其子节点的指针。 叶子节点（Leaf Node）： 叶子节点只存储数据，没有子节点。    一个数据，既可能存在内部节点上，也可能存在叶子节点上，这一点是与 B+ 树最大的不同，B+ 树只会将数据存储在叶子节点上。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/</guid>
      <description>索引组织表 #   在InnoDB存储引擎中，表都是按照主键顺序组织存放的，这种存储方式的表称为索引组织表（Index Organzied Table）。 在InnoDB存储引擎中，每张表都有个主键（Primary Key），如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：  首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，该列即为主键，当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键，这里需要注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序，例如下面的例子：   建表及插入数据语句为：
create table z( a int not null, b int null, c int not null, d int not null, unique key(b), unique key(d), unique key(c) ) engine=innodb; insert into z select 1,2,3,4; insert into z select 5,6,7,8; insert into z select 9,10,11,12;   上面示例中创建了一张表 z，有 a、b、c、d四列，b、c、d三列都有唯一索引，不同的是 b列允许NULL值，由于没有显式地定义主键，因此会选择非空的唯一索引，虽然 c、d列都是非空唯一索引，都可以作为主键的候选，但是在定义的过程中，由于 d列首先定义为唯一索引，因此InnoDB存储引擎将 d列视为主键。
  可以通过下面的SQL语句判断表的主键值，其中 _rowid可以显示表的主键，但是只能用于查看单个列作为主键的情况，不能用于多列组成主键的情况。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>InnoDB和MyISAM的区别 #  存储引擎主要用于从数据库中读取数据，MySQL 支持很多 存储引擎，但是 MyISAM 和 InnoDB 是使用最广泛的两个存储引擎，他们每一个都有各自的优缺点，因此选取一个适合我们应用的存储引擎来说非常重要。
 MySQL 5.5.5 之前的版本的默认存储引擎是 MyISAM，5.5.5 及其之后的版本的默认存储引擎是 InnoDB。
 MyISAM 和 InnoDB 的主要区别包括参照完整性（Referential Integrity）、事务和原子性（Transactions &amp;amp; Atomicity）、表锁定与行锁定（Table-locking vs Row-locking）、可靠性（Reliability）、全文索引（FULLTEXT Indexing）、缓存（Caching）、ACID 属性（ACID property）七个方面。
1 参照完整性 #   参照完整性确保了表与表之间的关系的一致性，比如一张表拥有指向另外一张表的外键，当被指向的表发生更改时，这些更改也会级联到链接表。 InnoDB 是一个关系型数据库管理系统（RDBMS），因此InnoDB 支持外键和参照完整性，包括级联删除和更新，但是MyISAM 不支持外键。  2 事务和原子性 #   MyISAM 不支持事务，但是InnoDB 支持。 因此，当一张表使用 MyISAM 引擎并且操作在执行的过程中被终止了，已经被更改的行将会被永久更改，即使操作还没有完成，但是当一张表是使用 InnoDB 引擎并且操作在执行的过程中被终止了，因为使用了事务，因此当我们提交之前，所有的更改将不会生效。 当我们使用 MyISAM 引擎时，所有的更改不能回滚，但是当我们使用 InnoDB 引擎时，更改是可以被回滚的。  3 表锁定和行锁定 #   当在MyISAM 引擎的表中执行一个查询时，整张表都会被锁定，这意味着后续查询只能等到当前查询结束之后才会被执行，当我们正在读一张大表时，而且同时这张表会有其他频繁的读写操作，这可能导致大量的查询被积压。 当在InnoDB 引擎的表中执行一个查询时，只有相关的行才会被锁定，表中的其他行可以继续进行其他操作，这意味着当查询不使用同一行时，可以在一个表上同时运行。  4 可靠性 #   MyISAM 引擎不提供数据完整性，比如硬件损坏（Hardware Failures）、突然关机（Unclean Shutdowns）或者操作取消（Canceled Operations）都会导致数据损坏，这就需要对表进行完全修复或者重建索引和表。 InnoDB 引擎使用事务日志（Transactional Log）、双写缓冲区（Double-Write Buffer）以及自动校验和验证（Automatic Checksum and Validation）来防止数据损坏，当 InnoDB对数据进行更改之前，他会在事务之前把数据记录到一个名为 ibdata1 的系统表空间文件（System Tablespace File），如果 MySQL 服务器发生崩溃，InnoDB 将会根据这些日志来自动恢复数据。  5 全文索引 #   在 MySQL 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/</guid>
      <description>Checkpoint技术 #  1 前言 #   缓冲池设计的目的是为了协调 CPU 速度与磁盘速度的鸿沟，因此页的操作首先都是在缓冲池中完成的。 如果一条DML 语句，如UPDATE 或DELETE改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新，数据库需要将新版本的页从缓冲池刷新到磁盘。 倘若每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的，若热点数据集中在某几个页中，那么数据库的性能将变得非常差，同时，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。 为了避免发生数据丢失的问题，当前事务数据库系统普遍都采用了WAL（Write Ahead Log）策略，即当事务提交时，先写 重做日志（Redo Log），再修改页，当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复，这也是 事务 ACID中 D（Durability，持久性）的要求。  2 为什么需要 Checkpoint 技术 #   思考下面的场景，如果重做日志可以无限的做大，同时缓冲池也足够大，能够缓冲所有数据库的数据，那么是不需要将缓冲池页的新版本刷新回磁盘，因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻，但是这需要两个前提条件：  缓冲池可以缓存数据库中所有的数据。  有经验的用户都知道，当数据库开始建的时候，表中没有任何数据，缓冲池的确可以缓存所有的数据库文件。 然而随着市场的推广，用户的增加，产品越来越受到关注，使用量也越来越大，这时负责后台存储的数据库的容量注定会不断增大。 当前3TB的MySQL数据库已并不少见，但是3TB的内存却非常少见，因此这一假设对于生产环境应用中的数据库是很难得到保证的。   重做日志可以无限增大。  这个也许是可以的，但是对成本要求太高，同时不便于运维，因为我们不知道什么时候重做日志是否已接近于磁盘可使用空间的阈值，并且要让存储设备支持可动态扩展也是需要一定的技巧和设备支持的。     即使上面两个条件都满足，那么还有一个条件需要考虑，那就是宕机后数据库的恢复时间，当数据库运行了几个月甚至几年时，这时发生宕机，重新应用重做日志的时间会非常久，此时恢复的代价也会非常大，此时，就需要使用Checkpoint（检查点）技术了。  3 解决的主要问题 #  Checkpoint技术的目的是解决以下几个问题：
 缩短数据库的恢复时间。  当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘，故数据库只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。   缓冲池不够用时，将脏页刷新到磁盘。  当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。   重做日志不可用时，刷新脏页。  重做日志不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。 重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。 若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。    4 分类 #  在InnoDB存储引擎中，Checkpoint发生的时间、条件及脏页的选择等都非常复杂，而Checkpoint所做的事情无外乎是将缓冲池中的脏页刷回到磁盘，不同之处在于每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发Checkpoint，在InnoDB引擎内部，有两种Checkpoint，分别为Sharp Checkpoint、Fuzzy Checkpoint。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/</guid>
      <description>宕机恢复原理 #  1 前言 #  MySQL 保证数据不丢失的能力主要体现在两个方面：
 能够恢复到任何时间点的状态。  对于这一点，只要保留足够的 Binlog，就可以通过重跑 Binlog 来实现。   能够保证 MySQL 在任何时间段突然崩溃，重启之后之前提交的记录都不会丢失。  对于这一点，也就是本文所说的宕机恢复，即在 InnoDB 存储引擎中，事务提交过程中任何阶段，MySQL 突然崩溃，重启后都能保证事务的完整性，已提交的事务不会丢失，未提交完整的数据会自动进行回滚，这个能力依赖的就是 Redo Log和 Undo Log两个日志。 因为宕机恢复主要体现在事务执行过程中突然崩溃，重启后能保证事务的完整性，所以在讲解具体的原理前，先了解一下 MySQL 事务执行有哪些关键阶段，后面才能依据这几个阶段来进行解析，下面以一条更新语句的执行流程为例来进行说明：  从内存中找出这条数据记录，对其进行更新。 将旧数据记录到 Undo Log 中。 将对数据页的更改记录到 Redo Log Buffer 中，状态为prepare 状态。 将逻辑操作记录到 Binlog Cache 中。 将 Redo Log 中的更改记录设置为commit 状态。  对于内存中的数据和日志，都是由后台线程来进行处理，当触发到落盘规则后再异步进行刷盘。
       2 WAL 技术 #   MySQL更改数据的时候，不是直接写磁盘文件中的数据，因为直接写磁盘文件是随机写，开销大性能低，没办法满足 MySQL 的性能要求，因此会设计成先在内存中对数据进行更改，再异步落盘。 但是内存总是不可靠，万一断电重启，还没来得及落盘的内存数据就会丢失，所以还需要加上写日志这个步骤，万一断电重启，还能通过日志中的记录进行恢复。 写日志虽然也是写磁盘，但是他是顺序写，相比随机写开销更小，能提升语句的执行性能。 这个技术就是大多数存储系统都会用的WAL（Write Ahead Log）技术，也称为日志先行的技术，指的是对数据文件进行修改前，必须将修改先记录日志，这样可以保证数据的一致性和持久性，也能提升语句执行性能。  3 核心日志模块 #  更新 SQL 执行过程中，总共涉及 MySQL 日志模块其中的三个核心日志，分别是 Redo Log（重做日志）、Undo Log（回滚日志）、Binlog（归档日志），下面将会对的三个日志进行一个概要介绍，详细的内容可以参考 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid>
      <description>数据库优化 #  1 SQL 语句的优化 #   优化 SQL 语句时可以按照以下的步骤来进行：
 首先分析慢查询日志，这里面记录了响应时间超过阈值 long_query_time 的 SQL 语句，通过日志找出 IO 大的 SQL 以及发现未命中索引的 SQL。 然后使用 EXPLAIN 对慢查询 SQL 进行分析，通过EXPLAIN 命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题。     应尽量避免在 WHERE 子句中使用 !=、&amp;lt;、&amp;gt;操作符或对字段进行 null 值判断，否则数据库引擎将放弃使用索引而进行全表扫描。
  只返回必要的列，最好不要用 SELECT * 语句。
  只返回必要的行，使用 LIMIT 语句来限制返回的数据。
  高并发高性能的应用中尽量对关联查询分解为单表查询，然后将结果在应用程序中进行关联，例如下面这个查询：
select * from tag join tag_post on tag_post.tag_id=tag.id join post on tag_post.post_id=post.id where tag.tag=&amp;#39;mysql&amp;#39;; 可以分解成下面这些查询来代替：
select * from tag where tag=&amp;#39;mysql&amp;#39;; select * from tag_post where tag_id=1234; select * from post where id in(123,456,567,9989,8909); 这种用分解关联查询的方式重构查询具有如下优势：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
      <description>分库分表 #  1 为什么要进行分库分表 #    在业务数据量比较少的时代，我们使用单机数据库就能满足业务使用，随着业务请求量越来越多，数据库中的数据量快速增加，这时单机数据库已经不能满足业务的性能要求，数据库主从架构随之应运而生。
  主从复制是将数据库写操作和读操作进行分离，使用多个只读实例（Slaver Replication）负责处理读请求，主实例（Master）负责处理写请求，只读实例通过复制主实例的数据来保持与主实例的数据一致性，由于只读实例可以水平扩展，所以更多的读请求不成问题。
  随着云计算、大数据时代的到来，事情并没有完美的得以解决，当写请求越来越多，主实例的写请求变成主要的性能瓶颈。
  如果仅仅通过增加一个主实例来分担写请求，写操作如何在两个主实例之间同步来保证数据一致性，如何避免双写，此时问题会变得更加复杂，这时就需要用到分库分表（Sharding），对写操作进行切分来解决，如下图所示：
  上图中的 DDM 为华为云的中间件产品，全称是 Distributed Database Middleware，作为 RDS（Relational Database Service）的前置分布式数据库访问服务，彻底解决了数据库的扩展性问题，对应用透明地实现海量数据的高并发访问，实现了读写分离和分库分表。
   2 分库分表的切分方式 #   数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式：  一种是按照不同的表（或者 Schema）来切分到不同的数据库（主机）上，这种切分方式可以称之为数据的垂直（纵向）切分。 另外一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。   垂直切分最大的特点就是规则简单，实施也更为方便，尤其适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统，在这种系统中，可以很容易做到将不同业务模块所使用的的表拆分到不同的数据库中，根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰。 水平切分相对于垂直切分来说，稍微复杂一些，因为要将同一个表中的不同数据拆分到不同的数据库中，对于应用程序来说，拆分规则本身比根据表名来拆分更为复杂，后期的数据维护也会更为复杂一些。 具体而言，如果单个库太大，这是我们要看是因为表多而导致数据多，还是因为单张表里面的数据多：  如果是因为表多而数据多，则使用垂直切分，根据业务切分成不同的库。 如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按照某种规则切分成多张表，甚至多个库上的多张表。   分库分表的顺序应该是先垂直分，后水平分，因为垂直分更简单，更符合我们处理现实世界问题的方式。  3 垂直切分 #  3.1 含义 #    垂直切分常见有垂直分库和垂直分表两种。
  垂直分库就是根据业务耦合性，将关联度低的表存储在不同的数据库，做法与大系统拆分为多个小系统类似，按业务分类进行独立划分：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
      <description>一致性哈希算法 #  1 传统哈希算法 #  1.1 含义 #   简单地说，哈希就是一个键值对存储，在给定键的情况下，可以非常高效地找到所关联的值，假如我们要根据邮政编码查找城市中的街道名称，一种最简单的实现方式是将此信息以哈希字典的形式进行存储&amp;lt;ZipCode, StreetName&amp;gt;。 当数据太大而无法存储在一个节点或机器上时，系统就会需要多个这样的节点或机器来存储他，比如，使用多个 Web 缓存中间件的系统，对于如何确定哪个key 存储在哪个节点上，最简单的解决方案是使用哈希取模来决定：   给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将 key 放入该节点。
  在获取 key 时，先对 key 进行哈希运算，将其除以系统中的节点数，然后转到该节点并获取值。
  上述过程对应的哈希算法定义如下：
# 下面的 N 为节点数 node_number = hash(key) % N   下图描绘了多节点系统中的传统的哈希取模算法，基于该算法可以实现简单的负载均衡。
     1.2 局限性 #  假设初始时有如下对应关系：
 1.2.1 节点减少的场景 #   在分布式多节点系统中，出现故障很常见，任何节点都可能在没有任何事先通知的情况下挂掉，针对这种情况，我们希望系统只是出现性能降低，正常的功能不会受到影响。 对于原始示例，假设其中 1 个节点出现了故障，这时节点数发生了变化，节点个数从 3 减少为 2，此时表格中的状态发生了变化：  很明显节点的减少会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将会导致节点映射错误，以semlinker 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当出现故障时，节点数减少为 2 个，此时该键对应的节点编号为 0。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>主从复制 #  1 什么是主从复制 #   MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。  2 为什么要主从复制 #   读写分离：  在开发工作中，有时候会遇见某个 SQL 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务。 使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。   数据实时备份：  当系统中某个节点发生故障时，可以方便的故障切换。   高可用 HA。 架构扩展：  随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O 访问频率过高。 有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘 I/O 访问的频率，提高单个机器的 I/O 性能。    3 常见架构模型 #  3.1 一主一从/一主多从 #   一主一从和一主多从是最常见的主从架构模式，一般实现主从配置或者读写分离都可以采用这种架构。 如果是一主多从模式，当b增加到一定数量时，Slave 对 Master 的负载以及网络带宽都会成为一个严重的问题。   3.2 多主一从 #   MySQL 5.7 开始支持多主一从的模式，将多个库的数据备份到一个库中存储。   3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>斐波那契数列 #  1 题目 #  写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 示例 2：
输入：n = 5 输出：5 提示：
 0 &amp;lt;= n &amp;lt;= 100     遇到求总数的问题时一般考虑用动态规划来求。
  这类问题的基本思路就是先寻找状态之间的关系，确定状态转移方程，然后使用暴力递归的方法求解，接着使用带有备忘录的递归、dp 数组的迭代解法进行优化。
  类似的题目还有：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/</guid>
      <description>事务的概念和特性 #  1 事务的概念 #   数据库中的事务是一个操作序列，包含了一组数据库操作命令。 事务把这一组命令作为一个整体一起向系统提交或撤销操作请求，即这一组命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。  2 事务的特性 #   注：如果没有特别说明，下面的事物的特性的原理指的都是MySQL的InnoDB引擎。
 事务具有 4 个特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），这 4 个特性通常简称为ACID。
2.1 原子性 #  2.1.1 含义 #   事务开始后的所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。 事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。  2.1.2 实现原理 #   InnoDB 引擎使用Undo Log（回滚日志）来保证原子性操作，我们对数据库中的每一条数据的改动（Insert、Delete、Update）都会被记录到 Undo Log 中，比如以下这些操作：  插入一条记录时，至少要把这条记录的主键记下来，之后回滚的时候只需把这个主键对应的记录删掉就好了。 删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。   当事务执行失败或者调用了 rollback 方法时，就会触发回滚事件，利用 Undo Log 中的记录将数据回滚到修改之前的样子。  2.2 一致性 #  2.2.1 含义 #   事务开始前和结束后，数据库的完整性约束没有被破坏。 比如A 向 B 转账，不可能 A 扣了钱，B 却没收到。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</guid>
      <description>Redis为什么这么快 #    完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
  数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的。
 Redis 的具体数据类型及数据结构可参考 3.1.2 Redis 数据类型。
   采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
 Redis 为什么采用单线程，单线程有什么优点？
 因为Redis 的操作都是基于内存的，绝大部分请求是纯粹的内存操作，非常迅速。 而CPU 的速度是远大于内存的速度的，因此CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。 而使用单线程可以省去多线程时 CPU 上下文切换的时间，也不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有死锁问题导致的性能消耗。 对于内存系统来说，多次读写都是在一个 CPU 上，没有上下文切换效率就是最高的。 既然单线程容易实现，而且CPU 不会成为瓶颈，那么就顺理成章的采用单线程的方案了。     使用多路 I/O 复用模型，非阻塞 IO。
  使用底层模型不同，他们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制，因为一般的系统调用函数的话，会浪费一定的时间去移动和请求。
  参考文献 #    几率大的 Redis 面试题（含答案）。  Redis 面试题（总结最全面的面试题）。  面试官：Redis 为什么这么快？除了基于内存操作还有其他原因吗？  Redis 是单线程的，但 Redis 为什么这么快？  Redis 为什么是单线程？为什么有如此高的性能？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>Redis实现分布式锁 #  1 背景 #   我们日常在电商网站购物时经常会遇到一些高并发的场景，例如电商 APP 上经常出现的秒杀活动、限量优惠券抢购，还有去哪儿网的火车抢票系统等，这些场景有一个共同特点就是访问量激增，虽然在系统设计时会通过限流、异步、排队等方式优化，但整体的并发还是平时的数倍以上，为了避免并发问题，防止库存超卖，给用户提供一个良好的购物体验，这些系统中都会用到锁的机制。 对于单进程的并发场景，可以使用编程语言及相应的类库提供的锁，如 Java 中的Synchronized 语法以及ReentrantLock 类等，避免并发问题。 如果在分布式场景中，实现不同客户端的线程对代码和资源的同步访问，保证在多线程下处理共享数据的安全性，就需要用到分布式锁技术。   2 含义 #   分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰保证一致性。 一个相对安全的分布式锁，一般需要具备以下特征：  互斥性：互斥是锁的基本特征，同一时刻锁只能被一个线程持有，执行临界区操作。 超时释放：通过超时释放，可以避免死锁，防止不必要的线程等待和资源浪费。 可重入性：一个线程在持有锁的情况可以对其再次请求加锁，防止锁在线程执行完临界区操作之前释放。 高性能和高可用：加锁和释放锁的过程性能开销要尽可能的低，同时也要保证高可用，防止分布式锁意外失效。    3 实现方式 #   使用 Redis 作为分布式锁，本质上要实现的目标就是一个进程在 Redis 里面占据了一个仅有的“茅坑”，当别的进程也想来“占坑”时，发现已经有人蹲在那里了，就只好放弃或者等待稍后再试。 目前基于 Redis 实现分布式锁主要有两大类，一类是基于单机，另一类是基于多机，不管是哪种实现方式，均需实现加锁、解锁、锁超时这三个分布式锁的核心要素。  3.1 基于 Redis 单机实现的分布式 #  3.1.1 使用 SETNX 指令 #    最简单的加锁方式就是直接使用 Redis 的 SETNX 指令，该指令只有在 key 不存在的情况下，将 key 的值设置为 true，若 key 已经存在，则 SETNX 命令不做任何动作。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</guid>
      <description>缓存穿透、缓存击穿、缓存雪崩 #  1 缓存穿透 #  1.1 含义 #   缓存穿透是指数据库中没有符合条件的数据，缓存服务器中也就没有缓存数据，导致业务系统每次都绕过缓存服务器查询下游的数据库，缓存服务器完全失去了其应有的作用。 如果黑客试图发起针对该 key 的大量访问攻击，数据库将不堪重负，最终可能导致崩溃宕机。 从下图可以看出查询时是直接穿过缓存到达下游数据库，大致业务流程如下图所示：   1.2 解决方法 #  1.2.1 接口层增加校验 #   在接口层增加校验，不合法的参数直接返回。 不相信任务调用方，根据自己提供的接口规范来，作为被调用方，要考虑可能任何的参数传值。  1.2.2 存储空值或默认值 #   虽然数据库中没有符合条件的数据，可以考虑缓存空值或者适合业务的默认值，来缓解这种情况。 为了降低数据的不一致，需要注意两点：  缓存的过期时间需要设置的比较短。 当数据库数据更新时也需要及时更新缓存中对应的数据。    1.2.3 为 IP 设置访问阈值 #   正常用户不会这样暴力攻击，只有是恶意者才会这样做，可以在网关 Nginx 作一个配置项，为每一个 IP 设置访问阈值。  1.2.4 使用布隆过滤器 #  1.2.4.1 背景 #   假如我们需要过滤某些不安全的网页，现在有 100 亿个黑名单页面，每个网页的 URL 最多占用 64 字节，现要设计一种网页过滤系统，可以根据网页的 URL 判断该网页是否在黑名单上，要求该系统允许有万分之一以下的判断错误率，并且使用的额外空间不要超过 30G。 可以采用以下几种方案：  将访问过的 URL 保存到数据库：每次需要过滤网页就需要启用一个数据库 select 查询，且当数据量变得非常庞大后，关系型数据库查询的效率会变得很低。 用 HashSet 将访问过的 URL 保存起来：这样只需要接近 $O(1)$ 的代价就可以查到一个 URL 是否被访问过了，但是内存消耗太大（存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，一旦我们的值很多，例如上亿的时候，那么 HashSet 占据的内存大小就变得很可观了）。 URL 经过 MD5 或者 SHA-1 等单向哈希后再保存到 HashSet 数据库：字符串经过 MD5 散列处理后的信息摘要长度只有 128bit，SHA-1 处理后也只有 160bit，因此方法 3 比方法 2 节省了好几倍的内存。 BitMap 的方法：建立一个 BitSet，将每个 URL 经过哈希函数映射到某一位，这样消耗内存是比较少的，但缺点是单一哈希函数发生冲突的概率太高。    1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-Runnable%E5%92%8C-Thread%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-Runnable%E5%92%8C-Thread%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Runnable和 Thread的区别 #  Runnable 和 Thread 本身并没有实质的区别，除此之外，主要有以下区别：
 Runnable 的使用方式是实现其接口，Thread 的使用方式是继承其类，二者都需要实现 run 方法。 Runnable 接口支持多继承，但基本上用不到。 Thread 实现了 Runnable 接口并进行了扩展，而 Thread 和 Runnable 的市值是实现的关系，不是同类的东西，所以 Runnable 和 Thread 本身并没有可比性。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</guid>
      <description>运行时数据区域 #  JVM 运行时数据区域主要有 程序计数器、 Java 虚拟机栈 、本地方法栈、堆、方法区 、运行时常量池 六个区域。
![]../../media/202105//1621914617.836086.png)
1 程序计数器（Program Counter Register） #   由于 JVM 同时可以处理多个线程，所以就涉及到一些线程调度，当 CPU 暂停运行线程把时间片让给另一个线程的时候，我们需要保存这个线程被暂停执行前的一些现场状态，需要记录当前执行到哪一行字节码了，所以具备保存现场的功能。 每条线程都有自己的PC 寄存器，在任意时刻虚拟机只会执行一个方法，如果执行的方法不是 Native 方法，PC 寄存器则保存指向当前执行字节码的指令地址；如果执行的是 Native 方法，则 PC 寄存器为空。   If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine&amp;rsquo;s pc register is undefined.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98/</guid>
      <description>凑零钱问题 #  1 题目 #  给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
示例 1：
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：
输入：coins = [2], amount = 3 输出：-1 示例 3：
输入：coins = [1], amount = 0 输出：0 示例 4：
输入：coins = [1], amount = 1 输出：1 示例 5：
输入：coins = [1], amount = 2 输出：2 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>二分查找 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/</guid>
      <description>锁 #  首先，对 MySQL 锁进行划分：
 按照锁的粒度划分：表锁（Table Level Lock）、行锁（Row Level Lock）。 按照锁的使用方式划分：共享锁（Share Lock）、排他锁（悲观锁的一种实现）（eXclusive Lock）。 按照锁的思想划分：悲观锁（Pessimistic Concurrency Control, PCC）、乐观锁（Optimistic Concurrency Control, PCC）。 InnoDB的几种意向锁：意向共享锁（Intensive Shared Lock, IS）、意向排他锁（Intensive Exclusive Lock）。 InnoDB的几种行级锁：记录锁（Recoord Lock）、间隙锁（Gap Lock）、临键锁（Next-key Lock）。  1 表锁和行锁 #  1.1 表锁 #  1.1.1 含义 #   表级锁是 MySQL 中粒度最大的一种锁，表示当前的操作对整张表加锁。 表锁响应的是非索引字段，即全表扫描，全表扫描时锁定整张表。 表级锁有两种模式：表共享锁（Table Read Lock）、表独占写锁（Table Write Lock）：  表共享锁： 不会阻塞其他用户对同一张表的读请求，但会阻塞对同一张表的写请求。 表独占写锁：会阻塞其他用户对同一张表的读写请求，当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放为止。    1.1.2 如何加表锁 #    给表显示加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。
  例如，有一个订单表 orders，其中记录有订单的总金额 total，同时还有一个订单明细表 order_detail，其中记录有订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条 SQL：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Redis数据类型 #   如无特殊说明，本文内容针对的 Redis 版本为 3.0.0，源码下载地址为 redis-3.0.0。
 1 前言 #    Redis 的 key 是顶层模型，他的 value 是扁平化的，所有的 value 都是一个 object，它的结构如下：
typedef struct redisObject { unsigned [type] 4; unsigned [encoding] 4; unsigned [lru] REDIS_LRU_BITS; int refcount; void *ptr; } robj;   上面的几个字段的意义如下：
 type：数据类型，就是我们熟悉的string、hash、list 等。 encoding：内部编码，其实就是数据结构，指的是当前这个 value 底层是用的什么数据结构，因为同一个数据类型底层也有多种数据结构的实现，所以这里需要指定数据结构。 REDIS_LRU_BITS：当前对象可以保留的时长。 refcount：对象引用计数，用于 GC。 ptr：指针，指向以 encoding 的方式实现这个对象的实际地址。    整个 Redis 的数据结构组织如下图所示：
   2 数据类型 #  Redis 中主要有 5 种数据类型，分别是字符串（String）、列表（List）、集合（Set）、有序集合（ZSet）、哈希（Hash）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84start%E5%92%8Crun%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84start%E5%92%8Crun%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>Thread类中的start()和run()方法有什么区别 #    通过 start()方法来启动一个线程，此时线程处于就绪状态，可以被 JVM 来调度执行，在调度过程中，JVM 通过调用线程类的 run()方法来完成实际的业务逻辑，当 run()方法结束后，此线程就会终止，所以通过 start()方法可以达到多线程的目的。
  如果直接调用线程类的 run()方法，会被当做一个普通的函数调用，程序中仍然只有主线程这一个线程，即 start()方法呢能够异步的调用 run()方法，但是直接调用 run()方法确实同步的，无法达到多线程的目的。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>判断对象是否存活的方法 #  判断对象是否存活的方法有两种，分别是 引用计数法、可达性分析算法。
 注：如无特殊说明，本文所有图的来源为《深入理解 Java 虚拟机 JVM 高级特性与最佳实践》
   引用计数法
 引用计数法是指给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减 1，任何时刻计数器为 0 的对象就是不可能再被使用的。 缺点是它很难解决对象之间相互循环引用的问题。举个简单的例子，对象 objA 和 obB 都有字段 Instance,赋值令 obja instance=objB 及 obiB. Instance=ojA，除此之外，这两个对象再无任何引用,实际上这两个对象已经不可能再被访问,但是它们因为互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。    可达性分析算法
 主要通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连（即从 GC Roots 到这个对象不可达）时，则证明对象是不可用的。    ![]../../media/202105//1621914618.1032557.png)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>贪心算法 #  1 定义 #  贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。
贪心选择性质： 简单地说就是每一步做出一个局部最优的选择，最终的结果就是全局最优。需要注意的是，这是一种特殊性质，只有一部分问题拥有这个性质。
 比如面前放着 100 张人民币，我们只能拿 10 张，怎么才能拿到最多的面额？显然每次选择剩下钞票中面值最大的一张，最后我们的选择一定是最优的。 但是大部分问题明显不具有贪心选择性质，比如斗地主，对手出对儿三，按照贪心策略，我们应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决。  2 示例 #  2.1 区间调度问题 #  2.1.1 无重叠区间 #  2.1.1.1 题目 #  给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
1. 可以认为区间的终点总是大于它的起点。 2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1:
输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2:
输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/</guid>
      <description>锁协议 #  1 三级封锁协议 #   三级封锁协议就是三个不同级别的封锁协议，他们是以何时加锁，何时解锁来区分的。
 1.1 一级封锁协议 #  1.1.1 含义 #   事务 $T$ 在修改数据 $R$ 之前必须先对其加 $X$ 锁，直到事务结束才释放，事务结束包括正常结束（Commit）和非正常结束（Rollback）。 在一级封锁协议中，如果仅仅是读数据而不对其进行修改，是不需要加锁的。 一级封锁协议可以解决更新丢失问题，但是他不能保证可重复读和不读脏数据。  1.1.2 示例 #  1.1.2.1 不使用锁导致的更新丢失问题 #   1.1.2.2 使用一级锁解决更新丢失问题 #    1.1.2.3 为什么一级锁不能解决脏读问题 #  脏读例子：
 用一级锁的情况：
 1.2 二级封锁协议 #  1.2.1 含义 #   在一级封锁协议之上，事务 $T$ 在读取数据 $R$ 之前必须先对其加 $S$ 锁，读完后方可释放 $S$ 锁。 二级封锁协议除了可以解决丢失更新问题，还可以进一步解决脏读问题。 但在二级封锁协议中，由于读完数据后即可释放 $S$ 锁，所以他不能保证可重复读。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</guid>
      <description>持久化机制 #  1 什么是持久化 #   持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。  2 Redis 中持久化机制有哪些 #  Redis 中持久化机制主要有两种，分别是RDB（默认）和AOF。
2.1 RDB #  2.1.1 含义 #   RDB 文件主要用于保存和还原 Redis 服务器所有数据库中的所有键值对数据。 创建方式主要有两种，分别是 SAVE 和 BGSAVE：  SAVE 命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。 BGSAVE 命令由子进程执行保存操作，所以该命令不会阻塞服务器。   因为 BGSAVE 命令可以在不阻塞服务器进程的情况下执行，所以可以通过设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令，用户可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令。  2.1.2 优缺点 #  2.1.2.1 优点 #   整个 Redis 数据库只包含一个文件，这对于文件备份来说非常方便，比如，我们可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据，通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。 对于灾难性恢复而言，RDB 也是一个不错的选择，因为我们可以非常轻松的将一个单独的文件压缩后再转移到其他存储介质上。 性能最大化，对于 Redis 的服务进程而言，在开始持久化时，他唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样可以极大地避免服务进程执行 IO 操作。 相比于 AOF 机制，如果数据集很大，RDB 的启动效率会更高。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</guid>
      <description>Java多线程中调用wait()和sleep()方法有什么不同 #  相同点：
 他们都是在多线程的环境下，都可以在程序的调用出阻塞指定的毫秒数，并返回。 二者都可以通过 interrupt()方法打断现成的暂停状态，从而使线程立刻抛出 InterruptedException。 不同点： wait()属于 Object 类的方法，sleep()属于 Thread 类的方法。 每个对象都有一个锁来控制同步访问，Synchronized 关键字可以和对象的锁交互，来实现现成的同步。sleep()方法没有释放锁，而 wait()方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait()方法只能在同步控制方法或者同步控制块里面使用，而 sleep()可以在任何地方使用。 sleep()方法必须捕获异常，而 wait()方法不需要捕获异常。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</guid>
      <description>垃圾收集算法 #  3.3.1 标记-清除算法 #  最基础的收集算法是“标记-清除”算法，算法分为“标记”和“清除”两个阶段：首先需要标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
3.3.2 复制算法 #  为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价是将内存缩小为了原来的一半。
复制算法一般用来回收新生代，由于新生代中的对象是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当Survivor空间不够用时，需要依赖其他内存进行分配担保。
3.3.3 标记-整理算法 #  复制收集算法在对象存活率较高时就要进行较多的赋值操作，效率就会变低，更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。
根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
3.3.4 分代收集算法 #  当代商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分为新生代和老年代，这样就可以根据各个年代的特点选用最适当的收集算法：
 在新生代中，每次垃圾回收都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 在老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>最长递增子序列 #  1 题目 #  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：
输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：
输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：
 1 &amp;lt;= nums.length &amp;lt;= 2500 -104 &amp;lt;= nums[i] &amp;lt;= 104  进阶：
 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗?  2 解题思路 #  2.1 动态规划法 #  2.1.1 问题分析 #  动态规划的核心设计思想是数学归纳法。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>排序算法 #  1 简单选择排序 #  1.1 算法原理 #   简单排序算法的基本思想为每一趟从待排序的数据元素中选择最小（最大）的一个元素作为首元素，直到所有元素排完为止。  1.2 参考代码 #   在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小。 交换是个比较耗时的操作，其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。 我们可以通过设置一个变量minInd，每一次比较仅存储较小元素的数组下标，当这一轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。  /** * @author peng.wei * @version 1.0 * @date 2021/5/3 20:52 * @Description 简单选择排序算法 */ public class SimpleSelectionSort { public static void sort(int[] arr) { int m = arr.length; for (int i = 0; i &amp;lt; m - 1; i++) { int minInd = i; for (int j = minInd + 1; j &amp;lt; m; j++) { // 只记录最小元素的位置，而不是每一次比较都交换，减少交换的次数  if (arr[minInd] &amp;gt; arr[j]) {minInd = j;} } if (minInd !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</guid>
      <description>事务日志 #  数据库的事务日志主要分三类，分别是Binlog、Redo Log、Undo Log。
1 Binlog #  1.1 含义 #   Binlog 记录了对 MySQL 数据库执行更改的所有操作，但是不包括 SELECT 和 SHOW 这类操作，但是若操作本身并没有导致数据库发生变化，那么该操作可能也会写入 Binlog，如update t set a = 1 where a = 2;，但是表t 中并不存在a = 2 的巨鹿，此时并不会对数据库进行更改，但是这个操作也会写入 Binlog。 Binlog 主要有以下几种作用：  恢复： 某些数据的恢复需要 Binlog，例如，在一个数据库全备文件恢复后，用户可以通过 Binlog 进行 point-in-time 的恢复（将数据恢复到一个给定的时间点，通常是在进行全量备份之后进行）。 复制： 其原理与恢复类似，通过复制和执行 Binlog 使一台远程的 MySQL 数据库（一般称为 slave 或 standby）与一台 MySQL 数据库（一般称为 master 或 primary）进行实时同步。 审计： 用户可以通过 Binlog 中的信息进行审计，判断是否有对数据库进行注入的攻击。    1.2 常用参数 #  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</guid>
      <description>过期机制和内存淘汰策略 #  1 过期机制 #  1.1 设置键的生存时间或过期时间 #  1.1.1 设置过期时间 #   Redis 中有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候被删除）：  EXPIRE &amp;lt;key&amp;gt; &amp;lt;ttl&amp;gt;：命令用于将键 key 的生存时间设置为 ttl 秒。 PEXPIRE &amp;lt;key&amp;gt; &amp;lt;ttl&amp;gt;：命令用于将 键 key 的生存时间设置为 ttl 毫秒。 EXPIREAT &amp;lt;key&amp;gt; &amp;lt;timestamp&amp;gt;：命令用于将键 key 的过期时间设置为 timestamp 所指定的秒数时间戳。 PEXPIREAT &amp;lt;key&amp;gt; &amp;lt;timestamp&amp;gt;：命令用于将键 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳。   虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用 PEXIREAT 命令来实现的，无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行 PEXPIREAT 命令一样：   首先，EXPIRE命令可以转换为 PEXPIRE：
def EXPIRE(key, ttl_in_sec): # 将 TTL 转换成毫秒 ttl_in_ms = sec_to_ms(ttl_in_sec) PEXPIRE(key, ttl_in_ms)   接着，PEXPIRE 命令又可以换成 PEXPIREAT 命令：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>ReentrantLock和Synchronized的区别 #  相同点：
两者都是可重入锁，他们的加锁方式都是同步，而且都是阻塞式的同步，也就是说当一个线程获得了对象锁，进入了同步块，其它访问概统不快的线程都必须阻塞在同步块外面等待。
不同点：
 原始构成：Synchronized是Java语言的关键字，是原生层面的互斥，需要jvm实现；而ReentrantLock是JDK1.5之后提供的API层面的互斥锁类。 实现：Synchronized是通过JVM来加锁和解锁；ReentrantLock是API层面的加锁和解锁。 代码编写：Synchronied不需要用户去手动释放锁，当Synchronied方法或者代码块执行完之后，系统会自动让线程释放对锁的占用，更安全；而ReentrantLock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致死锁现象。 等待可中断：Sychronied不可中断，直到代码执行完，才正常释放锁，除非抛出异常，由JVM退出等待；ReentrantLock在持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以通过tryLock来设置超时时间，时间过了之后就放弃等待，同时可以将lockInterruptibly()方代码块中，调用interrupt()方法来中断，但是Synchronied不行。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>类的生命周期和加载过程 #  ![6zd6i.png (787×430)]../../media/202105//1621914619.9545197.png)
一个类在 JVM 里的生命周期有 7 个阶段，分别是：
 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading）  其中前 5 个部分（加载、验证、准备、解析、初始化）统称为类加载，具体过程如下：
  加载： 这个阶段的主要操作是根据明确知道的 class 完全限定名，来获取二进制 classfile 格式的字节流，简单点说就是找到文件系统中 jar 包或存在于任何地方的&amp;quot;class 文件&amp;quot;。如果找不到，则会抛出 NoClassDefFound 错误。加载阶段并不会检查 classfile 的语法和格式，整个过程主要由 JVM 和 Java 的具体某一个 类加载器 协作完成。
  验证： 这个阶段主要是确保 class 文件里的字节流信息符合当前虚拟机的要求，不会危害虚拟机的安全。验证过程中会检查 classfile 的语义，判断常量池中的符号，并执行类型检查，主要目的是判断字节码的合法性。
  准备： 这个阶段会创建静态字段，并将其初始化为标准默认值（比如 null 或者 0 值），并分配方发表，即在方法区中分配这些变量所使用的的内存空间，需要注意的是，准备阶段并未执行任何 Java 代码。 例如：对于 public static int i = 1;，后面在类初始化阶段才会执行赋值为 1，但是如果使用 final 作为静态常量，则会在准备阶段就会被赋值为 1。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</guid>
      <description>编辑距离 #  1 题目 #  给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
 插入一个字符 删除一个字符 替换一个字符  示例 1：
输入：word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot; 输出：3 解释： horse -&amp;gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;) rorse -&amp;gt; rose (删除 &#39;r&#39;) rose -&amp;gt; ros (删除 &#39;e&#39;) 示例 2：
输入：word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot; 输出：5 解释： intention -&amp;gt; inention (删除 &#39;t&#39;) inention -&amp;gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;) enention -&amp;gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;) exention -&amp;gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;) exection -&amp;gt; execution (插入 &#39;u&#39;) 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>MVCC实现原理 #  1 含义 #   MVCC 是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成数据的并发阻塞问题。 通俗的讲就是 MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。  2 核心知识点 #  2.1 事务版本号 #   每次事务开启前都会从数据库获得一个自增长的事务 ID，可以从事务 ID判断事务执行的先后顺序。  2.2 隐藏列 #   DB_TRX_ID： 记录操作该数据事务的事务 ID。 DP_POLL_PTR： 指向上一个版本数据在 Undo Log 里的位置指针。 DB_ROW_ID：隐藏 ID，当建表没有合适的索引作为聚集索引时，会用该隐藏 ID 创建聚集索引。  2.3 Undo Log #  2.3.1 含义 #   Undo Log 主要用于记录数据被修改之前的日志，在表信息修改之前会先把数据拷贝到 Undo Log 里，在事务进行回滚时可以通过 Undo Log 里的日志进行数据还原，具体可参考 Undo Log。  2.3.2 用途 #   保证事务进行 ROLLBACK 时的原子性和一致性，当事务进行回滚的时候可以用 Undo Log 的数据进行恢复。 在MVCC 版本控制中，通过读取 Undo Log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-volatile%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-volatile%E9%80%82%E7%94%A8%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>volatile适用于高并发的什么场景 #  volidate最适合一个线程写，多个线程读的场景，如果有多个线程并发写操作，仍然需要使用锁或者线程安全的容器或者原子变量来替代。我们只能在有限的一些场景下使用volidate变量来替代锁，要使volidate变量提供理想的线程安全，必须同时满足下面两个条件：
 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/</guid>
      <description>类加载时机 #  1 类的初始化触发的情况 #   当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类。 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类，就是new一个类的时候要初始化。 当遇到调用静态方法的指令时，初始化该静态方法所在的类。 当遇到访问静态字段的指令时，初始化该静态字段所在的类。 子类的初始化会触发父类的初始化。 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化。 使用反射API对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化。 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。  2 不会指定类初始化的情况 #   通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上没有直接引用常量的类，不会触发定义常量所在的类。 通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始化。 通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不初始化）。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/</guid>
      <description>高楼扔鸡蛋 #  1 题目 #  给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
已知存在楼层 f ，满足 0 &amp;lt;= f &amp;lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &amp;lt;= x &amp;lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
示例 1：
输入：k = 1, n = 2 输出：2 解释： 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 如果它没碎，那么肯定能得出 f = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>多线程join方法用于什么场景 #  主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法。join方法的作用是等待线程对象被销毁。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/</guid>
      <description>类加载器的种类 #  类加载过程可以描述为“通过一个类的全限定名 a.b.c.XXClass来获取描述此类的 Class对象”，这个过程由类加载器（CLassLoader） 来完成。这样的好处在于，子类加载器可以复用父类加载器加载的类。 类加载器主要分为三种：
![csrk7.png (651×444)]../../media/202105//1621914620.392762.png)
  启动类加载器（BootstrapClassLoader）：
 他用来加载Java的核心类，是用C++代码来实现的，并不继承自java.lang.ClassLoader（负责加载JDK中jre/lib/tr.jar里所有的class）。 他可以看做是JVM自带的，我们在代码层面无法直接获取到启动类加载器的引用，所以不允许直接操作他，如果打印出来就是个null，但是后面可以通过命令行参数影响他加载什么。    扩展类加载器（ExtCLassLoader）：
 他负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。 代码里直接获取他的父类加载器为null，因为无法拿到启动类加载器。    应用类加载器（AppClassLoader）：
 他负责在JVM启动时加载来自Java命令的-classpath或者-cp选项、java.class.path系统属性指定的jar包和类路径。 在应用程序代码里可以通过ClassLoader的静态方法getSystemClassLoader()来获取应用类加载器。 如果没有特别指定，则在没有使用自定义类加载器情况下，用户自定义的类都由此类加载器加载。    自定义类加载器（CustomClassLoader）：
 除了前面三种系统自带的类加载器，用户还可以自己定义类加载器，如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>最长回文子序列 #  1 题目 #  给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1: 输入:
&amp;quot;bbbab&amp;quot; 输出:
4 一个可能的最长回文子序列为 &amp;ldquo;bbbb&amp;rdquo;。
示例 2: 输入:
&amp;quot;cbbd&amp;quot; 输出:
2 一个可能的最长回文子序列为 &amp;ldquo;bb&amp;rdquo;。
提示：
 1 &amp;lt;= s.length &amp;lt;= 1000 s 只包含小写英文字母  2 解题思路 #  2.1 子序列问题处理模板 #  对于这种子序列问题，我们一般需要使用动态规划的方法来解决：
 找状态关系（通过数学归纳获得）。 定义 dp 数组（根据状态转移方程获得）。  dp 数组的定义主要有两种方式，一种是定义一个一维数组，另一种是定义一个二维数组。
2.1.1 一维 dp 数组 #  例如，在 最长递增子序列中，我们就是定义了一个一维数组，其含义为：在子数组 $array[0..i]$ 中，我们要求的子序列（最长递增子序列）的长度是 $dp[i]$。
int n = array.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>多个线程间如何共享数据 #   如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据。2. 将共享数据封装成另一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上，这样容易实现针对数据进行各个操作的互斥和通信。 将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法页封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/</guid>
      <description>类加载机制的特点 #  类加载机制有三个特点，具体如下：
 双亲委托：  当一个自定义类加载器需要加载一个类，比如java.lang.String，他很懒，不会一上来就直接加载他，而是先委托自己的父类加载器去加载。父加载器如果发现自己还有父加载器，会一直往前找。 这样只要上级加载器比如启动类加载器，已经加载了某个类比如java.lang.String，所有的子类加载器都不需要自己加载了。 如果几个类加载器都没有加载到指定名称的类，那么会抛出ClassNotFoundException 异常。   负责依赖： 如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类或接口，也会去尝试加载这些依赖项。 缓存加载： 为了提升加载效率，消除重复加载，一旦某个类被一个类加载器加载，那么他会缓存这个加载结果，不会重复加载。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>最大子序和 #  1 题目 #  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 示例 4：
输入：nums = [-1] 输出：-1 示例 5：
输入：nums = [-100000] 输出：-100000 提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105  进阶： 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>线程的状态有哪些，各自的使用场景是什么 #   新状态：线程被创建出来，但是还没有调用start()方法。2. 可运行状态：线程有资格运行，但调度程序还没有把它选定为运行线程时所处的状态，此时正在等待操作系统分配资源、等待IO；连接，当satrt()方法调用时，线程首先进入可运行状态，在线程运行之后或者从阻塞、等待、睡眠状态回来后，也返回到可运行状态。 Running(运行状态)：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。 等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态，实际上这三个状态组合为一种，其共同点是线程仍旧是获得，但是当前没有条件运行，等待某件事件出现时，他可能返回到可运行状态。 死亡状态：线程的run()方法完成时所处的状态。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <description>JVM内存结构 #  1 概述 #  JVM 内部使用Java 内存模型，在逻辑上将内存划分为线程栈（Thread Stacks）和堆内存（Heap）两个部分，如下图所示：
![4pajs.jpg (1148×816)]../../media/202105//1621914622.9091363.png)
1.1 线程栈 #  JVM 中，每个正在运行的线程，都有自己的线程栈。
 线程栈包含了当前正在执行的方法链或调用链上的所有方法的状态信息， 所以线程栈又被称为方法栈或调用栈。 线程栈里面保存了调用链上正在执行的所有方法中的局部变量：  每个线程都只能访问自己的线程栈。 每个线程都不能访问其他线程的局部变量。   即使两个线程正在执行完全相同的代码，但每个线程都会在自己的线程栈内创建对应代码中声明的局部变量，所以每个线程都有一份自己的局部变量副本：  所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。 线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。    1.2 堆内存 #  堆内存又称为共享堆，堆中的所有对象，可以被所有线程访问，只要他们能拿到对象的引用地址：
 如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。 如果两个线程同时调用某个对象的同一个方法，则他们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。  虽然各个线程自己使用的局部变量都在自己的栈上，但是大家可以共享堆上的对象，各个不同线程访问同一个对象实例的基础类型的成员变量，会给每个线程一个变量的副本。
![6j9fe.jpg (1688×1078)]../../media/202105//1621914622.9118786.png)
1.3 总结 #   如果是原生数据类型的局部变量，那么他的内容就全部保留在线程栈中。 如果是对象引用，在对象的引用地址保存在栈中，而实际的对象内容保存在堆中。 对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数值，还是对象引用。 类的静态变量则和类定义一样都保存在堆中。  总结一下：
 原始数据类型的局部变量和对象引用地址在栈上。 对象、对象成员与类定义、静态变量在堆上。  ![ksq1n.jpg (1728×1098)]../../media/202105//1621914622.9144847.png)
2 线程栈 #  ![6yhj7.jpg (1450×986)]../../media/202105//1621914622.9165661.png)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</guid>
      <description>买卖股票 #  1 题目 #  给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
 1 &amp;lt;= prices.length &amp;lt;= 105 0 &amp;lt;= prices[i] &amp;lt;= 104  2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-Java%E8%87%AA%E5%B8%A6%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-Java%E8%87%AA%E5%B8%A6%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>Java自带哪几种线程池 #   newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。如果长时间没有往线程池中提交任务，则该工作线程将自动终止。终止后，如果又提交了新的任务，则线程池重新创建一个工作线程。因此，在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。 newFixedThreadPool(典型且优秀的线程池)：创建一个指定工作线程数量的线程池。每当提交一个任务时就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。它具有提高程序效率和节省创建线程时所耗开销的优点。但是，在线程池空闲时，他不会释放工作线程，还会占用一定的系统资源。 newSingleThreadExecutor：创建一个单线程化的 Executor，即只创建唯一的工作线程来执行任务，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。如果这个线程异常结束，会有另一个取代他，保证顺序执行，单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>常见的垃圾收集算法有哪些 #  1 引用计数法 #  2.1 原理 #   这种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了该对象，这个对象的计数器就加 1，取消对这个对象的引用时，这个对象的计数器就减 1。 任何一个时刻，如果该对象的计数器为 0，那么这个对象就是可以回收的。  2.2 缺点 #   如果出现了对象之间的相互引用，这样单纯的引用计数就会出现问题，导致循环引用的对象没办法回收，这时就会出现内存泄漏，该释放的没释放，该回收的没回收。 如果依赖关系复杂，计算机的内存资源很可能用满，或者说不够用，这样就可能会导致内存溢出。 由于以上原因，在JVM 中没有使用引用计数法。  2 JVM 常用 GC 算法 #  各种垃圾收集器的实现细节虽然不尽相同，但总体而言，垃圾收集器都专注于两件事情：
 查找所有存活对象。 抛弃其他部分，即死对象，不再使用的对象。  2.1 标记可达对象（Marking Reacable Objects） #  现代 JVM 中所有的 GC 算法，第一步都是找出所有存活的对象，如下图所示：
![e575a130-322d-11ea-9111-a36492d50563 (2054×1134)]../../media/202105//1621914623.3531394.png)
 首先，有一些特定的对象被指定为GC 根元素（Garbage Collection Roots），包括：  当前正在执行的方法里的局部变量和输入参数。 活动线程。 内存中所有类的静态字段。 JNI 引用。   其次，GC 遍历内存中整体的对象关系图，从 GC 根元素开始扫描，到直接引用，以及其他对象（通过对象的属性域），所有 GC 访问到的对象都被标记为存活对象。  存活对象在上图中用蓝色表示，标记阶段完成后，所有存活对象都被标记了。 而其他对象（上图中灰色部分）就是根元素不可达的，也就是程序不能再使用这些不可达的对象，这样的对象被认为是垃圾，GC 会在接下来的阶段清除他们。   在标记阶段有几个需要注意的地方：  标记阶段需要暂停所有的应用线程，以遍历所有对象的引用关系，因为不暂停就没法跟踪一直在变化的引用关系图，这种情景叫做全线停顿（Stop The World Pause），而可以安全暂停线程的点叫做安全点，然后，JVM 就可以专心执行清理工作了，安全点可能由多种因素触发，GC 是触发安全点最常见的原因。 暂停的时间与堆内存大小、对象的总数没有直接关系，而是由存活对象的数量来决定，所以增加堆内存的大小并不会直接影响标记阶段占用的时间。    2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>最长重复子数组 #  1 题目 #  给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
示例：
输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。 提示：
 1 &amp;lt;= len(A), len(B) &amp;lt;= 1000 0 &amp;lt;= A[i], B[i] &amp;lt; 100  2 解题思路 #  2.1 暴力解法 #  2.1.1 问题分析 #   首先将 $nums2$ 中的元素对应的下标保存在 $map$ 中，这样便于查找 $nums1$ 中的元素是否在 $nums2$ 中出现。 然后遍历 $nums1$，假设当前遍历的元素为 $item$：  如果 $item$ 没有在 $nums2$ 中出现，则直接返回。 如果 $item$ 在 $nums2$ 中出现，则以 $item$ 为起点，同步遍历 $nums1$ 和 $nums2$ 的后续元素，直到两个数组中对应元素不相等，或达到任意数组的边界，计算两个数组相应部分的的重复子数组的大小，并对最终的结果进行更新。   最后返回最终结果即可。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.10-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.10-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>Java内存模型 #   Java 内存模型（Java Memory Model, JMM）本身是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式。 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，用于存储线程私有的数据，而 Java 内存模型中规定都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行： 首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成后再将变量写回到主内存，不能直接操作主内存中的变量。 工作内存中存储着主内存中的变量副本拷贝，因为工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成。  ![]../../media/202105//1621914599.8081136.png)
参考文献 #    全面理解 Java 内存模型(JMM)及 volatile 关键字。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/</guid>
      <description>指针碰撞和空闲列表 #  1 原理分析 #  为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来：
 假设 Java 堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Pointer Bumping）。 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为空闲列表（Free List）。 选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。 因此：  在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法时指针碰撞。 在使用CMS这种基于标记-清除算法的收集器时，通常采用空闲列表。    指针碰撞：
![]../../media/202105//1621914623.735002.png)
空闲列表：
![]../../media/202105//1621914623.7397084.png)
2 参考文献 #    指针碰撞和空闲列表。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>最长有效括号 #  1 题目 #  给你一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
示例 1：
输入：s = &amp;#34;(()&amp;#34; 输出：2 解释：最长有效括号子串是 &amp;#34;()&amp;#34; 示例 2：
输入：s = &amp;#34;)()())&amp;#34; 输出：4 解释：最长有效括号子串是 &amp;#34;()()&amp;#34; 示例 3：
输入：s = &amp;#34;&amp;#34; 输出：0 提示：
 0 &amp;lt;= s.length &amp;lt;= 3 * 104 s[i] 为 &amp;lsquo;(&amp;rsquo; 或 &amp;lsquo;)&amp;rsquo;  2 解题思路 #  2.1 动态规划 #  2.1.1 问题解析 #   对于这种最值型题目一般采用动态规划的方法来求解。 动态规划题目的分析分为以下 4 个步骤：  确定状态：  研究最优策略的最后一步。 化为子问题。   转移方程：  根据子问题定义得到。   初始条件和边界情况。 计算顺序。   首先，我们定义一个 $dp$ 数组，其中 $dp[i]$表示以下标为 $i$ 的字符结尾的最长有效子字符串的长度。 然后进行动态规划的求解：  确定状态：  对于最优的策略，一定有最后一个元素 $s[i]$，所以，我们先看第 $i$ 个位置，这个位置的元素 $s[i]$ 有两种情况：  $s[i] = &amp;lsquo;(&#39;$：这时 $s[i]$无法和其之前的元素组成有效的括号对，所以 $dp[i] = 0$。 $s[i] = &amp;lsquo;)&#39;$：这时，需要看其前面一个元素来判断是否为有效括号对：   $s[i - 1] = &amp;lsquo;(&#39;$：即 $s[i]$和 $s[i - 1]$ 组成一对有效括号，有效括号长度新增 2，此时以 $i$位置的字符结尾的最长有效括号长度为以 $(i - 2)$ 位置的字符结尾的最长有效括号长度加 2，我们无需知道 $(i - 2)$ 位置的字符是否可以组成有序括号对，此时有：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</guid>
      <description>并发编程的三大特性 #  并发编程主要包含三大特性，分别是 原子性、可见性 和 有序性。
1 原子性 #  1.1 概念 #  原子性是指在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。
1.2 示例 #  i = 0; //1 j = i ; //2 i++; //3 i = j + 1; //4 上面的四个操作中，只有 1 是原子操作，其余绝不是：
 1 在 Java 中，对基本数据类型的变量的赋值操作都是原子性。 2 中包含了两个操作：  读取 i。 将 i 结果赋值给 j。   3 中包含了三个操作：  读取 i。 i+1。 将加 1 结果赋值给 i。   4 中同 3 一样。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>常见的垃圾收集器有哪些 #  JVM 中常见的垃圾收集器主要包括串行 GC 收集器（Serial GC）、ParNew 收集器、并行 GC 收集器（Parallel GC）、CMS 收集器（Most Concurrent Mark and Sweep Garbage Collector）、G1 收集器（Garbage First）五种。
1 串行 GC 收集器（Serial GC） #  Serial 收集器主要包括Serial 收集器（用于年轻代）、Serial Old 收集器（用于老年代）两种。
2.1 特点 #   串行 GC在年轻代使用标记-复制算法，在老年代使用标记-清除-整理算法。 两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。  2.2 缺点 #   不能充分利用多核 CPU，因为不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。  2.3 启用方法 #  -XX:+UseSerialGC 2 ParNew 收集器 #  ParNew 收集器是Serial 收集器的多线程版本，它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，因为除了 Serial 收集器外，目前只有他能与CMS 收集器配合工作。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.12-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.12-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</guid>
      <description>指令重排 #  在 Java 中看似顺序的代码在 JVM 中，可能会出现编译器或者 CPU 对这些操作指令进行了重新排序，在特定情况下，指令重排会给我们的程序带来不确定的结果。
1 概念 #  在虚拟机层面，为了尽可能减少内存操作速度远慢于CPU运行速度所带来的的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱，即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码可能会后执行，以尽可能充分的利用CPU，从 Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
 编译器优化重排序： 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行重排序： 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统重排序： 处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。   2 数据依赖性 #   如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。     名称 代码示例 说明     写后读 a = 1;b = 1 写一个变量之后，再读这个变量   写后写 a = 1;a = 2; 写一个变量之后，再写这个变量   读后写 a = b;b = 1; 读一个变量之后，再写这个变量    上面 3 中情况中，只要将两个操作的顺序进行重排序，程序的执行结果就会被改变。 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。不过这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  3 as-if-serial 语义 #  3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>内存溢出与内存泄漏的区别 #  1 基本概念 #  1.1 内存溢出 #  内存溢出（Out Of Memory）是指程序在申请内存时，没有足够的内存空间供其使用。
1.2 内存泄漏 #  内存泄漏（Memory Leak）是指不再使用的对象持续占有内存，使得这部分内存得不到及时释放，从而造成内存空间浪费。
2 二者关系 #   如果存在严重的内存泄漏问题，随着时间的推移，则必然会引起内存溢出。 内存泄漏一般是资源管理问题或程序 Bug，内存溢出则是内存空间不足和内存泄漏的最终结果。  3 内存溢出的常见情况 #  3.1 持久代溢出 #   因为运行常量池在方法区，而方法区在持久代中，因此出现持久代溢出的原因可能是运行时常量池溢出。 也可能是程序中使用了大量的 jar 或 class，使得方法区中保存的 class 对象没有被及时回收或class 信息使用的内存超过了配置的大小。  3.2 堆溢出 #   发生这种溢出的原因一般是创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制。 解决这个区域异常的方法是通过内存映像分析工具对 Dump 出来的转储快照进行分析，看到底是内存溢出还是内存泄漏：  如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的应用链，定位泄漏代码的位置，修改程序或算法。 如果不是内存泄漏，说明内存中的对象确实都还必须存活，那就应该检查虚拟机的堆参数 -Xmx（最大堆大小）和 -Xms（初始堆大小），与机器物理内存对比看是否可以调大。    3.3 虚拟机栈和本地方法栈溢出 #    如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverFlowError。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError。  4 内存泄漏 #  4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.13-Volatile%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.13-Volatile%E5%8E%9F%E7%90%86/</guid>
      <description>Volatile原理 #  1 定义 #   Volatile 可以保证线程的可见性、有序性，但是无法保证线程的原子性。 加入Volatile 关键字时，会多出一个 lock 前缀指令，该指令实际相当于一个内存屏障，他会提供 3 个功能：  确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在他前面的操作已经全部完成。 他会强制将缓存的修改操作立即写入主内存。 如果是写操作，他会导致其他 CPU 中对应的缓存行无效。    2 实现原理 #  2.1 可见性 #   如果对声明了 Volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀指令，将这个变量所在的缓存行的数据写回到系统内存，这一步确保了如果有其他线程对声明了 Volatile 变量进行修改时，则立即更新主内存中的数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理器会通过嗅探在总线上的传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里，这一步确保了其他线程获得的声明了 Volatile 变量都是从主内存中获取最新的。  2.2 有序性 #   Lock 前缀指令实际上相当于一个内存屏障，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在他前面的操作已经全部完成。  3 示例 #  3.1 保证可见性 #  先看一段代码，假如线程 1 先执行，线程 2 后执行：
//线程 1 boolean stop = false; while(!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>常用的JVM启动参数有哪些 #  # JVM 启动参数不换行 # 设置堆内存 -Xmx4g -Xms4g # 指定 GC 算法 -XX:+UseG1GC -XX:MaxGCPauseMillis=50 # 指定 GC 并行线程数 -XX:ParallelGCThreads=4 # 打印 GC 日志 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 指定 GC 日志文件 -Xloggc:gc.log # 指定 Meta 区的最大值 -XX:MaxMetaspaceSize=2g # 设置单个线程栈的大小 -Xss1m # 指定堆内存溢出时自动进行 Dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ # 指定默认的连接超时时间 -Dsun.net.client.defaultConnectTimeout=2000 -Dsun.net.client.defaultReadTimeout=2000 # 指定时区 -Duser.timezone=GMT+08 # 设置默认的文件编码为 UTF-8 -Dfile.encoding=UTF-8 # 指定随机数熵源(Entropy Source) -Djava.security.egd=file:/dev/./urandom </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.14-CAS%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.14-CAS%E5%8E%9F%E7%90%86/</guid>
      <description>CAS原理 #  1 CAS 含义 #    CAS 全称是 Compare and Swap，即比较并交换。
  它是一种无锁原子算法，同时也是一种乐观机制。
  CAS 映射到操作系统就是一条 CPU 原子指令，实现方式是基于硬件平台的汇编指令，在 Intel 的 CPU 中，使用的是 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。
  CAS 包含 3 个参数 V、E、N：
 V： Value，即要更新的值。 E： Expect，即预期值。 N：New，即新值。  只有当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程完成更新，则当前线程什么都不做，最后 CAS 返回当前 V 的真实值。
  当多个线程同时使用 CAS 操作一个变量时，最多只会有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试（自旋），当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以避免其他线程对当前线程的干扰。
  与锁相比，使用 CAS 会使程序看起来更加复杂一些，但是使用无锁的方式完全没有锁竞争带来的线程间频繁调度的开销和阻塞，他对死锁问题天生免疫，因此他要比基于锁的方式拥有更好的性能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</guid>
      <description>反射机制 #  1 含义 #    一般情况下，我们使用某个类时必定知道他是什么类，是用来做什么的，于是我们直接对这个类进行实例化，之后使用这个类对象进行操作，这种进行类对象的初始化的方法，我们可以理解为正射，例如：
Apple apple = new Apple(); apple.setPrice(4.0);   而反射只有在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法，例如：
Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;#34;top.grayson.jvm.reflect.Apple&amp;#34;); Method setPriceMethod = cls.getMethod(&amp;#34;setPrice&amp;#34;, double.class); Constructor&amp;lt;?&amp;gt; constructor = cls.getConstructor(); Object instance = constructor.newInstance(); setPriceMethod.invoke(instance, 5.0);   上面两段代码的执行结果是完全一样的，但是其思路完全不一样：
 第一段代码在未运行时就已经确定了要运行的类（Apple）。 第二段代码在运行时通过字符串值才得知要运行的类（top.grayson.jvm.reflect.Apple）。    完整的代码及运行结果如下：
public class ReflectTest1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { // 直接初始化，正射  Apple apple = new Apple(); apple.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.15-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.15-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/</guid>
      <description>Java的4种引用级别 #  1 介绍 #  从 JDK 1.2 版本开始，对象的引用被划分为 4 中级别，从而使程序能更加灵活地控制对象的生命周期，这 4 中级别从高到低依次为强引用（FinalReference）、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。
![]../../media/202105//1621914616.5661292.png)
2 具体划分 #  2.1 强引用（FinalReference） #    强引用是使用最普遍的引用，如果一个对象具有强引用，那么垃圾回收器绝对不会回收他，如下：
Object finalReference = new Object();   当空间不足时，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
  如果强引用对象不使用时，需要弱化从而使 GC 能够回收，显示地设置 finalReference 为 null，或让其超出对象的生命周期范围，则 GC 认为该对象不存在引用，这时就可以回收这个对象，具体什么时候回收取决于 GC 算法。
finalReference = null;   如果一个方法内部有一个强引用（局部变量），这个引用保存在 Java 栈中，真正的引用内容（Object）保存在 Java 堆中，当这个方法运行完成后，就会退出方法栈，则引用对象的引用数就会变为 0，这个对象就会被回收。
public void test() { Object finalReference = new Object(); // 省略其他操作 }   如果这个变量为全局变量时，就需要在不用这个对象时赋值为 null，因为强引用不会被垃圾回收。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.16-Java%E4%B8%AD%E7%9A%84%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.16-Java%E4%B8%AD%E7%9A%84%E9%94%81/</guid>
      <description>Java中的锁 #  1 公平锁和非公平锁 #  1.1 基本概念 #  1.1.1 公平锁 #  1.1.1.1 含义 #  公平锁是指多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列里面的第一位才能得到锁。
1.1.1.2 优缺点 #  1.1.1.2.1 优点 #   所有的线程都能得到资源，不会饿死在队列中。  1.1.1.2.2 缺点 #   吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，CPU唤醒阻塞线程的开销会很大。  1.1.2 非公平锁 #  1.1.2.1 含义 #   非公平锁是指多个线程区获取锁的时候，会直接去尝试，获取不到，再去进入等待队列，如果能获取到，则直接获取锁。 ReentrantLock默认是非公平锁， 如果要使用公平锁，可以使用ReentrantLock lock = new ReentrantLock(true);  ![]../../media/202105//1621914616.920087.png)
1.1.2.2 优缺点 #  1.1.2.2.1 优点 #   可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点，CPU 也不必去唤醒所有线程，会减少唤醒线程的数量。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.17-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.17-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>Synchronized实现原理 #  1 特性 #  Synchronized 具有 原子性、 可见性、 有序性、 可重入性。
2 用法 #  Synchronized 可以修饰静态方法、成员函数，同时还可以直接定义代码块，但是归根结底他上锁的资源只有两类，一个是对象，一个是类。
 关于 static 需要注意以下地方：
 static修饰的静态方法、静态属性都是归类所有，同时该类的所有实例对象都可以访问。 普通成员属性、成员方法是归实例化的对象所有，必须实例化之后才能访问，这也是为什么静态方法不能访问非静态属性的原因。   2.1 修饰成员函数 #   下面的代码均定义在 SynchronizedTest 类中，且该类中的变量定义如下：
private int i = 0; private static int j = 0; private final SynchronizedTest instance = new SynchronizedTest();    具体的代码如下：
// 对成员函数加锁，必须获得该类的实例对象的锁才能进入同步块 public synchronized void add1() { i++; }   该方法没有被 static 修饰，也就是说该方法是归实例化的对象所有，那么这个锁就是加给 SynchronizedTest 类所实例化的对象。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>线程池实现原理 #  1 前言 #  1.1 什么是线程池 #   线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如 MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。 线程池维护多个线程，等待监督管理者分配可并发执行的任务，这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。  1.2 线程池有哪些优点 #   降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能，比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。  1.3 线程池解决的问题是什么 #   线程池解决的核心问题就是资源管理问题，在并发环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入，这种不确定性将带来以下若干问题：  频繁申请、销毁资源和调度资源，将带来额外的损耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。   为解决资源分配这个问题，线程池采用了池化（Pooling）思想，即为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 除了线程池以外，池化思想在计算机领域的其他比较典型的几种使用策略包括：  内存池（Memory Pooling）：预先申请内存，提升内存申请速度，减少内存碎片。 连接池（Connection Pooling）：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池（Object Pooling）：循环使用对象，减少资源在初始化和释放时的昂贵损耗。    2 核心设计与实现 #  在前文中，我们了解到线程池是一种通过池化思想，帮助我们管理线程而获取并发性的工具，在 Java 中的体现是 ThreadPoolExecutor，下面我们将详细介绍该类的设计与实现。
 如无特殊说明，下面内容的叙述基于的 JDK 版本为 JDK 1.8.0_181。
 2.1 总体设计 #  ThreadPoolExecutor 的继承关系如下图所示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>删除有序数组中的重复项 #  2.4.1 题目 #  给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/</guid>
      <description>找出数组游戏的赢家 #  1 题目 #  给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
返回赢得比赛的整数。
题目数据 保证 游戏存在赢家。
示例 1：
输入：arr = [2,1,3,5,4,6,7], k = 2 输出：5 解释：一起看一下本场游戏每回合的情况：因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。 示例 2：
输入：arr = [3,2,1], k = 10 输出：3 解释：3 将会在前 10 个回合中连续获胜。 示例 3：
输入：arr = [1,9,8,2,3,7,6,4,5], k = 7 输出：9 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>如何寻找消失的元素 #  1 题目 #  数组 nums 包含从 0 到 n 的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在 O(n)时间内完成吗？
注意： 本题相对书上原题稍作改动
示例 1：
输入：[3,0,1] 输出：2 示例 2：
输入：[9,6,4,2,3,5,7,0,1] 输出：8 2 不同解法 #  2.1 方法一：位运算 #  对于异或运算（^），我们知道他有一个特殊的性质：一个数和他本身做异或运算结果为 0，一个数和 0 做异或运算还是他本身。
而且异或运算满足交换律和结合律，也就是说：
2^3^2 = 3^(2^2) = 3^0 = 3 而这道题就可以通过这些性质巧妙算出缺失的那个元素。比如说 nums = [0, 3, 1, 4]：
 为了容易理解，我们假设先把索引补一位，让后让每个元素和自己相等的索引相对应：
 这样做了之后，就可以发现除了缺失元素之外，所有的索引和元素都组成一对儿了，现在如果把这个落单的索引 2 找出来，也就找到了缺失的那个元素。
如何找这个落单的数字呢，只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下，这也就达到了我们的目的。
/** * 面试题 17.04. 消失的数字（版本 2：位运算） * @param nums 数字集合 * @return */ public int missingNumberV2(int[] nums) { int res = 0; int n = nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>如何寻找缺失和重复的元素 #  1 题目 #  集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
给定一个数组 nums 代表了集合 S 发生错误后的结果。
请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
示例 1：
输入：nums = [1,2,2,4] 输出：[2,3] 示例 2：
输入：nums = [1,1] 输出：[1,2] 2 问题解析 #  这个问题的特点是，每个元素和数组索引有一定的对应关系，。
我们可以暂且将 nums 中的元素变为 [0..N-1]，这样每个元素就和一个数组索引完全对应了，这样方便理解一些。
现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去。
所以我们如果可以通过某种方法，找到那个重复元素对应的索引，也就相当于找到了那个重复元素，找到那个没有元素对应的索引，也就找到了那个缺失的元素。
我们可以通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了。 如果出现重复元素 4，直观结果就是，索引 4 所对应的元素已经是负数了。
 对于缺失元素 3，直观结果就是，索引 3 所对应的元素是正数。
 对于这种数组问题，关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射。
3 参考代码 #  package com.grayson.top; import org.apache.commons.lang3.time.StopWatch; import java.util.Arrays; import java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E6%9C%80%E5%A4%A7%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E6%9C%80%E5%A4%A7%E6%95%B0/</guid>
      <description>最大数 #  1 题目 #  给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。
注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
示例 1：
输入：nums = [10,2] 输出：&amp;quot;210&amp;quot; 示例 2：
输入：nums = [3,30,34,5,9] 输出：&amp;quot;9534330&amp;quot; 示例 3：
输入：nums = [1] 输出：&amp;quot;1&amp;quot; 示例 4：
输入：nums = [10] 输出：&amp;quot;10&amp;quot; 提示：
 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 109  2 解题思路 #  2.1 互换位置 #  2.1.1 问题分析 #   可以先遍历整个数组，然后比较两个数字组成字符串对应的数字的大小，然后将二者互换位置，将较大的数字放在数组前面。 在对数字组成字符串对应的数字进行比较时，可以通过将两个数字互换位置，然后比较组成的两个数字字符串的大小即可，在对两个数字字符串进行比较时需要注意，如果直接将其转换位数字来比较的话可能会越界，所以需要按照字符串的格式从高位到低位逐位比较，直到可以区分两个字符串的大小即可。 当所有数字比较完成后，需要判断一下是否所有数字全部为 0，因为如果都为 0 的话，按照正常的逻辑，后面生成的字符串为 &amp;quot;000...&amp;quot; 的格式，这样是不正确的，所以需要判断一下是否所有数字都为 0，如果都为 0 的话，直接返回 &amp;quot;0&amp;quot; 即可。  判断时只需要判断比较完的数组的第一个元素是否为 0 即可，因为如果第一个元素为 0 的话，后面的元素一定全部为 0。    2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>二维数组中的查找 #  1 题目 #  在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
 0 &amp;lt;= n &amp;lt;= 1000 0 &amp;lt;= m &amp;lt;= 1000  2 解题思路 #  如下图所示，我们将矩阵逆时针旋转 45 度，并将其转化为图形式，发现其类似于二叉搜索树，即对于每个元素，其左分支元素更小，右分支元素更大。因此，通过从“根节点”开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>两数之和 #  1 题目 #  给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
 2 &amp;lt;= nums.length &amp;lt;= 103 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案  2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>三数之和 #  1 题目 #  给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意： 答案中不可以包含重复的三元组。
示例 1：
输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2：
输入：nums = [] 输出：[] 示例 3：
输入：nums = [0] 输出：[] 提示：
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  2 解题思路 #  2.1 双指针法 #  2.1.1 问题解析 #   先对原来的数组进行排序。 假设数组 $nums$ 的长度为 $len$。 首先固定一个点 $nums[i]$，进行第一次去重，如果 $nums[i]==nums[i+1]$，则进行下一个循环。 然后分别定义左、右指针：  $$ left = i + 1 $$</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>合并两个有序数组 #  1 题目 #  给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示：
 nums1.length == m + n nums2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/</guid>
      <description>二分查找框架 #  package com.grayson.top; import java.util.List; /** * @author peng.wei * @version 1.0 * @date 2021/3/21 14:25 * @Description 二分查找算法框架 */ public class BinarySearch { /** * 二分查找算法 * @param nums 原始数组 * @param target 目标值 * @return 目标值在原始数组中的位置 */ public static int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left &amp;lt;= right) { // 为了防止 (left + right) 太大导致溢出  int mid = left + (right - left) / 2; if (nums[mid] &amp;lt; target) {left = mid + 1;} else if (nums[mid] &amp;gt; target) {right = mid - 1;} // 直接返回  else if (nums[mid] == target) {return mid;} } // 直接返回  return -1; } /** * 寻找左侧边界的二分查找算法 * @param nums 原始数组 * @param target 目标值 * @return 目标值在原始数组中的位置 */ public static Integer leftBond(int[] nums, int target) { int left = 0, right = nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>搜索旋转排序数组 #  1 题目 #  整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>如何运用二分查找算法 #  1 二分查找适用场景 #  在有序数组中搜索给定的目标值的索引，如果目标值重复，可以返回目标值的左侧边界索引或者右侧边界索引。
2 场景示例 #  2.1 Koko 吃⾹蕉 #  2.1.1 题目 #  珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。
示例 1：
输入: piles = [3,6,7,11], H = 8 输出: 4 示例 2：
输入: piles = [30,11,23,4,20], H = 5 输出: 30 示例 3：
输入: piles = [30,11,23,4,20], H = 6 输出: 23 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 #  1 反转整个链表 #  1.1 题目 #  反转一个单链表。
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
1.2 问题解析 #  对于递归算法，最重要的就是明确递归函数的定义。 具体来说，我们的函数定义是这样的：
 输入一个节点 head，将以 head 为起点的链表反转，并返回反转之后的头结点。  示例代码如下：
/** * 206.反转链表（版本 2-递归） * 反转一个单链表。 * @param head 单链表的头指针 * @return 反转后的单链表 */ public ListNode reverse(ListNode head) { // 如果输入的 head 为 null，则返回 null  if (head == null) {return null;} if (head.next == null) {return head;} ListNode last = reverse(head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>数组中的第k个最大元素 #  1 题目 #  在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
2 解题思路 #  下面代码中用到的 CommonUtils 工具类代码如下：
/** * @author peng.wei * @version 1.0 * @date 2021/5/3 20:53 * @Description 通用工具类 */ public class CommonUtils { /** * 交换数组中两个指定位置的元素 * @param arr 数组 * @param i 下标 1 * @param j 下标 2 */ public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>二叉树的最近公共祖先 #  1 题目 #  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
示例 1：
 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2：
 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3：
输入：root = [1,2], p = 1, q = 2 输出：1 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树遍历 #  1 算法模板 #  二叉树遍历算法分为两种，一种是深度优先遍历算法，例如前序遍历、中序遍历、后序遍历，另一种是广度优先遍历算法，例如层次遍历。
1.1 深度优先遍历算法 #  1.1.1 递归解法 #  1.1.1.1 前序遍历 #  /** * 前序遍历（递归解法） * * @param head 头结点 */ public void preOrderRecur(TreeNode head) { // base case  if (head == null) { return; } // 访问根节点  System.out.println(head.val); // 遍历左节点  preOrderRecur(head.left); // 遍历右节点  preOrderRecur(head.right); } 1.1.1.2 中序遍历 #  /** * 中序遍历（递归解法） * * @param head 头结点 */ public void inOrderRecur(TreeNode head) { // base case  if (head == null) { return; } // 遍历左节点  preOrderRecur(head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</guid>
      <description>岛屿问题 #  1 前言 #   我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的，而我们今天要讨论的 DFS 问题，是在一种【网格】结构中进行的，岛屿问题是这类网格 DFS 问题的典型代表。 网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。 本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。  2 网格问题的基本概念 #   我们首先要明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。 网格问题是由 $m \times n$ 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。 岛屿问题是一类典型的网格问题，每个格子中的数字可能是 0 或者 1，我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。   在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等，不过这些问题，基本都可以用 DFS 遍历来解决。  3 网格 DFS 的基本结构 #  3.1 基本结构 #    网格结构要比二叉树结构稍微复杂一些，他其实是一种简化版的图结构，要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历，我们写的 二叉树 DFS 遍历一般是这样的：
void traverse(TreeNode root) { // 判断 base case  if (root == null) { return; } // 访问两个相邻结点：左子结点、右子结点  traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>平衡二叉树 #  1 题目 #  给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1：
 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：
 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：
输入：root = [] 输出：true 提示：
 树中的节点数在范围 [0, 5000] 内 -104 &amp;lt;= Node.val &amp;lt;= 104  2 解题思路 #  2.1 自顶向下（前序遍历） #  2.1.1 问题分析 #   自顶向下判断是否为平衡二叉树的基本思路为：  按照类似于先序遍历的方法判断当前节点的左右子树的高度差是否小于 2。 判断当前节点的左右子树是否为平衡二叉树。   算法的演示动画可参考 平衡二叉树。 该算法存在的缺点是计算左右子树的高度差和判断左右子树是否为平衡二叉树的过程中可能存在节点重复遍历的情况。  2.1.2 参考代码 #  /** * 110.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>二叉树路径问题 #  1 问题分类 #  二叉树路径的问题大致可以分为两类，分别是自顶向下和非自顶向下。
1.1 自顶向下 #  1.1.1 概述 #   自顶向下就是从某一个节点（不一定是根节点）出发，从上向下寻找路径，到某一个节点（不一定是叶节点）结束，继续细分的话，还可以分为一般路径和定和路径。 这类题通常用 深度优先搜索（DFS）和 广度优先搜索（BFS）解决，BFS 一般比 DFS 更为繁琐，这里为了简洁只展现 DFS 代码。 这类题型需要注意以下几点：  如果是找路径和等于给定 $target$ 的路径的，那么可以不用新增一个临时变量来判断当前路径和，只需要用给定和 $target$ 减去节点值，最终结束条件判断 $target == 0$ 即可。 二叉树的问题大部分是不需要回溯的，因为：  二叉树的递归部分（dfs(root -&amp;gt; left)、dfs(root -&amp;gt; right)）已经把可能的路径穷尽了，因此到任意节点的路径只可能有一条，绝对不可能出现另外的路径也到这个满足条件的叶节点的。 而对比二维数组（例如 岛屿问题）的 DFS，for循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此某一个满足条件的点可能是多条路径到该点的，并且 visited数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须回溯。   至于找到路径后是否需要 return，这取决于是否要求找到叶节点满足条件的路径：  如果必须找到叶节点，那么就要 return。 如果是到任意节点都可以，那么必不能 return，因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归。   至于是否需要双重递归（即调用根节点的 dfs 函数后，继续调用根左右节点的 pathsum 函数），需要看题目是要求从根节点开始，还是从任意节点开始。    1.1.2 解题模板 #  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>构造二叉树 #  1 根据前序遍历和中序遍历构造二叉树 #  1.2 题目 #  给定一棵树的前序遍历 preorder 与中序遍历 inorder。请构造二叉树并返回其根节点。
示例 1:
 Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] 示例 2:
Input: preorder = [-1], inorder = [-1] Output: [-1] 提示:
 1 &amp;lt;= preorder.length &amp;lt;= 3000 inorder.length == preorder.length -3000 &amp;lt;= preorder[i], inorder[i] &amp;lt;= 3000 preorder 和 inorder 均无重复元素 inorder 均出现在 preorder preorder 保证为二叉树的前序遍历序列 inorder 保证为二叉树的中序遍历序列  1.3 解题思路 #  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/</guid>
      <description>回溯算法解题框架 #  1 含义 #   回溯算法其实就是我们常说的DFS算法，本质上就是一种暴力穷举算法。 解决一个回溯问题，实际上就是一个决策树的遍历过程，我们只需要思考 3 个问题：  路径： 也就是已经做出的选择。 选择列表： 也就是当前可以做的选择。 约束条件： 也就是到达决策树底层，无法再做选择的条件。    2 框架 #  回溯算法的核心就是for 循环里面的递归，即在递归调用之前【做选择】，在递归调用之后【撤销选择】。
result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 3 应用场景 #  回溯算法的应用场景主要包括以下几个方面：
  全排列。  N皇后。  4 参考文献 #    回溯算法解题套路框架。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>全排列 #  1 题目 #  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：
输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：
输入：nums = [1] 输出：[[1]] 提示：
 1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数互不相同  2 解题思路 #  2.1 回溯算法 #  2.1.1 问题分析 #    全排列对应的回溯树如下图所示，只要从根遍历这棵树，记录路径上的字，其实就是所有的全排列。   我们可以把上面的树称为决策树，因为我们在每个节点上都在做决策，比如说我们站在下面的红色节点上，此时，我们就在做决策，因为 2 那条树枝在我们身后，这个选择我们已经做过了，所以我们只可以选择 1 那条树枝，或者选择 3 那条树枝。   此时：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.3-N%E7%9A%87%E5%90%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.3-N%E7%9A%87%E5%90%8E/</guid>
      <description>N皇后 #  1 题目 #  n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &amp;lsquo;Q&amp;rsquo; 和 &amp;lsquo;.&amp;rsquo; 分别代表了皇后和空位。
示例 1：
 输入：n = 4 输出：[[&amp;#34;.Q..&amp;#34;,&amp;#34;...Q&amp;#34;,&amp;#34;Q...&amp;#34;,&amp;#34;..Q.&amp;#34;],[&amp;#34;..Q.&amp;#34;,&amp;#34;Q...&amp;#34;,&amp;#34;...Q&amp;#34;,&amp;#34;.Q..&amp;#34;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：
输入：n = 1 输出：[[&amp;#34;Q&amp;#34;]] 提示：
 1 &amp;lt;= n &amp;lt;= 9 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。  2 解题思路 #  2.1 回溯算法 #  2.1.1 问题分析 #   N 皇后的问题本质上跟 全排列问题差不多，决策树的每一层表示棋盘的每一行，每个节点可以做出的选择是在该行的任意一列放置一个皇后。 函数backtrack 依然像个在决策树上游走的指针，通过row 和col 就可以表示函数遍历到的位置，通过isValid 函数可以将不符合条件的情况进行剪枝。   2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/</guid>
      <description>快速模幂算法 #  今天来聊一道与数学运算有关的题目，LeetCode 372 题 Super Pow，需要我们进行巨大的幂运算，然后求余数。
int superPow(int a, vector&amp;lt;int&amp;gt;&amp;amp; b); 要求我们的算法返回幂运算 a^b 的计算结果与 1337 取模后的结果。首先我们需要计算 a^b，但是这个 b 会非常大，所以 b 是用数组的形式表示的。
2.1.1 处理数组指数 #  我们可以发现这样一个规律： 通过公式发现我们可以用递归来解决这个问题，因此问题的规模缩小了：
superPow(a, [1,5,6,4]) =&amp;gt; superPow(a, [1,5,6]) 根据这个规律，我们可以写出如下代码框架：
/** * 返回模幂运算 a^[b] 的计算结果与 base 取模后的结果 * 1. a^[1024] = a^4 * a^[1020] * = a^4 * (a^[102])^10 * @param a 底数 * @param b 指数 * @param base 取模数 * @return 模幂运算 a^b 的计算结果与 base 取模后的结果 */ public static int superPow(int a, Vector&amp;lt;Integer&amp;gt; b, int base) { if (b.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</guid>
      <description>搜索二维矩阵 #  1 题目 #  编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1：
 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true 示例 2：
 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false 提示：
 m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 100 -104 &amp;lt;= matrix[i][j], target &amp;lt;= 104  2 解题思路 #  2.1 普通遍历 #  2.1.1 问题分析 #  由于矩阵每行中的整数从左到右按升序排列，每行的第一个整数大于前一行的最后一个整数，因此我们可以按照如下方法来遍历：
 先按行遍历，看每行的第一个元素是否等于目标元素，如果不等于，则找出第一个元素小于等于目标元素，最后一个元素大于等于目标元素的行。  如果能找到这样的行的话，则直接返回 true。 如果找不到这样的行的话，则直接返回 false。    上面的遍历方法时间复杂度较高，可以使用二分查找的方法代替普通查找，这就是下面要用的二分查找法。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>螺旋矩阵 #  1 题目 #  给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
示例 1：
 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：
 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示：
 m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 10 -100 &amp;lt;= matrix[i][j] &amp;lt;= 100  2 问题分析 #  解决这个问题的基本思路是：
 计算需要遍历的圈数$totalRing$：  矩阵的行数$rowNum = matrix.length$。 矩阵的列数$colNum$：  如果 $rowNum &amp;gt; 0$，则 $colNum = matrix[0].length$。 如果 $rowNum \le 0$，则 $colNum = 0$。   令 $totalRingTemp = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</guid>
      <description>x 的平方根 #  1 题目 #  实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4 输出: 2 示例 2:
输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 2 解题思路 #  2.1 暴力解法 #  2.1.1 问题分析 #   暴力解法的基本思路是因为 $i * i = x$，因此 $x / i &amp;gt;= i$ 并且 $x / (i + 1) &amp;lt; (i + 1)$。  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>构造 K 个回文字符串 #  1 题目 #  给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。
如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。 示例 1：
输入：s = &amp;quot;annabelle&amp;quot;, k = 2 输出：true 解释：可以用 s 中所有字符构造 2 个回文字符串。 一些可行的构造方案包括：&amp;quot;anna&amp;quot; + &amp;quot;elble&amp;quot;，&amp;quot;anbna&amp;quot; + &amp;quot;elle&amp;quot;，&amp;quot;anellena&amp;quot; + &amp;quot;b&amp;quot; 示例 2：
输入：s = &amp;quot;leetcode&amp;quot;, k = 3 输出：false 解释：无法用 s 中所有字符构造 3 个回文串。 示例 3：
输入：s = &amp;quot;true&amp;quot;, k = 4 输出：true 解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/</guid>
      <description>如何寻找最⻓回⽂⼦串 #  1 题目 #  给你一个字符串 s，找到 s 中最长的回文子串。
示例 1：
输入：s = &amp;quot;babad&amp;quot; 输出：&amp;quot;bab&amp;quot; 解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。 示例 2：
输入：s = &amp;quot;cbbd&amp;quot; 输出：&amp;quot;bb&amp;quot; 示例 3：
输入：s = &amp;quot;a&amp;quot; 输出：&amp;quot;a&amp;quot; 示例 4：
输入：s = &amp;quot;ac&amp;quot; 输出：&amp;quot;a&amp;quot; 2 问题分析 #  寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串。 可以通过双指针的方法来解决。
3 参考代码 #  package com.grayson.top; import org.apache.commons.lang3.time.StopWatch; import java.util.concurrent.TimeUnit; /** * @author peng.wei * @version 1.0 * @date 2021/3/23 15:05 * @Description 最长回文子串 */ public class L5 { /** * 寻找回文子串 * * @param s 字符串 * @param start 起始字符的下标 * @param end 结束字符的下标 * @return 偶数回文子串的长度 */ public static String palindrome(String s, int start, int end) { int slow = start, fast = end; while (slow &amp;gt;= 0 &amp;amp;&amp;amp; fast &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/</guid>
      <description>如何判定括号的合法性 #  1 题目 #  给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。
示例 1：
输入：s = &amp;quot;()&amp;quot; 输出：true 示例 2：
输入：s = &amp;quot;()[]{}&amp;quot; 输出：true 示例 3：
输入：s = &amp;quot;(]&amp;quot; 输出：false 示例 4：
输入：s = &amp;quot;([)]&amp;quot; 输出：false 示例 5：
输入：s = &amp;quot;{[]}&amp;quot; 输出：true 2 问题解析 #  栈是一种后进先出的结构，处理括号的问题时尤其有用。
我们可以遍历字符串，然后遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。
3 参考代码 #  package com.grayson.top; import org.apache.commons.lang3.time.StopWatch; import javax.xml.stream.events.Characters; import java.util.Stack; import java.util.concurrent.TimeUnit; /** * @author peng.wei * @version 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</guid>
      <description>字符串转换整数 (atoi) #  1 题目 #  请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。  注意：
 本题中的空白字符只包括空格字符 &#39; &#39; 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。  示例 1：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>长度为3的不同回文子序列 #  1 题目 #  给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。
即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。
回文 是正着读和反着读一样的字符串。
子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
例如，&amp;ldquo;ace&amp;rdquo; 是 &amp;ldquo;abcde&amp;rdquo; 的一个子序列。 示例 1：
输入：s = &amp;#34;aabca&amp;#34; 输出：3 解释：长度为 3 的 3 个回文子序列分别是： - &amp;#34;aba&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) - &amp;#34;aaa&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) - &amp;#34;aca&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) 示例 2：
输入：s = &amp;#34;adc&amp;#34; 输出：0 解释：&amp;#34;adc&amp;#34; 不存在长度为 3 的回文子序列。 示例 3：
输入：s = &amp;#34;bbcbaba&amp;#34; 输出：4 解释：长度为 3 的 4 个回文子序列分别是： - &amp;#34;bbb&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;bcb&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;bab&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;aba&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>无重复字符的最长子串 #  1 题目 #  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2:
输入: s = &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。 示例 3:
输入: s = &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。 示例 4:
输入: s = &amp;quot;&amp;quot; 输出: 0 提示：
 0 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由英文字母、数字、符号和空格组成  2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>字符串相加 #  1 题目 #  给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。
提示：
 num1 和 num2 的长度都小于 5100 num1 和 num2 都只包含数字 0-9 num1 和 num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式  2 解题思路 #  2.1 模拟竖式算法 #  2.1.1 问题分析 #   如果两个字符串的长度不同，则将位数较短的字符串补零，使其和较长的字符串长度相同。 将两个字符串各位进行相加：  两个字符串当前数字分别是 $a$、$b$，进位值 $plus$ 初始为 0。 将 $a$、$b$、$plus$ 相加得 $tempRes$，同时令当前位相加结果 $add$ 等于 $tempRes$：  如果 $tempRes&amp;gt;9$，说明当前位有进位，则令 $plus=tempRes/10$，$add=tempRes-plus/10$。 否则令 $plus=0$，说明当前位没有进位。   将当前位相加得结果 $add$ 添加到最终结果 $res$ 中。   如果最后 $plus$ 大于 0，说明最后一位又有进位，将进位结果添加到最终结果 $res$ 中。 前面得到的结果 $res$ 是反的，将其反转一下返回即可。   2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>翻转字符串里的单词 #  1 题目 #  给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
说明：
 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。 翻转后单词间应当仅用一个空格分隔。 翻转后的字符串中不应包含额外的空格。  示例 1：
输入：s = &amp;#34;the sky is blue&amp;#34; 输出：&amp;#34;blue is sky the&amp;#34; 示例 2：
输入：s = &amp;#34; hello world &amp;#34; 输出：&amp;#34;world hello&amp;#34; 解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。 示例 3：
输入：s = &amp;#34;a good example&amp;#34; 输出：&amp;#34;example good a&amp;#34; 解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。 示例 4：
输入：s = &amp;#34; Bob Loves Alice &amp;#34; 输出：&amp;#34;Alice Loves Bob&amp;#34; 示例 5：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</guid>
      <description>环形链表 II #  1 题目 #  给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明： 不允许修改给定的链表。
进阶：
 你是否可以使用 O(1) 空间解决此题？  示例 1：
 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：
 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：
 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示：
 链表中节点的数目范围在范围 [0, 104] 内 -105 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>如何高效判断回文链表 #  1 题目 #  请判断一个链表是否为回文链表。
示例 1:
输入: 1-&amp;gt;2 输出: false 示例 2:
输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
2 不同解法 #  2.1 创建一个新的单链表 #  我们可以把原始链表反转存入一条新的链表，然后比较这两个链表是否相同即可。
/** * Definition for singly-linked list. */ public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } /** * 反转链表 * @param head 单链表的头指针 * @return 反转后的链表 */ private static ListNode reverse(ListNode head) { ListNode p = null; // 遍历并反转链表  while (head !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>K 个一组翻转链表 #  1 题目 #  给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
进阶：
 你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。  示例 1：
 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2：
 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] 示例 3：
输入：head = [1,2,3,4,5], k = 1 输出：[1,2,3,4,5] 示例 4：
输入：head = [1], k = 1 输出：[1] 提示：
 列表中节点的数量在范围 sz 内 1 &amp;lt;= sz &amp;lt;= 5000 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>相交链表 #  1 题目 #  编写一个程序，找到两个单链表相交的起始节点。
如下面的两个链表：
 在节点 c1 开始相交。
示例 1：
 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：
 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>链表中倒数第k个节点 #  1 题目 #  输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2. 返回链表 4-&amp;gt;5.  和该题目类似的题目还有：
  19. 删除链表的倒数第 N 个结点。   2 解题思路 #  2.1 两次遍历 #  2.1.1 问题分析 #   先遍历一下链表，统计一下总的节点个数 $total$。 然后再遍历一下链表，将指针 $p$ 向前移动 $total - k$ 步，此时 $p$ 指向的节点即为倒数第 $k$ 个节点。  2.1.2 参考代码 #  /** * 剑指 Offer 22.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>合并K个升序链表 #  1 题目 #  给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。
示例 1：
输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] 将它们合并到一个有序链表中得到。 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 示例 2：
输入：lists = [] 输出：[] 示例 3：
输入：lists = [[]] 输出：[] 提示：
 k == lists.length 0 &amp;lt;= k &amp;lt;= 10^4 0 &amp;lt;= lists[i].length &amp;lt;= 500 -10^4 &amp;lt;= lists[i][j] &amp;lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4  2 解题思路 #  2.1 两两合并 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/</guid>
      <description>在二叉树中分配硬币 #  1 题目 #  给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
返回使每个结点上只有一枚硬币所需的移动次数。
示例 1：
 输入：[3,0,0] 输出：2 解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2：
 输入：[0,3,0] 输出：3 解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3：
 输入：[1,0,2] 输出：2 示例 4：
 输入：[1,0,0,null,3] 输出：4 ** 提示：**
 1&amp;lt;= N &amp;lt;= 100 0 &amp;lt;= node.val &amp;lt;= N  2 解题思路 #  这里我们引入一个 过载量，用 $O$ 表示，他表示当前节点需要移出的金币数。
例如一个节点 $T_1$ 有 2 枚金币，则他需要移出的金币数为 1，即该节点的过载量 $O(T_1)=1$。
假如一个树 $T$ 有 $k$ 个节点，其中 $m$ 个非叶节点，分别为 $T_1,T_2,T_3,&amp;hellip;,T_m$，$k-m$ 个叶子节点，分别为 $T_{m+1},T_{m+2},T_{m+3},&amp;hellip;,T_k$，则：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>将有序数组转换为二叉搜索树 #  1 题目 #  给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：  示例 2：
 输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 2 解题思路 #  2.1 问题分析 #  二叉搜索树的中序遍历是升序序列，题目中的数组也是按照生序排序的有序数组，因此可以判断数组时二叉搜索树的中序遍历序列。
我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或相差 1，这样可以使得树保持平衡，因此问题的实质可以转化为将有序数组按照中序遍历的方式构造为一棵二叉树即可。
2.2 参考代码 #  package com.grayson.top; import com.grayson.top.domain.TreeNode; /** * @author peng.wei * @version 1.0 * @date 2021/4/9 19:32 * @Description 将有序数组转换为二叉搜索树 */ public class L108 { /** * 创建二叉搜索树 * * @param nums 有序数组 * @param left 左节点下标 * @param right 右节点下标 * @return 创建的二叉树的根节点 */ public TreeNode createBST(int[] nums, int left, int right) { // base case  if (left &amp;gt; right) { return null; } int mid = left + (right - left) / 2; TreeNode node = new TreeNode(); node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>重建二叉树 #  1 题目 #  输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如，给出
前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：
 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000 2 解题思路 #  2.1 递归法 #  2.1.1 问题分析 #  前序遍历性质：节点按照 [根子树 | 左子树 | 右子树] 排序。
中序遍历性质：节点按照 [左子树 | 根节点 | 右子树] 排序。
根据以上性质，可得出以下结论：
 前序遍历的首元素为树的根节点 node 的值。 在中序遍历中搜索根节点 node 的索引，可将中序遍历划分为 [左子树 | 根节点 | 右子树]。 根据中序遍历中的左/右子树的节点数量，可将前序遍历划分为 [根节点 | 左子树 | 右子树]。  通过以上三步，可确定三个节点：树的根节点、左子树根节点、右子树根节点。对于树的左、右子树，仍可使用以上步骤划分子树的左右子树。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>二叉树中的最大路径和 #  1 题目 #  路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1：
输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2：
输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42 提示：
 树中节点数目范围是 [1, 3 * 104] -1000 &amp;lt;= Node.val &amp;lt;= 1000  2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>用栈实现队列 #  1 题目 #  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
 void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false  说明：
 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。  进阶：
 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。  示例：
输入： [&amp;#34;MyQueue&amp;#34;, &amp;#34;push&amp;#34;, &amp;#34;push&amp;#34;, &amp;#34;peek&amp;#34;, &amp;#34;pop&amp;#34;, &amp;#34;empty&amp;#34;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</guid>
      <description>如何高效解决接雨水问题 #  2.3.1 题目 #  给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
示例 1：
 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：
输入：height = [4,2,0,3,2,5] 输出：9 2.3.2 核心思路 #  对于这种问题，我们不要想整体，而应该去想局部。这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下能装 2 格水。
 这是因为位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，假设这两个柱子的高度分别为 leftMax 和 rightMax，则位置 i 的水柱高度为：
water[i] = min(leftMax, rightMax) - height[i]   2.3.3 解法 #  2.3.3.1 暴力解法 #  /** * 获取一个数组中指定下标范围内的最大值 * @param height 数组 * @param startIndex 起始坐标 * @param endIndex 结束坐标 * @return 该数组指定下标范围内的最大值 */ public static int getMax(int[] height, int startIndex, int endIndex) { int max = -1; if (startIndex &amp;lt; 0 || endIndex &amp;gt; height.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</guid>
      <description>最少侧跳次数 #  1 题目 #  给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。
给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。
比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</guid>
      <description>实现 Trie (前缀树) #  1 题目 #  Trie（发音类似 &amp;ldquo;try&amp;rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
示例：
输入 [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;] [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]] 输出 [null, null, true, false, true, null, true]解释 Trie trie = new Trie(); trie.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>LRU 缓存机制 #  1 题目 #  运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 实现 LRUCache 类：
 LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。  进阶： 你是否可以在 O(1) 时间复杂度内完成这两种操作？
示例：
输入 [&amp;#34;LRUCache&amp;#34;, &amp;#34;put&amp;#34;, &amp;#34;put&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;put&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;put&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;, &amp;#34;get&amp;#34;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 #  1 含义 #   单例模式（Singleton Design Pattern）是指保证一个类只能有一个实例，并且提供一个全局访问点。 单例模式的实现需要三个必要条件：   单例类的构造函数必须是私有的，这样才能将类的创建权控制在内部，从而使得类的外部不能创建类的实例。
  单例类通过一个私有的静态变量来存储其唯一实例。
  单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。
 因为单例类的构造函数是私有的，所以单例类不能被继承。
    实现单例类时，需要考虑三个问题：  创建单例对象时，是否线程安全。 单例对象的创建，是否延时加载。 获取单例对象时，是否需要锁（锁会导致低性能）。    2 优缺点 #  2.1 优点 #   在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例，这样就可以防止其他对象对自己的实例化，确保所有的对象都访问一个实例，避免对共享资源的多重占用。 单例模式具有一定的伸缩性，类自己来控制实例化进程，因此在改变实例化进程上有相应的伸缩性。 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁对象时，单例模式无疑可以提高系统的性能。  2.2 缺点 #   不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 由于单例模式没有抽象层，因此单例类的扩展有很大的困难。 滥用单例会带来一些负面影响，例如：  为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。 如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。    3 使用场景 #  在下面几个场景中适合使用单例模式：
 有频繁实例化然后销毁的情况，也就是频繁的new 对象，可以考虑单例模式。 创建对象耗时过多或者耗资源过多，但又经常用到的对象。 频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件。  下面举几个例子来说明一下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂模式 #  1 含义 #   工厂模式提供了一种创建对象的最佳方式， 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象，实现了创建者和调用者的分离。 工厂模式可分为简单工厂模式、工厂方法模式、抽象工厂模式。  2 优缺点 #  2.1 优点 #   工厂模式是我们最常用的实例化对象模式，是用工厂方法代替 new操作的一种模式。 利用工厂模式可以降低程序的耦合性，为后期的维护修改提供很大的便利。 将选择实现类、创建对象统一管理和控制，从而将调用者跟我们的实现类解耦。  3 使用场景 #   首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂模式，而对于简单对象，特别是只需要 new就可以完成创建的对象，无需使用工厂模式，因为如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 其次，工厂模式是一种典型的解耦模式，假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，这会大大降低对象之间的耦合度。 最后，由于工厂模式是依赖抽象架构的，他把实例化产品的任务交由实现类完成，扩展性比较好，也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。  4 分类 #  4.1 简单工厂模式 #  4.1.1 含义 #   简单工厂模式相当于一个工厂中有各种产品，创建一个类时，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。 但是工厂的职责过重，而且类型过多时不利于系统的扩展维护。  4.1.2 UML类图 #   4.1.3 实例 #    创建工厂：
public interface Car { void run(); }   创建工厂的产品（宝马）：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式 #  1 含义 #    代理模式是指通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。
  代码在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能。
 关于代理，以下小例子可以帮助我们理解代理的含义：
 游戏代练 游戏代练这件事就是一个代理模式，所谓代练，就是Proxy，也即代理类，代理的流程是我们把自己的账号交给代练人员，让他们帮我们打怪升级，而我们只需提供账号即可，代练人员那边，他所要做的就是登陆我们的账号，然后替我们打游戏，从第三者的角度看，我们这个角色在打怪升级，但这个第三者并不知道是不是我们本人在打游戏，他只能看到我们这个账号正在打怪升级，但并不需要知道后面打游戏的是谁，这就是代理模式，由他人代理玩游戏。 邀请明星 假设我们现在要邀请明星来上节目，我们应该先给他的经纪人打电话，然后再由经纪人通知到该明星，这里经纪人充当的就是代理的角色。     2 应用场景 #   当不想访问某个对象或访问某个对象存在困难时，就可以为这个对象创建一个代理，通过代理来间接的访问这个对象。 如果原始对象有不同的访问权限，可以使用代理控制对原始对象的访问，保护原始对象。 在访问原始对象时执行一些自己的附加条件。 为某个对象在不同的地址空间提供局部代理，使得系统可以将服务端的实现隐藏，客户端不必考虑服务端的存在。 具体应用场景主要包括Spring AOP、日志打印、异常处理、事务控制、权限控制。  3 分类 #  代理模式主要分为静态代理模式和动态代理模式两类，其中动态代理模式可分为 JDK 动态代理和 cglib 动态代理两种。
3.1 静态代理 #  3.1.1 含义 #   静态代理是由程序员或工具生成代理类的源码，再编译代理类。 所谓静态也就是在程序运行之前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。  3.1.2 类图 #    Subject：抽象主题类，定义了代理对象和真实对象的共同接口方法，既可以是接口，也可以是抽象类。 RealSubject：真实主题类，该类可以称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了 Subject 接口，而Client端通过代理类间接的调用真实主题类的方法，由其执行真实的业务逻辑。 ProxySubject：代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了 Subject 接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。 Client：客户端，使用代理。   相关近义词：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>String、StringBuffer和StringBuilder的区别 #  1 各自的特点 #  1.1 String #    在 Java中字符串属于对象，Java提供了 String类来创建和操作字符串。
  String的值是不可变的，这就导致每次对 String的操作都会生成新的 String对象，这样不仅效率低下，而且大量浪费有限的内存空间，下图是对 String操作时内存变化的图：
  我们可以看到，初始String值是hello，然后在这个字符串后面加上新的字符串world，这个过程是需要在堆内存中开辟内存空间的，最终得到了hello world字符串也需要开辟相应的内存空间。 这样短短的两个字符串，却要开辟三次内存空间，这是对内存空间的极大浪费。    1.2 StringBuffer和StringBuilder #    StringBuffer始于Java 1.0，StringBuilder始于Java 1.5。 StringBuffer的所有方法都是同步（Synchronized）的，因此它是线程安全的，这就导致相比于StringBuilder，它在性能上会差一点；StringBuilder的方法不是同步的（Non-Synchronized），因此它是线程不安全的，因此相比于StringBuffer，他在性能上会好一点。 由于StringBuilder相较于StringBuffer有速度优势，所以大多数情况下建议使用 StringBuilder类，然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer类。  2 三者的区别 #    字符串修改上的区别：
 String： 不可变字符串。 StringBuffer： 可变字符串，效率低，线程安全。 StringBuilder： 可变字符串，效率高，线程不安全。    初始化上的区别：
 String： 可以赋空值。 StringBuffer和StringBuilder： 不能赋空值。  ①String String s = null; String s = “abc”; ②StringBuffer StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this location StringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象 StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”   3 建议 #   如果要操作少量的数据用String。 多线程字符串缓冲区下操作大量数据用StringBuffer。 单线程字符串缓冲区下操作大量数据用StringBuilder。  4 参考文献 #    String vs StringBuffer vs StringBuilder。  图析:String,StringBuffer与StringBuilder的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>HashMap和ConcurrentHashMap实现原理 #  1 HashMap #  1.1 简介 #   Java 为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、HashTable、LinkedHashMap和TreeMap，类继承关系如下图所示：  下面针对各个实现类的特点做一些说明：  HashMap：  根据键的 hashCode 值存储数据，大多数情况下可以直接定位到他的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 最多只允许一条记录的键为 null，允许多条记录为 null。 非线程安全，任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。 如果需要满足线程安全，可以用 Collections 的 synchronizedMap() 方法（该方法也是使用一个全局锁来同步多个线程间的并发访问）使 HashMap 具有线程安全能力，或者使用 ConcurrentHashMap。   HashTable：  HashTable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是他继承自 Dictionary 类，并且是线程安全的：  HashTable线程安全的策略实现代价比较大，简单粗暴，get/put所有相关的操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问的时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。    HashTable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换，因为ConcurrentHashMap 采用了分段锁，并发性比 HashTable 要高很多，具体可参考 2.1 实现原理。    LinkedHashMap：  LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。   TreeMap：  TreeMap 实现了 SortedMap 接口，能够把保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的，如果使用排序的映射，建议使用 TreeMap。 在使用 TreeMap 时，key必须实现 Comparable 接口，或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>ArrayList和LinkedList实现原理 #   如无特殊说明，下面内容的叙述基于的 JDK 版本为 JDK 1.8.0_181。
 1 ArrayList #  1.1 概述 #   ArrayList 的底层数据结构是数组，虽然对于用户来说 ArrayList 是个动态的数组，但是实际上底层是个定长数组，只是在必要的时候，对底层的数组进行扩容，每次扩容 1.5 倍，但是扩容、删除都是有代价的，极端情况下，需要将大量的元素进行移位。 ArrayList不是线程安全的，只能在单线程环境下使用，多线程环境下可以考虑用 Collections.synchronizedList(List&amp;lt;T&amp;gt; list) 返回一个线程安全的 ArrayList 类，也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 ArrayList实现了 Serializable 接口，因此他支持序列化，能够通过序列化传输，实现了 RandomAccess 接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了 Cloneable 接口，能被克隆。  1.2 实现原理 #  1.2.1 构造函数 #  ArrayList 的构造函数一共有三种，分别是无参构造、传入一个整数、传入一个集合。
1.2.1.1 无参构造 #    ArrayList 的无参构造函数源码如下：
transient Object[] elementData; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; public ArrayList() { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>深拷贝与浅拷贝 #  1 数据类型 #  1.1 分类 #  Java 中的数据类型可以分为两大类，分别是基本类型和引用类型。
1.1.1 基本类型 #  Java 中基本类型一共是四类八种，具体如下：
 整型：byte、short、int、long。 浮点类型：float、double。 字符型：char。 逻辑型：boolean。  1.1.2 引用类型 #  除了上面四类八种基本类型外，其他的都是引用类型，包括数组。
1.2 区别 #   基本类型的变量保存原始值，即他代表的值就是数值本身；而引用类型的变量保存引用值，引用值指向内存空间的地址，代表了某个对象的引用，而不是对象本身。 基本类型在声明时系统就给他分配了内存空间，引用类型在声明时只给变量分配了引用空间，而没有分配数据空间。 具体示例如下：   声明一个基本数据类型 int1 并赋值：
int int1 = 100;    声明一个基本数据类型 int2，并赋值为 int1，对于基本数据类型来说，赋值（=号）就相当于拷贝了一份值，把 int1 的值 100，拷贝给 int2。：
int int2 = int1;    将 int1 的值修改为 500：
int1 = 500;    此时，分别打印 int1、int2 的值，会输出为 500、100。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/</guid>
      <description>概述 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/</guid>
      <description>Spring IOC #   如无特殊说明，本文使用的 Spring 版本为 5.3.9。
 1 背景 #   传统的 Java 组件协作方式如下：   假如我们有一个在线书店的项目，通过 BookService 获取书籍：
public class BookService { private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config); public Book getBook(long bookId) { try (Connection conn = dataSource.getConnection()) { ... return book; } } } 为了从数据库查询书籍，BookService 持有一个 DataSource，为了实例化一个 HikariDataSource，又不得不实例化一个 HikariConfig。
  现在我们继续编写 UserService 获取用户：
public class UserService { private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config); public User getUser(long userId) { try (Connection conn = dataSource.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/</guid>
      <description>Spring AOP #   如无特殊说明，本文使用的 Spring 版本为 5.3.9。
 1 背景 #   软件开发一直在寻求一种高效开发、扩展、维护的方式，从面向过程的开发实践中，前人将关注点抽象出来，对行为和属性进行聚合，形成了面向对象的开发思想，其在一定程度上影响了软件开发的过程。 鉴于此，我们在开发的过程中会对软件开发进行抽象、分割成各个模块或对象，例如，我们会对 API 进行抽象成四个模块，分别为Controller、Service、Gateway、Command，这很好地解决了业务级别的开发，但对于系统级别的开发我们很难聚焦，比如，对于每一个模块需要进行打印日志、代码监控、异常处理，以打日志为例，我们只能将日志代码嵌套在各个对象上，而无法关注日志本身，这种现象有偏离了 OOP（Object-Oriented Programming, 面向对象编程）思想。  为了能更好地将系统级别的代码抽离出来，去掉与对象的耦合，就产生了 AOP（Aspect-Oriented Programming, 面向切面编程），如下图所示，OOP 属于一种横向扩展，AOP 属于一种纵向扩展，AOP 依托于 OOP，进一步将系统级别的代码抽象出来，进行纵向排列，实现低耦合。   2 含义 #   AOP，全称为 Aspect-Oriented Programming，即面向切面编程。 它是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点，从关注点中分离出横切关注点是面向切面程序设计的核心概念。 分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过切面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好地管理起来。 Spring AOP 的核心技术是 JDK 动态代理，以动态代理技术为基础，设计出了一系列 AOP 的横切实现，比如前置通知、返回通知、异常通知，同时，Spring AOP 还提供了一系列的 Pointcut来匹配切入点，例如JdkRegexpMethodPointcut（正则切入点）、NameMatchMethodPointcut（方法名切入点），可以使用现有的切入点来设置横切面，也可以扩展相关的 Pointcut 方法来实现切入需求。 为了让 AOP 起作用，需要完成一系列的过程，比如：  需要为目标对象建立代理对象，这个代理对象可以通过使用 JDK 的 Proxy 来完成，也可以通过第三方的代理生成器 CGLIB 来完成。 需要启动代理对象的拦截器来完成各种横切面的织入，这一系列的织入是通过一系列的 Adapter 来实现的，通过这一系列 Adapter 的设计，可以把 AOP 的横切面设计和 Proxy 模式有机地结合起来，从而实现在 AOP 中定义好的各种织入方式。    3 家庭成员 #  Spring AOP 的家庭成员主要包括三个，分别为Advice（通知）、Pointcut（切点）、Advisor（通知器）。</description>
    </item>
    
  </channel>
</rss>
