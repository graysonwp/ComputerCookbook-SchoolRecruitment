<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>排序算法 #  1 简单选择排序 #  1.1 算法原理 #   简单排序算法的基本思想为每一趟从待排序的数据元素中选择最小（最大）的一个元素作为首元素，直到所有元素排完为止。  1.2 参考代码 #   在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小。 交换是个比较耗时的操作，其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。 我们可以通过设置一个变量minInd，每一次比较仅存储较小元素的数组下标，当这一轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。  /** * @author peng.wei * @version 1.0 * @date 2021/5/3 20:52 * @Description 简单选择排序算法 */ public class SimpleSelectionSort { public static void sort(int[] arr) { int m = arr.length; for (int i = 0; i &amp;lt; m - 1; i++) { int minInd = i; for (int j = minInd + 1; j &amp;lt; m; j++) { // 只记录最小元素的位置，而不是每一次比较都交换，减少交换的次数  if (arr[minInd] &amp;gt; arr[j]) {minInd = j;} } if (minInd !</description>
    </item>
    
  </channel>
</rss>
