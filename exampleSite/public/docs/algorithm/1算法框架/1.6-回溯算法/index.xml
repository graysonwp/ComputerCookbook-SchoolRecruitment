<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/</guid>
      <description>回溯算法解题框架 #  1 含义 #   回溯算法其实就是我们常说的DFS算法，本质上就是一种暴力穷举算法。 解决一个回溯问题，实际上就是一个决策树的遍历过程，我们只需要思考 3 个问题：  路径： 也就是已经做出的选择。 选择列表： 也就是当前可以做的选择。 约束条件： 也就是到达决策树底层，无法再做选择的条件。    2 框架 #  回溯算法的核心就是for 循环里面的递归，即在递归调用之前【做选择】，在递归调用之后【撤销选择】。
result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 3 应用场景 #  回溯算法的应用场景主要包括以下几个方面：
  全排列。  N皇后。  4 参考文献 #    回溯算法解题套路框架。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>全排列 #  1 题目 #  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：
输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：
输入：nums = [1] 输出：[[1]] 提示：
 1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数互不相同  2 解题思路 #  2.1 回溯算法 #  2.1.1 问题分析 #    全排列对应的回溯树如下图所示，只要从根遍历这棵树，记录路径上的字，其实就是所有的全排列。   我们可以把上面的树称为决策树，因为我们在每个节点上都在做决策，比如说我们站在下面的红色节点上，此时，我们就在做决策，因为 2 那条树枝在我们身后，这个选择我们已经做过了，所以我们只可以选择 1 那条树枝，或者选择 3 那条树枝。   此时：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.3-N%E7%9A%87%E5%90%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.3-N%E7%9A%87%E5%90%8E/</guid>
      <description>N皇后 #  1 题目 #  n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &amp;lsquo;Q&amp;rsquo; 和 &amp;lsquo;.&amp;rsquo; 分别代表了皇后和空位。
示例 1：
 输入：n = 4 输出：[[&amp;#34;.Q..&amp;#34;,&amp;#34;...Q&amp;#34;,&amp;#34;Q...&amp;#34;,&amp;#34;..Q.&amp;#34;],[&amp;#34;..Q.&amp;#34;,&amp;#34;Q...&amp;#34;,&amp;#34;...Q&amp;#34;,&amp;#34;.Q..&amp;#34;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：
输入：n = 1 输出：[[&amp;#34;Q&amp;#34;]] 提示：
 1 &amp;lt;= n &amp;lt;= 9 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。  2 解题思路 #  2.1 回溯算法 #  2.1.1 问题分析 #   N 皇后的问题本质上跟 全排列问题差不多，决策树的每一层表示棋盘的每一行，每个节点可以做出的选择是在该行的任意一列放置一个皇后。 函数backtrack 依然像个在决策树上游走的指针，通过row 和col 就可以表示函数遍历到的位置，通过isValid 函数可以将不符合条件的情况进行剪枝。   2.</description>
    </item>
    
  </channel>
</rss>
