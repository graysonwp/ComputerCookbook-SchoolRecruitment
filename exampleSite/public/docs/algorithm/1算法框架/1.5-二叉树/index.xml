<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树遍历 #  1 算法模板 #  二叉树遍历算法分为两种，一种是深度优先遍历算法，例如前序遍历、中序遍历、后序遍历，另一种是广度优先遍历算法，例如层次遍历。
1.1 深度优先遍历算法 #  1.1.1 递归解法 #  1.1.1.1 前序遍历 #  /** * 前序遍历（递归解法） * * @param head 头结点 */ public void preOrderRecur(TreeNode head) { // base case  if (head == null) { return; } // 访问根节点  System.out.println(head.val); // 遍历左节点  preOrderRecur(head.left); // 遍历右节点  preOrderRecur(head.right); } 1.1.1.2 中序遍历 #  /** * 中序遍历（递归解法） * * @param head 头结点 */ public void inOrderRecur(TreeNode head) { // base case  if (head == null) { return; } // 遍历左节点  preOrderRecur(head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</guid>
      <description>1 前言 #   我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的，而我们今天要讨论的 DFS 问题，是在一种【网格】结构中进行的，岛屿问题是这类网格 DFS 问题的典型代表。 网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。 本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。  2 网格问题的基本概念 #   我们首先要明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。 网格问题是由 $m \times n$ 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。 岛屿问题是一类典型的网格问题，每个格子中的数字可能是 0 或者 1，我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。   在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等，不过这些问题，基本都可以用 DFS 遍历来解决。  3 网格 DFS 的基本结构 #  3.1 基本结构 #    网格结构要比二叉树结构稍微复杂一些，他其实是一种简化版的图结构，要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历，我们写的 二叉树 DFS 遍历一般是这样的：
void traverse(TreeNode root) { // 判断 base case  if (root == null) { return; } // 访问两个相邻结点：左子结点、右子结点  traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>平衡二叉树 #  1 题目 #  给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
示例 1：
 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2：
 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3：
输入：root = [] 输出：true 提示：
 树中的节点数在范围 [0, 5000] 内 -104 &amp;lt;= Node.val &amp;lt;= 104  2 解题思路 #  2.1 自顶向下（前序遍历） #  2.1.1 问题分析 #   自顶向下判断是否为平衡二叉树的基本思路为：  按照类似于先序遍历的方法判断当前节点的左右子树的高度差是否小于 2。 判断当前节点的左右子树是否为平衡二叉树。   算法的演示动画可参考 平衡二叉树。 该算法存在的缺点是计算左右子树的高度差和判断左右子树是否为平衡二叉树的过程中可能存在节点重复遍历的情况。  2.1.2 参考代码 #  /** * 110.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>二叉树路径问题 #  1 问题分类 #  二叉树路径的问题大致可以分为两类，分别是自顶向下和非自顶向下。
1.1 自顶向下 #  1.1.1 概述 #   自顶向下就是从某一个节点（不一定是根节点）出发，从上向下寻找路径，到某一个节点（不一定是叶节点）结束，继续细分的话，还可以分为一般路径和定和路径。 这类题通常用 深度优先搜索（DFS）和 广度优先搜索（BFS）解决，BFS 一般比 DFS 更为繁琐，这里为了简洁只展现 DFS 代码。 这类题型需要注意以下几点：  如果是找路径和等于给定 $target$ 的路径的，那么可以不用新增一个临时变量来判断当前路径和，只需要用给定和 $target$ 减去节点值，最终结束条件判断 $target == 0$ 即可。 二叉树的问题大部分是不需要回溯的，因为：  二叉树的递归部分（dfs(root -&amp;gt; left)、dfs(root -&amp;gt; right)）已经把可能的路径穷尽了，因此到任意节点的路径只可能有一条，绝对不可能出现另外的路径也到这个满足条件的叶节点的。 而对比二维数组（例如 岛屿问题）的 DFS，for循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此某一个满足条件的点可能是多条路径到该点的，并且 visited数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须回溯。   至于找到路径后是否需要 return，这取决于是否要求找到叶节点满足条件的路径：  如果必须找到叶节点，那么就要 return。 如果是到任意节点都可以，那么必不能 return，因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归。   至于是否需要双重递归（即调用根节点的 dfs 函数后，继续调用根左右节点的 pathsum 函数），需要看题目是要求从根节点开始，还是从任意节点开始。    1.1.2 解题模板 #  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>构造二叉树 #  1 根据前序遍历和中序遍历构造二叉树 #  1.2 题目 #  给定一棵树的前序遍历 preorder 与中序遍历 inorder。请构造二叉树并返回其根节点。
示例 1:
 Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] 示例 2:
Input: preorder = [-1], inorder = [-1] Output: [-1] 提示:
 1 &amp;lt;= preorder.length &amp;lt;= 3000 inorder.length == preorder.length -3000 &amp;lt;= preorder[i], inorder[i] &amp;lt;= 3000 preorder 和 inorder 均无重复元素 inorder 均出现在 preorder preorder 保证为二叉树的前序遍历序列 inorder 保证为二叉树的中序遍历序列  1.3 解题思路 #  1.</description>
    </item>
    
  </channel>
</rss>
