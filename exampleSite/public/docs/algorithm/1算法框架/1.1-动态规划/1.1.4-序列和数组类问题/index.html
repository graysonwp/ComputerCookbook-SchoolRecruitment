<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="序列和数组类问题 #  1 序列类问题 #  1.1 最长递增子序列 #  1.1.1 题目 #  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：
输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：
输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：
 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104  进阶：
 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗?  1.1.2 解题思路 #  1.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="序列和数组类问题 #  1 序列类问题 #  1.1 最长递增子序列 #  1.1.1 题目 #  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：
输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：
输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：
 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104  进阶：
 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗?  1.1.2 解题思路 #  1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="docs" />



<title>1.1.4 序列和数组类问题 | Computer Cookbook School Recruitment</title>
<link rel="manifest" href="/school-recruitment/manifest.json">
<link rel="icon" href="/school-recruitment/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/school-recruitment/book.min.57f7f660871517a5bfcfb5e2de853d806f7e34d94ebd5f3f3bad62e9ddbae209.css" integrity="sha256-V/f2YIcVF6W/z7Xi3oU9gG9&#43;NNlOvV8/O61i6d264gk=" crossorigin="anonymous">
  <script defer src="/school-recruitment/flexsearch.min.js"></script>
  <script defer src="/school-recruitment/en.search.min.ddcf6bcf59f53a854992903fddbc3eb404e9294c5826045ce92334fde6a3e27e.js" integrity="sha256-3c9rz1n1OoVJkpA/3bw&#43;tATpKUxYJgRc6SM0/eaj4n4=" crossorigin="anonymous"></script>

  <script defer src="/school-recruitment/sw.min.07899fc95e217f83f76b676678ae96a3d8d0d0b042f9f17c3f23eec2551b7b12.js" integrity="sha256-B4mfyV4hf4P3a2dmeK6Wo9jQ0LBC&#43;fF8PyPuwlUbexI=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />

  <a href="https://github.com/wpwbb510582246/ComputerCookbook-SchoolRecruitment" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;z-index: 100;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/school-recruitment/"><span>Computer Cookbook School Recruitment</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://www.grayson.top" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/graysonwp" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






<hr>


  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-353f7a5578fa41dbc42c73ea30fe2255" class="toggle" checked />
    <label for="section-353f7a5578fa41dbc42c73ea30fe2255" class="flex justify-between">
      <a role="button" class="">第一章 算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e0c159ebe8e8b165cd558008fb5f5074" class="toggle" checked />
    <label for="section-e0c159ebe8e8b165cd558008fb5f5074" class="flex justify-between">
      <a role="button" class="">1、算法框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="toggle" checked />
    <label for="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="flex justify-between">
      <a role="button" class="">1.1 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" class="">1.1.1 斐波那契数列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="">1.1.2 背包问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="">1.1.3 贪心算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84%E7%B1%BB%E9%97%AE%E9%A2%98/" class=" active">1.1.4 序列和数组类问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" class="">1.1.5 编辑距离</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/" class="">1.1.6 高楼扔鸡蛋</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/" class="">1.1.7 股票问题系列通解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/" class="">1.1.8 最长有效括号</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/" class="">1.1.9 股票问题系列通解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/" class="">1.1.10 最长重复子数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/" class="">1.1.11 最长有效括号</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e36081c41f3a4d8d8355cae83c46c9b8" class="toggle"  />
    <label for="section-e36081c41f3a4d8d8355cae83c46c9b8" class="flex justify-between">
      <a role="button" class="">1.2 二分查找</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/" class="">1.2.1 二分查找框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">1.2.2 搜索旋转排序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="">1.2.3 如何运用二分查找算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ac9691c4865fdec0880b3cb638bc594" class="toggle"  />
    <label for="section-2ac9691c4865fdec0880b3cb638bc594" class="flex justify-between">
      <a role="button" class="">1.3 数据结构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">1.3.1 反转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="">1.3.2 相交链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" class="">1.3.3 链表中倒数第k个节点</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2adde4460efeae2e3f7fc587adb365a8" class="toggle"  />
    <label for="section-2adde4460efeae2e3f7fc587adb365a8" class="flex justify-between">
      <a role="button" class="">1.4 排序算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.4.1-%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="">1.4.1 常见排序算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.4.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" class="">1.4.2 数组中的第k个最大元素</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b9f975ded87a304ee48569c44f19492" class="toggle"  />
    <label for="section-9b9f975ded87a304ee48569c44f19492" class="flex justify-between">
      <a role="button" class="">1.5 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">1.5.1 二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/" class="">1.5.2 岛屿问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.3 平衡二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="">1.5.4 二叉树路径问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.5 构造二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="">1.5.6 二叉树的最近公共祖先</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4571e95d0021653ce2d27ee4b0838ca0" class="toggle"  />
    <label for="section-4571e95d0021653ce2d27ee4b0838ca0" class="flex justify-between">
      <a role="button" class="">1.6 回溯算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/" class="">1.6.1 回溯算法解题框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-N%E7%9A%87%E5%90%8E/" class="">1.6.2 N皇后</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d6fac765b0c7fea77c79961a611f9f8f" class="toggle"  />
    <label for="section-d6fac765b0c7fea77c79961a611f9f8f" class="flex justify-between">
      <a role="button" class="">1.7 数组</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.7-%E6%95%B0%E7%BB%84/1.7.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="">1.7.1 删除有序数组中的重复项</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.7-%E6%95%B0%E7%BB%84/1.7.2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" class="">1.7.2 滑动窗口最大值</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-07c6c41b5fb22f09768b6f4e1da46596" class="toggle"  />
    <label for="section-07c6c41b5fb22f09768b6f4e1da46596" class="flex justify-between">
      <a role="button" class="">1.8 字符串</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.1-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" class="">1.8.1 最小覆盖子串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/" class="">1.8.2 字符串相乘</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.3-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/" class="">1.8.3 比较版本号</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.4-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/" class="">1.8.4 验证 Ip地址</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.5-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II/" class="">1.8.5 基本计算器 Ii</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8b579ed4452b6a8d2017a24343689b5c" class="toggle"  />
    <label for="section-8b579ed4452b6a8d2017a24343689b5c" class="flex justify-between">
      <a role="button" class="">2、高频面试题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5a653711e83b11abc9ab6143b1a9fd64" class="toggle"  />
    <label for="section-5a653711e83b11abc9ab6143b1a9fd64" class="flex justify-between">
      <a role="button" class="">2.1 数学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/" class="">2.1.1 快速模幂算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/" class="">2.1.2 搜索二维矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="">2.1.3 螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" class="">2.1.4 X 的平方根</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5c279474332677699cd0b53888bd51ba" class="toggle"  />
    <label for="section-5c279474332677699cd0b53888bd51ba" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="">2.2 二分查找</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e057e8659d2f838952397ed15d20f46c" class="toggle"  />
    <label for="section-e057e8659d2f838952397ed15d20f46c" class="flex justify-between">
      <a role="button" class="">2.3 数组</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.1 如何寻找消失的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.2 如何寻找缺失和重复的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.3-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/" class="">2.3.3 找出数组游戏的赢家</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E6%9C%80%E5%A4%A7%E6%95%B0/" class="">2.3.4 最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="">2.3.5 二维数组中的查找</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.6 两数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.7 三数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">2.3.8 合并两个有序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/" class="">2.3.9 下一个排列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/" class="">2.3.10 缺失的第一个正数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.11-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="">2.3.11 寻找两个正序数组的中位数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.12-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" class="">2.3.12 多数元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.13-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" class="">2.3.13 最长连续序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.14-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B4/" class="">2.3.14 给定数字能组成的最大时间</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="toggle"  />
    <label for="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="flex justify-between">
      <a role="button" class="">2.4 字符串</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">2.4.1 构造 K 个回文字符串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/" class="">2.4.2 如何寻找最 回 串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/" class="">2.4.3 如何判定括号的合法性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/" class="">2.4.4 字符串转换整数 (Atoi)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">2.4.5 长度为3的不同回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="">2.4.6 无重复字符的最长子串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/" class="">2.4.7 字符串相加</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/" class="">2.4.8 翻转字符串里的单词</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c2cc4653d849ecb4e8d0df9162693740" class="toggle"  />
    <label for="section-c2cc4653d849ecb4e8d0df9162693740" class="flex justify-between">
      <a role="button" class="">2.5 链表</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/" class="">2.5.1 环形链表 Ii</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" class="">2.5.2 如何高效判断回文链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="">2.5.3 合并 K个升序链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="">2.5.4 相交链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" class="">2.5.5 链表中倒数第k个节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="">2.5.6 合并 K个升序链表</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-95a636b3d00f4ce42d96beeef34d9742" class="toggle"  />
    <label for="section-95a636b3d00f4ce42d96beeef34d9742" class="flex justify-between">
      <a role="button" class="">2.6 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/" class="">2.6.1 在二叉树中分配硬币</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="">2.6.2 将有序数组转换为二叉搜索树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">2.6.4 重建二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="">2.6.5 二叉树中的最大路径和</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2dca4a28932da6fd2ab80d6adf86f380" class="toggle"  />
    <label for="section-2dca4a28932da6fd2ab80d6adf86f380" class="flex justify-between">
      <a role="button" class="">2.7 队列</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" class="">2.7.1 用栈实现队列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9868fca37e026543bb4220219b385440" class="toggle"  />
    <label for="section-9868fca37e026543bb4220219b385440" class="flex justify-between">
      <a role="button" class="">2.8 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/" class="">2.8.1 如何高效解决接雨水问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/" class="">2.8.2 最少侧跳次数</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2b868ec58580c16b57b76d0e583b5ec9" class="toggle"  />
    <label for="section-2b868ec58580c16b57b76d0e583b5ec9" class="flex justify-between">
      <a role="button" class="">2.9 设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/" class="">2.9.1 实现 Trie (前缀树)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="">2.9.2 Lru 缓存机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0922907dd56f7a4a192db7338c0e7143" class="toggle"  />
    <label for="section-0922907dd56f7a4a192db7338c0e7143" class="flex justify-between">
      <a role="button" class="">第二章 计算机基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e090ea075956ea0a88f3be27eb8b8174" class="toggle"  />
    <label for="section-e090ea075956ea0a88f3be27eb8b8174" class="flex justify-between">
      <a role="button" class="">1、计算机网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-043e7911fd2d67fbc52b823c1516a0d8" class="toggle"  />
    <label for="section-043e7911fd2d67fbc52b823c1516a0d8" class="flex justify-between">
      <a role="button" class="">1.1 传输层： Tcp和 UDP</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="">1.1.1 三次握手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="">1.1.2 四次挥手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="">1.1.3 流量控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="">1.1.5 拥塞控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1.6 Tcp和 Udp的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="">1.1.7 Tcp如何保证传输的可靠性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" class="">1.1.8 Tcp长连接和短连接</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="toggle"  />
    <label for="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="flex justify-between">
      <a role="button" class="">1.2 应用层：HTTP和HTTPS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.1 Http和 HTTP S的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.2 Get和 Post的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.3 Session与 Cookie的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/" class="">1.2.4 从输入网址到获得页面的过程（越详细越好）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/" class="">1.2.5 Http请求有哪些常见的状态码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="">1.2.6 什么是 Rip，算法是什么</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/" class="">1.2.7 Http1.0、 Http1.1和 Http2.0的主要区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/" class="">1.2.8 DNS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" class="">1.2.9 HTTP S加密和认证过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" class="">1.2.10 常见网络攻击</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/" class="">1.2.11 Rest</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3-%E8%AE%A1%E7%AE%97%E5%85%B6%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="">1.3 计算其网络体系结构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="toggle"  />
    <label for="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="flex justify-between">
      <a role="button" class="">1.4 网络层协议</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" class="">1.4.1 Ip地址的分类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/" class="">1.4.2 划分子网</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/" class="">1.4.3 什么是 Arp协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/" class="">1.4.4 Nat协议</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-09f7d8995bc26810475d1c56597a312e" class="toggle"  />
    <label for="section-09f7d8995bc26810475d1c56597a312e" class="flex justify-between">
      <a role="button" class="">2、操作系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2f767bf946d6dc8ddeda6b6435471e5b" class="toggle"  />
    <label for="section-2f767bf946d6dc8ddeda6b6435471e5b" class="flex justify-between">
      <a role="button" class="">2.1 进程和线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.1.1 进程和线程的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="">2.1.2 进程间通信方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="">2.1.3 进程同步问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/" class="">2.1.4 进程有哪几种状态</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" class="">2.1.5 进程调度策略</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" class="">2.1.6 僵尸进程和孤儿进程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="">2.1.7 线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/" class="">2.1.8 协程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="">2.1.9 异常控制流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="">2.1.10 Io多路复用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/" class="">2.1.11 用户态和内核态</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.2-%E6%AD%BB%E9%94%81/" class="">2.2 死锁</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b2b1a78994c9898abed1b08fef134abd" class="toggle"  />
    <label for="section-b2b1a78994c9898abed1b08fef134abd" class="flex justify-between">
      <a role="button" class="">2.3 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/" class="">2.3.1 分页和分段</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="">2.3.2 虚拟内存</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="">2.3.3 页面置换算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/" class="">2.3.4 局部性原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="">2.3.5 缓冲区溢出</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/" class="">2.4 磁盘调度</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e28cc33fe5745d14abf4a0147d0624a5" class="toggle"  />
    <label for="section-e28cc33fe5745d14abf4a0147d0624a5" class="flex justify-between">
      <a role="button" class="">第三章 数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6fd3cab540793410b1ce567d790deadc" class="toggle"  />
    <label for="section-6fd3cab540793410b1ce567d790deadc" class="flex justify-between">
      <a role="button" class="">1、数据库基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/" class="">1.1 事务的概念和特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/" class="">1.2 锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/" class="">1.3 锁协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/" class="">1.4 事务日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.5 Mvcc实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12290256fbd76ac6014c39648c5827fe" class="toggle"  />
    <label for="section-12290256fbd76ac6014c39648c5827fe" class="flex justify-between">
      <a role="button" class="">1.6 基础知识</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/" class="">1.6.1 三范式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" class="">1.6.2 多表连接方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="">1.6.3 存储过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.6.4 Delete、 Truncate和 Drop的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/" class="">1.6.5 触发器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/" class="">1.6.6 视图</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d1b14978df09adfe15777e58b9b435ec" class="toggle"  />
    <label for="section-d1b14978df09adfe15777e58b9b435ec" class="flex justify-between">
      <a role="button" class="">2、 My SQL</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/" class="">2.1 索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="">2.2 B 树、 B 树索引算法原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/" class="">2.3 索引组织表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.4 Inno Db和 My Isam的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/" class="">2.5 Checkpoint技术</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/" class="">2.6 宕机恢复原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="">2.7 数据库优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="">2.8 分库分表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="">2.9 一致性哈希算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="">2.10 主从复制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-53f351d3e26dfa58c34e937b76a0c4ce" class="toggle"  />
    <label for="section-53f351d3e26dfa58c34e937b76a0c4ce" class="flex justify-between">
      <a role="button" class="">3、 Redis</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-356f36d039b40fdb10be19d36f2f2793" class="toggle"  />
    <label for="section-356f36d039b40fdb10be19d36f2f2793" class="flex justify-between">
      <a role="button" class="">3.1 概述</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/" class="">3.1.1 为什么 Redis单线程还这么快</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="">3.1.2 Redis数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="">3.1.3 持久化机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="">3.1.4 过期机制和内存淘汰策略</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.2-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="">3.2 线程模型</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4731e97839509d5614da88af39acf326" class="toggle"  />
    <label for="section-4731e97839509d5614da88af39acf326" class="flex justify-between">
      <a role="button" class="">3.3 分布式问题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="">3.3.1 Redis实现分布式锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-555105a060edfd5dfac44ac6d49d31e5" class="toggle"  />
    <label for="section-555105a060edfd5dfac44ac6d49d31e5" class="flex justify-between">
      <a role="button" class="">3.4 缓存异常</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" class="">3.4.1 缓存穿透、缓存击穿、缓存雪崩</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c0c910bcaee9694f45ce547519533401" class="toggle"  />
    <label for="section-c0c910bcaee9694f45ce547519533401" class="flex justify-between">
      <a role="button" class="">3.5 高可用</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.5-%E9%AB%98%E5%8F%AF%E7%94%A8/3.5.1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="">3.5.1 主从复制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.5-%E9%AB%98%E5%8F%AF%E7%94%A8/3.5.2-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/" class="">3.5.2 哨兵模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.5-%E9%AB%98%E5%8F%AF%E7%94%A8/3.5.3-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" class="">3.5.3 集群模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f0d841e400bf38796a65a65ef72b420e" class="toggle"  />
    <label for="section-f0d841e400bf38796a65a65ef72b420e" class="flex justify-between">
      <a role="button" class="">第四章 设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/" class="">1、概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e796a2fc1bf6b4e9454f5a191dd15040" class="toggle"  />
    <label for="section-e796a2fc1bf6b4e9454f5a191dd15040" class="flex justify-between">
      <a role="button" class="">2、创建型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="">2.1 单例模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="">2.2 工厂模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="toggle"  />
    <label for="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="flex justify-between">
      <a role="button" class="">3、结构型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="">3.1 代理模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="">3.2 装饰器模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0f94fb8c7e53c880650621fdcc596283" class="toggle"  />
    <label for="section-0f94fb8c7e53c880650621fdcc596283" class="flex justify-between">
      <a role="button" class="">4、行为型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/4%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="">4.1 策略模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-eca69da21de5b0cd25d8421dec09a327" class="toggle"  />
    <label for="section-eca69da21de5b0cd25d8421dec09a327" class="flex justify-between">
      <a role="button" class="">第五章 Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a64d861c08691e8f06f1178d4d28cf04" class="toggle"  />
    <label for="section-a64d861c08691e8f06f1178d4d28cf04" class="flex justify-between">
      <a role="button" class="">1、 Java基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1 String、 String Buffer和 String Builder的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.2 Hash Map和 Concurrent Hash Map实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.3 Array List和 Linked List实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="">1.4 深拷贝与浅拷贝</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/" class="">1.5 抽象类与接口</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="toggle"  />
    <label for="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="flex justify-between">
      <a role="button" class="">2、 Java多线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" class="">2.1 并发编程的三大特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" class="">2.2 指令重排</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Volatile%E5%8E%9F%E7%90%86/" class="">2.3 Volatile原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-CAS%E5%8E%9F%E7%90%86/" class="">2.4 Cas原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/" class="">2.5 Java的4种引用级别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="">2.6 Java中的锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.7 Synchronized实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.8 线程池实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-AQS/" class="">2.9 Aqs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65e183c484720f91ba3d1676e1ed5a16" class="toggle"  />
    <label for="section-65e183c484720f91ba3d1676e1ed5a16" class="flex justify-between">
      <a role="button" class="">3、 Jvm</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" class="">3.1 运行时数据区域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/" class="">3.2 判断对象是否存活的方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="">3.3 垃圾收集算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="">3.4 类的生命周期和加载过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/" class="">3.5 类加载时机</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="">3.6 类加载器的种类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/" class="">3.7 类加载机制的特点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="">3.8 Jvm内存结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.9 常见的垃圾收集算法有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/" class="">3.10 指针碰撞和空闲列表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.11 常见的垃圾收集器有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">3.12 内存溢出与内存泄漏的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.13 常用的 Jvm启动参数有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="">3.14 反射机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-78e3fdb9e302e0ddb1abf0723557c671" class="toggle"  />
    <label for="section-78e3fdb9e302e0ddb1abf0723557c671" class="flex justify-between">
      <a role="button" class="">4、 Nio</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/4NIO/4.1-%E6%A6%82%E8%BF%B0/" class="">4.1 概述</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="toggle"  />
    <label for="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="flex justify-between">
      <a role="button" class="">第六章 Spring全家桶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-afe35ec73fb23fd24d05388dd4f6d178" class="toggle"  />
    <label for="section-afe35ec73fb23fd24d05388dd4f6d178" class="flex justify-between">
      <a role="button" class="">1、 Spring</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/" class="">1.1 概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/" class="">1.2 Spring Ioc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/" class="">1.3 Spring Aop</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b63cda05fe80f821d31813480ebd8acb" class="toggle"  />
    <label for="section-b63cda05fe80f821d31813480ebd8acb" class="flex justify-between">
      <a role="button" class="">2、 Spring Boot</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/2SpringBoot/2.1-SpringSpringBootSpringCloud%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/" class="">2.1 Spring、 Spring Boot、 Spring Cloud的联系与区别</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/school-recruitment/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>1.1.4 序列和数组类问题</strong>

  <label for="toc-control">
    
    <img src="/school-recruitment/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"> </script>
  <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })</script>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#序列和数组类问题">序列和数组类问题</a>
      <ul>
        <li><a href="#1-序列类问题">1 序列类问题</a>
          <ul>
            <li><a href="#11-最长递增子序列httpsleetcode-cncomproblemslongest-increasing-subsequence">1.1 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">最长递增子序列</a></a>
              <ul>
                <li><a href="#111-题目">1.1.1 题目</a></li>
                <li><a href="#112-解题思路">1.1.2 解题思路</a>
                  <ul>
                    <li><a href="#1121-动态规划法">1.1.2.1 动态规划法</a>
                      <ul>
                        <li><a href="#11211-问题分析">1.1.2.1.1 问题分析</a></li>
                        <li><a href="#11212-参考代码">1.1.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#1122-二分查找法">1.1.2.2 二分查找法</a>
                      <ul>
                        <li><a href="#11221-问题分析">1.1.2.2.1 问题分析</a></li>
                        <li><a href="#11222-参考代码">1.1.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#12-最长回文子序列httpsleetcode-cncomproblemslongest-palindromic-subsequence">1.2 <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">最长回文子序列</a></a>
              <ul>
                <li><a href="#121-题目">1.2.1 题目</a></li>
                <li><a href="#122-解题思路">1.2.2 解题思路</a>
                  <ul>
                    <li><a href="#1221-子序列问题处理模板">1.2.2.1 子序列问题处理模板</a>
                      <ul>
                        <li><a href="#12211-一维-dp-数组">1.2.2.1.1 一维 dp 数组</a></li>
                        <li><a href="#12212-二维-dp-数组">1.2.2.1.2 二维 dp 数组</a></li>
                      </ul>
                    </li>
                    <li><a href="#1222-问题分析">1.2.2.2 问题分析</a></li>
                    <li><a href="#1223-参考代码">1.2.2.3 参考代码</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#13-最长公共子序列httpsleetcode-cncomproblemslongest-common-subsequence">1.3 <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></a>
              <ul>
                <li><a href="#131-解题思路">1.3.1 解题思路</a>
                  <ul>
                    <li><a href="#1311-动态规划">1.3.1.1 动态规划</a>
                      <ul>
                        <li><a href="#13111-问题分析">1.3.1.1.1 问题分析</a></li>
                        <li><a href="#13112-参考代码">1.3.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#2-数组类问题">2 数组类问题</a>
          <ul>
            <li><a href="#21-最大子序和httpsleetcode-cncomproblemsmaximum-subarray">2.1 <a href="https://leetcode-cn.com/problems/maximum-subarray">最大子序和</a></a>
              <ul>
                <li><a href="#211-题目">2.1.1 题目</a></li>
                <li><a href="#212-解题思路">2.1.2 解题思路</a>
                  <ul>
                    <li><a href="#2121-暴力法">2.1.2.1 暴力法</a>
                      <ul>
                        <li><a href="#21211-问题分析">2.1.2.1.1 问题分析</a></li>
                        <li><a href="#21212-参考代码">2.1.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2122-动态规划">2.1.2.2 动态规划</a>
                      <ul>
                        <li><a href="#21221-问题分析">2.1.2.2.1 问题分析</a></li>
                        <li><a href="#21222-参考代码">2.1.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2123-贪心法">2.1.2.3 贪心法</a>
                      <ul>
                        <li><a href="#21231-问题解析">2.1.2.3.1 问题解析</a></li>
                        <li><a href="#21232-参考代码">2.1.2.3.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-打家劫舍httpsleetcode-cncomproblemshouse-robber">2.2 <a href="https://leetcode-cn.com/problems/house-robber">打家劫舍</a></a>
              <ul>
                <li><a href="#221-解题思路">2.2.1 解题思路</a>
                  <ul>
                    <li><a href="#2211-动态规划">2.2.1.1 动态规划</a>
                      <ul>
                        <li><a href="#22111-问题分析">2.2.1.1.1 问题分析</a></li>
                        <li><a href="#22112-参考代码">2.2.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#23-乘积最大子数组httpsleetcode-cncomproblemsmaximum-product-subarray">2.3 <a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a></a>
              <ul>
                <li><a href="#231-解题思路">2.3.1 解题思路</a>
                  <ul>
                    <li><a href="#2311-动态规划">2.3.1.1 动态规划</a>
                      <ul>
                        <li><a href="#23111-问题分析">2.3.1.1.1 问题分析</a></li>
                        <li><a href="#23112-参考代码">2.3.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#24-三角形最小路径和httpsleetcode-cncomproblemstriangle">2.4 <a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></a>
              <ul>
                <li><a href="#241-解题思路">2.4.1 解题思路</a>
                  <ul>
                    <li><a href="#2411-动态规划">2.4.1.1 动态规划</a>
                      <ul>
                        <li><a href="#24111-问题分析">2.4.1.1.1 问题分析</a></li>
                        <li><a href="#24112-参考代码">2.4.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#25-解码方法httpsleetcode-cncomproblemsdecode-ways">2.5 <a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></a>
              <ul>
                <li><a href="#251-解题思路">2.5.1 解题思路</a>
                  <ul>
                    <li><a href="#2511-动态规划">2.5.1.1 动态规划</a>
                      <ul>
                        <li><a href="#25111-问题分析">2.5.1.1.1 问题分析</a></li>
                        <li><a href="#25112-参考代码">2.5.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#26-打家劫舍-iihttpsleetcode-cncomproblemshouse-robber-ii">2.6 <a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></a>
              <ul>
                <li><a href="#261-解题思路">2.6.1 解题思路</a>
                  <ul>
                    <li><a href="#2611-动态规划">2.6.1.1 动态规划</a>
                      <ul>
                        <li><a href="#26111-问题分析">2.6.1.1.1 问题分析</a></li>
                        <li><a href="#26112-参考代码">2.6.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#27-最长重复子数组httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray">2.7 <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray">最长重复子数组</a></a>
              <ul>
                <li><a href="#271-题目">2.7.1 题目</a></li>
                <li><a href="#272-解题思路">2.7.2 解题思路</a>
                  <ul>
                    <li><a href="#2721-暴力解法">2.7.2.1 暴力解法</a>
                      <ul>
                        <li><a href="#27211-问题分析">2.7.2.1.1 问题分析</a></li>
                        <li><a href="#27212-参考代码">2.7.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2722-动态规划">2.7.2.2 动态规划</a>
                      <ul>
                        <li><a href="#27221-问题分析">2.7.2.2.1 问题分析</a></li>
                        <li><a href="#27222-参考代码">2.7.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2723-滑动窗口">2.7.2.3 滑动窗口</a>
                      <ul>
                        <li><a href="#27231-问题分析">2.7.2.3.1 问题分析</a></li>
                        <li><a href="#27232-参考代码">2.7.2.3.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="序列和数组类问题">
  序列和数组类问题
  <a class="anchor" href="#%e5%ba%8f%e5%88%97%e5%92%8c%e6%95%b0%e7%bb%84%e7%b1%bb%e9%97%ae%e9%a2%98">#</a>
</h1>
<h2 id="1-序列类问题">
  1 序列类问题
  <a class="anchor" href="#1-%e5%ba%8f%e5%88%97%e7%b1%bb%e9%97%ae%e9%a2%98">#</a>
</h2>
1.1 <h3 id="11-最长递增子序列httpsleetcode-cncomproblemslongest-increasing-subsequence">
  
  <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">最长递增子序列</a>
  <a class="anchor" href="#11-%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemslongest-increasing-subsequence">#</a>
</h3>
<h4 id="111-题目">
  1.1.1 题目
  <a class="anchor" href="#111-%e9%a2%98%e7%9b%ae">#</a>
</h4>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p><strong>示例 1：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
</code></pre></div><p><strong>示例 2：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [0,1,0,3,2,3]
输出：4
</code></pre></div><p><strong>示例 3：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [7,7,7,7,7,7,7]
输出：1
</code></pre></div><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 2500</li>
<li>-104 &lt;= nums[i] &lt;= 104</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以设计时间复杂度为 O(n2) 的解决方案吗？</li>
<li>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</li>
</ul>
<h4 id="112-解题思路">
  1.1.2 解题思路
  <a class="anchor" href="#112-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="1121-动态规划法">
  1.1.2.1 动态规划法
  <a class="anchor" href="#1121-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e6%b3%95">#</a>
</h5>
<h6 id="11211-问题分析">
  1.1.2.1.1 问题分析
  <a class="anchor" href="#11211-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<p><strong>动态规划的核心设计思想是数学归纳法。</strong></p>
<p>比如我们想证明一个数学结论，那么我们先假设这个结论在 $k &lt; n$ 时成立，然后想办法证明 $k = n$ 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 $k$ 等于任何数都成立。</p>
<p>类似的，我们在设计动态规划算法时，需要一个 $dp$ 数组，我们可以假设 $dp[0&hellip;i-1]$ 都已经被算出来了，然后需要通过这些结果算出 $dp[i]$。</p>
<p>该题目的具体解题思路如下：</p>
<ol>
<li><strong>定义 $dp$ 数组：$dp[i]$ 表示以 $nums[i]$ 这个数结尾的最长递增子序列的长度。</strong> 根据这个定义，<strong>我们的最终结果（子序列的最大长度）应该是 $dp$ 数组中的最大值</strong>。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-04_202723.png" alt="" /></p>
<p>
  <img src="./../../../media/202104/2021-04-04_202743.png" alt="" /></p>
<ol start="2">
<li>刚在这个过程中每个 $dp[i]$ 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 $dp[i]$ 呢？这就是动态规划中关键的部分了，要思考如何进行<strong>状态转移</strong>，这里就可以使用<strong>数学归纳</strong>的思想了。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-04_203956.png" alt="" /></p>
<ul>
<li>假设此时我们已经知道了 $dp[0&hellip;4]$ 的所有结果，现在需要求 $dp[5]$ 值，也就是相求以 $nums[5]$ 结尾的最长递增子序列。</li>
<li>$nums[5]=3$，既然是递增子序列，我们只要<strong>找到前面那些结尾比 3 小的子序列，然后把 3 接到最后</strong>，就可以形成一个新的递增子序列，而且这个新的子序列长度加 1。</li>
<li>当然，<strong>可能形成很多新的子序列，但是我们只要最长的，把最长子序列的长度作为 $dp[5]$ 即可</strong>。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>这段代码的逻辑可以算出 $dp[5]$，类似数学归纳法，我们可以算出 $dp[5]$，其他的就可以都算出来了。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//  遍历 nums
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="3">
<li>还有一个细节问题，$dp$ 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最少为 1。</li>
</ol>
<p>至此，这道题就解决了，时间复杂度为 $O(N^2)$，最后总结一下动态规划的设计流程：</p>
<ol>
<li><strong>首先明确 $dp$ 数组所存数据的含义。</strong> 这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</li>
<li>然后根据 $dp$ 数组的定义，运用<strong>数学归纳法</strong>的思想，假设 $dp[0&hellip;i-1]$ 都已知，想办法求出 $dp[i]$，一旦这一步完成，整个题目就解决了。但如果无法完成这一步，可能是以下原因：
<ul>
<li>$dp$ 数组的定义不够恰当，需要重新定义 $dp$ 数组的含义。</li>
<li>$dp$ 数组存储的信息不够，不足以推出下一步的答案，需要把 $dp$ 数组扩大成二维数组甚至三维数组。</li>
</ul>
</li>
<li>最后想一想问题的 $base\space case$ 是什么，以此来初始化 $dp$ 数组，以保证算法正确运行。</li>
</ol>
<h6 id="11212-参考代码">
  1.1.2.1.2 参考代码
  <a class="anchor" href="#11212-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * 300. 最长递增子序列（版本 1：动态规划）
</span><span style="color:#75715e">     * 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
</span><span style="color:#75715e">     * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param nums 整数数组
</span><span style="color:#75715e">     * @return 最长严格递增子序列的长度
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLISV1</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  定义 dp 数组，其中第 i 个元素表示以 nums[i]这个数结尾的最长递增子序列的长度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        <span style="color:#75715e">//  将数组中的元素初始化为 1
</span><span style="color:#75715e"></span>        Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">fill</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>

        <span style="color:#75715e">//  遍历 nums
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">//  找出 nums[i] 之前的元素中小于 nums[i] 的元素，将 nums[i] 接在其后面，然后把 dp[i] + 1 即可
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//  dp 数组中最大的元素即为最长递增子序列的长度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> dp<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//  返回结果
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h5 id="1122-二分查找法">
  1.1.2.2 二分查找法
  <a class="anchor" href="#1122-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e6%b3%95">#</a>
</h5>
<h6 id="11221-问题分析">
  1.1.2.2.1 问题分析
  <a class="anchor" href="#11221-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<p><strong>最长递增子序列</strong>和一种叫做<strong>Patience Game</strong>的纸牌游戏有关，甚至有一种排序方法就叫做<strong>Patience Sorting</strong>（耐心排序）。该纸牌游戏的玩法如下：</p>
<ol>
<li>首先，给我们一副扑克牌，我们想遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-04_210817.png" alt="" /></p>
<ol start="2">
<li>处理这些扑克牌要遵循以下规则：
<ol>
<li><strong>只能把点数小的牌压到点数比他大的牌上。</strong></li>
<li>如果当前牌<strong>点数较大没有可以放置的堆</strong>，则<strong>新建一个堆</strong>，把这张牌放进去。</li>
<li>如果当前牌<strong>有多个堆可供选择</strong>，则选择<strong>最左边的堆</strong>放置（保证牌堆顶的牌有序）。</li>
</ol>
</li>
<li>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 $A$ 的值最大，而不是 1）。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-04_211338.png" alt="" /></p>
<ol start="4">
<li>按照上述规则执行，可以算出最长递增子序列，<strong>牌的堆数就是最长递增子序列的长度</strong>。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-04_211739.png" alt="" /></p>
<ol start="5">
<li>我们只要把<strong>处理扑克牌的过程</strong>编程写出来即可。每次处理一张扑克牌不是要找到一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到
  <a href="/school-recruitment/">二分查找</a>了：用<strong>寻找左侧边界的二分查找法来搜索当前牌应放置的位置</strong>。</li>
</ol>
<h6 id="11222-参考代码">
  1.1.2.2.2 参考代码
  <a class="anchor" href="#11222-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * 300. 最长递增子序列（版本 2：二分数组）
</span><span style="color:#75715e">     * 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
</span><span style="color:#75715e">     * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param nums 整数数组
</span><span style="color:#75715e">     * @return 最长严格递增子序列的长度
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLISV2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  牌堆顶部的牌
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> top <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        <span style="color:#75715e">//  牌堆数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> piles <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

        <span style="color:#75715e">//  遍历 nums，将牌进行分堆
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> poker <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>

            <span style="color:#75715e">//  采用寻找左侧边界的二分查找法，寻找牌应放置的堆的位置
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> right <span style="color:#f92672">=</span> piles <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;=</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">-</span> left<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>top<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> poker<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>top<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> poker<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>top<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> poker<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>

            <span style="color:#75715e">//  没找到放牌的位置，则新建一堆
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;=</span> piles<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>piles<span style="color:#f92672">++;};</span>
            <span style="color:#75715e">//  将牌放到该堆的位置
</span><span style="color:#75715e"></span>            top<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> poker<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//  牌堆数即为最长递增子序列的长度，将其直接返回即可
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> piles<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div>1.2 <h3 id="12-最长回文子序列httpsleetcode-cncomproblemslongest-palindromic-subsequence">
  
  <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">最长回文子序列</a>
  <a class="anchor" href="#12-%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemslongest-palindromic-subsequence">#</a>
</h3>
<h4 id="121-题目">
  1.2.1 题目
  <a class="anchor" href="#121-%e9%a2%98%e7%9b%ae">#</a>
</h4>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
<strong>示例 1:</strong>
输入:</p>
<pre><code>&quot;bbbab&quot;
</code></pre><p>输出:</p>
<pre><code>4
</code></pre><p>一个可能的最长回文子序列为 &ldquo;bbbb&rdquo;。</p>
<p><strong>示例 2:</strong>
输入:</p>
<pre><code>&quot;cbbd&quot;
</code></pre><p>输出:</p>
<pre><code>2
</code></pre><p>一个可能的最长回文子序列为 &ldquo;bb&rdquo;。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 1000</li>
<li>s 只包含小写英文字母</li>
</ul>
<h4 id="122-解题思路">
  1.2.2 解题思路
  <a class="anchor" href="#122-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="1221-子序列问题处理模板">
  1.2.2.1 子序列问题处理模板
  <a class="anchor" href="#1221-%e5%ad%90%e5%ba%8f%e5%88%97%e9%97%ae%e9%a2%98%e5%a4%84%e7%90%86%e6%a8%a1%e6%9d%bf">#</a>
</h5>
<p>对于这种子序列问题，我们一般需要使用<strong>动态规划</strong>的方法来解决：</p>
<ol>
<li><strong>找状态关系（通过数学归纳获得）。</strong></li>
<li><strong>定义 dp 数组（根据状态转移方程获得）。</strong></li>
</ol>
<p>dp 数组的定义主要有两种方式，一种是定义一个<strong>一维数组</strong>，另一种是定义一个<strong>二维数组</strong>。</p>
<h6 id="12211-一维-dp-数组">
  1.2.2.1.1 一维 dp 数组
  <a class="anchor" href="#12211-%e4%b8%80%e7%bb%b4-dp-%e6%95%b0%e7%bb%84">#</a>
</h6>
<p>例如，在
  <a href="http://notebook.grayson.top/project-21/doc-266">最长递增子序列</a>中，我们就是定义了一个一维数组，其含义为：<strong>在子数组 $array[0..i]$ 中，我们要求的子序列（最长递增子序列）的长度是 $dp[i]$。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 最值<span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#f92672">...)</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h6 id="12212-二维-dp-数组">
  1.2.2.1.2 二维 dp 数组
  <a class="anchor" href="#12212-%e4%ba%8c%e7%bb%b4-dp-%e6%95%b0%e7%bb%84">#</a>
</h6>
<p>这种思路运用相对多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为<strong>只涉及一个字符串</strong>和<strong>涉及两个字符串</strong>两种情况。</p>
<ol>
<li><strong>只涉及一个字符串/数组时：</strong> 在子数组 $array[i..j]$ 中，我们要求的子序列（最长回文子序列）的长度为 $dp[i][j]$。</li>
<li><strong>涉及两个字符串/数组：在子数组 $arr1[0..i]$ 和 $arr2[0..j]$ 中，我们要求的子序列（最长公共子序列）长度为 $dp[i][j]$。</strong></li>
</ol>
<h5 id="1222-问题分析">
  1.2.2.2 问题分析
  <a class="anchor" href="#1222-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h5>
<p>
  <img src="./../../../media/202104/2021-04-08_163717.png" alt="" /></p>
<p>dp 函数的定义为：<strong>在子串 $s[i..j]$ 中，最长回文子序列的长度为 $dp[i][j]$</strong>。</p>
<p>如果我们想求 $dp[i][j]$，假设我们已经知道了子问题 $dp[i+1][j-1]$ 的结果，即 $s[i+1..j-1]$ 中最长回文子序列的长度，那么我们就可以想办法算出 $dp[i][j]$ 的值，即 $s[i..j]$ 中最长回文子序列的长度，这主要取决于 $s[i]$ 和 $s[j]$ 的字符。</p>
<ol>
<li><strong>如果 $s[i]==s[j]$：</strong> 则他俩加上 $s[i+1..j-1]$ 中的最长回文子序列就是 $s[i..j]$ 的最长回文子序列。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-08_164936.png" alt="" /></p>
<ol start="2">
<li><strong>如果 $s[i]!=s[j]$：</strong> 说明他俩不可能同时出现在 $s[i..j]$ 的最长回文子序列中，那么把他俩分别加入 $s[i+1..j-1]$ 中，看看哪个子串产生的回文子序列更长即可。</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-08_165224.png" alt="" /></p>
<p>代码模板如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> s[j])
    <span style="color:#75715e">// 它俩⼀定在最⻓回⽂⼦序列中
</span><span style="color:#75715e"></span>    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">else</span>
    <span style="color:#75715e">//  s[i+1..j] 和 s[i..j-1] 谁的回⽂⼦序列更⻓？
</span><span style="color:#75715e"></span>    dp[i][j] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</code></pre></div><p>至此，状态转移方程就写出来了，根据<strong>dp 数组</strong>的定义，<strong>我们要求的就是 $dp[0][n-1]$，也就是整个 s 的最长回文子序列的长度</strong>。</p>
<h5 id="1223-参考代码">
  1.2.2.3 参考代码
  <a class="anchor" href="#1223-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h5>
<ol>
<li>首先明确一下 $base \space case$，如果只有一个字符，显然最长回文子序列的长度为 1，即 $dp[i][j]=1 \space (i==j)$。</li>
<li>因为 $i$ 肯定小于 $j$，所以对于那些 $i&gt;j$ 的位置，根本不存在什么子序列，应该初始化为 0。</li>
<li>根据我们刚才的状态转移方程，想求 $dp[i][j]$ 需要知道 $dp[i+1][j-1]$，$dp[i+1][j]$，$dp[i][i-1]$ 这三个位置，将其填入 dp 数组后是这样：</li>
</ol>
<p>
  <img src="./../../../media/202104/2021-04-08_173451.png" alt="" /></p>
<p><strong>为了保证每次计算 $dp[i][j]$，左、下、右方向的位置已经被计算出来了，只能斜着遍历或者反着遍历。</strong></p>
<p>
  <img src="./../../../media/202104/2021-04-09_152953.png" alt="" /></p>
<p>我选择<strong>反着遍历</strong>，参考代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.grayson.top<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> java.util.Arrays<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * @author peng.wei
</span><span style="color:#75715e"> * @version 1.0
</span><span style="color:#75715e"> * @date 2021/4/8 14:50
</span><span style="color:#75715e"> * @Description 最长回文子序列
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">L516</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 516. 最长回文子序列
</span><span style="color:#75715e">     * 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
</span><span style="color:#75715e">     * @param s 字符串
</span><span style="color:#75715e">     * @return  最长回文子序列的长度
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">longestPalindromeSubseq</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//  dp table: s[i...j] 子串的回文子序列的最大长度
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//  最终的结果为 dp[0][n - 1]
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">][</span>n<span style="color:#f92672">];</span>

        <span style="color:#75715e">//  base case: 单个字符的回文子序列的最大长度为 1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">//  两个字符相等，将 dp[i + 1][j - 1] + 1
</span><span style="color:#75715e"></span>                    dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">//  两个字符不相等，则 dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])
</span><span style="color:#75715e"></span>                    dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// 返回最终的结果 dp[0][n - 1]
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> dp<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div>1.3 <h3 id="13-最长公共子序列httpsleetcode-cncomproblemslongest-common-subsequence">
  
  <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a>
  <a class="anchor" href="#13-%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemslongest-common-subsequence">#</a>
</h3>
<h4 id="131-解题思路">
  1.3.1 解题思路
  <a class="anchor" href="#131-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="1311-动态规划">
  1.3.1.1 动态规划
  <a class="anchor" href="#1311-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="13111-问题分析">
  1.3.1.1.1 问题分析
  <a class="anchor" href="#13111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>类似的解法还可用于
  <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a>，不过这里和求最长重复子数组不同的一点是子序列中的元素不一定在原数组中连续，因此，在 $dp$ 数组的转换上稍微会有一定区别，具体如下：</li>
</ol>
<ul>
<li><strong>如果 $nums1[i] = nums2[j]$</strong>，<strong>则 $dp[i][j] = dp[i + 1][j + 1] + 1$</strong>。</li>
<li><strong>否则</strong>，$dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])$。</li>
</ul>
<p>
  <img src="./../../../media/202107/2021-07-17_205353.png" alt="" /></p>
<h6 id="13112-参考代码">
  1.3.1.1.2 参考代码
  <a class="anchor" href="#13112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 1143. 最长公共子序列
</span><span style="color:#75715e"> * @param text1 数组 1
</span><span style="color:#75715e"> * @param text2 数组 2
</span><span style="color:#75715e"> * @return  两个数组中公共的、长度最长的子数组的长度
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">longestCommonSubsequence</span><span style="color:#f92672">(</span>String text1<span style="color:#f92672">,</span> String text2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n1 <span style="color:#f92672">=</span> text1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> n2 <span style="color:#f92672">=</span> text2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i][j] 表示 nums1[i:] 和 nums2[j:] 的最长公共子序列的长度，则 dp 数组中最大的元素即为 nums1 和 nums2 的最长公共子序列的长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n1 <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>n2 <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>

    <span style="color:#75715e">//  分别遍历 nums1 和 nums2，计算最长公共子序列的长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n1 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n2 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;=</span>0<span style="color:#f92672">;</span> j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//  如果 nums1[i] = nums2[j]，则 dp[i][j] = dp[i + 1][j + 1]，否则，dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>text1<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> text2<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]);</span>
            <span style="color:#f92672">}</span>
            res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="2-数组类问题">
  2 数组类问题
  <a class="anchor" href="#2-%e6%95%b0%e7%bb%84%e7%b1%bb%e9%97%ae%e9%a2%98">#</a>
</h2>
2.1 <h3 id="21-最大子序和httpsleetcode-cncomproblemsmaximum-subarray">
  
  <a href="https://leetcode-cn.com/problems/maximum-subarray">最大子序和</a>
  <a class="anchor" href="#21-%e6%9c%80%e5%a4%a7%e5%ad%90%e5%ba%8f%e5%92%8chttpsleetcode-cncomproblemsmaximum-subarray">#</a>
</h3>
<h4 id="211-题目">
  2.1.1 题目
  <a class="anchor" href="#211-%e9%a2%98%e7%9b%ae">#</a>
</h4>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
</code></pre></div><p><strong>示例 2：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [1]
输出：1
</code></pre></div><p><strong>示例 3：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [0]
输出：0
</code></pre></div><p><strong>示例 4：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [-1]
输出：-1
</code></pre></div><p><strong>示例 5：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：nums = [-100000]
输出：-100000
</code></pre></div><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 104</li>
<li>-105 &lt;= nums[i] &lt;= 105</li>
</ul>
<p><strong>进阶：</strong> 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</p>
<h4 id="212-解题思路">
  2.1.2 解题思路
  <a class="anchor" href="#212-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2121-暴力法">
  2.1.2.1 暴力法
  <a class="anchor" href="#2121-%e6%9a%b4%e5%8a%9b%e6%b3%95">#</a>
</h5>
<h6 id="21211-问题分析">
  2.1.2.1.1 问题分析
  <a class="anchor" href="#21211-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>依次遍历单个元素、两个元素、&hellip;、N 个元素，然后从中选取最大子序和。</li>
</ol>
<p>
  <img src="./../../../media/202105/2021-05-22_193233.png" alt="" /></p>
<h6 id="21212-参考代码">
  2.1.2.1.2 参考代码
  <a class="anchor" href="#21212-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 53. 最大子序和（版本 1：暴力法）
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param nums 数组
</span><span style="color:#75715e"> * @return 最大子序和
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubArrayV1</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> len<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> i<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                sum <span style="color:#f92672">+=</span> nums<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> k<span style="color:#f92672">];</span>
            <span style="color:#f92672">}</span>
            max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>sum<span style="color:#f92672">,</span> max<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="2122-动态规划">
  2.1.2.2 动态规划
  <a class="anchor" href="#2122-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="21221-问题分析">
  2.1.2.2.1 问题分析
  <a class="anchor" href="#21221-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>定义 $dp$ 数组：
<ol>
<li>$dp[i]$ 表示 $nums$ 中以 $nums[i]$ 结尾的最大子序和。</li>
<li>$dp[i]$ 中最大的元素即为 $nums$ 的最大子序和。</li>
<li>$dp[0] = nums[0]$。</li>
</ol>
</li>
<li>列出状态转移方程：
$$
dp[i] = max(dp[i-1] + nums[i], nums[i])
$$</li>
</ol>
<p>
  <img src="./../../../media/202105/2021-05-22_194007.png" alt="" /></p>
<h6 id="21222-参考代码">
  2.1.2.2.2 参考代码
  <a class="anchor" href="#21222-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 53. 最大子序和（版本 2：动态规划）
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param nums 数组
</span><span style="color:#75715e"> * @return 最大子序和
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubArrayV2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> max<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i] 表示以 nums[i] 结尾的 nums[0...i] 序列中最大子序和
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  则最终 dp 数组中的最大值便是整个数组的最大子序和
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>len<span style="color:#f92672">];</span>
    dp<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    max <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> len<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">],</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="2123-贪心法">
  2.1.2.3 贪心法
  <a class="anchor" href="#2123-%e8%b4%aa%e5%bf%83%e6%b3%95">#</a>
</h5>
<h6 id="21231-问题解析">
  2.1.2.3.1 问题解析
  <a class="anchor" href="#21231-%e9%97%ae%e9%a2%98%e8%a7%a3%e6%9e%90">#</a>
</h6>
<ol>
<li>如果 sum 小于 0，说明他对于下一个 sum 起副作用，所以将 sum 重置为当前元素。</li>
<li>否则的话，直接将当前元素累加到 sum 上。</li>
</ol>
<p>
  <img src="./../../../media/202105/2021-05-22_194238.png" alt="" /></p>
<h6 id="21232-参考代码">
  2.1.2.3.2 参考代码
  <a class="anchor" href="#21232-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 53. 最大子序和（版本 3：贪心算法）
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param nums 数组
</span><span style="color:#75715e"> * @return 最大子序和
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubArrayV3</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">],</span> max <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> len<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sum <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  如果 sum 小于 0，说明他对于下一个 sum 起副作用，所以将 sum 重置为当前元素
</span><span style="color:#75715e"></span>            sum <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//  否则的话，直接将当前元素累加到 sum 上
</span><span style="color:#75715e"></span>            sum <span style="color:#f92672">+=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span> sum<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.2 <h3 id="22-打家劫舍httpsleetcode-cncomproblemshouse-robber">
  
  <a href="https://leetcode-cn.com/problems/house-robber">打家劫舍</a>
  <a class="anchor" href="#22-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8dhttpsleetcode-cncomproblemshouse-robber">#</a>
</h3>
<h4 id="221-解题思路">
  2.2.1 解题思路
  <a class="anchor" href="#221-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2211-动态规划">
  2.2.1.1 动态规划
  <a class="anchor" href="#2211-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="22111-问题分析">
  2.2.1.1.1 问题分析
  <a class="anchor" href="#22111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>该题目中 $dp$ 数组的含义为 $dp[i]$ 表示以从第 $i$ 家开始偷窃，在不触动警报装置的情况下，一夜之内能够偷窃得到的最高金额，且：</p>
<p>$$
dp[i] = max(dp[i + 1], dp[i + 2] + nums[i])
$$</p>
</li>
</ol>
<h6 id="22112-参考代码">
  2.2.1.1.2 参考代码
  <a class="anchor" href="#22112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rob</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>

    <span style="color:#75715e">//  base case
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">&gt;=</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">];}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">&gt;=</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">],</span> nums<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 2<span style="color:#f92672">]);}</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> 3<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> dp<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.3 <h3 id="23-乘积最大子数组httpsleetcode-cncomproblemsmaximum-product-subarray">
  
  <a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a>
  <a class="anchor" href="#23-%e4%b9%98%e7%a7%af%e6%9c%80%e5%a4%a7%e5%ad%90%e6%95%b0%e7%bb%84httpsleetcode-cncomproblemsmaximum-product-subarray">#</a>
</h3>
<h4 id="231-解题思路">
  2.3.1 解题思路
  <a class="anchor" href="#231-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2311-动态规划">
  2.3.1.1 动态规划
  <a class="anchor" href="#2311-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="23111-问题分析">
  2.3.1.1.1 问题分析
  <a class="anchor" href="#23111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>对于这种<strong>含有不定状态的最值问题</strong>，一般可以通过<strong>设置多个 $dp$ 数组来求解</strong>，<strong>分别用不同的 $dp$ 数组来表示不同的状态</strong>。</li>
<li>在本题中，假如我们直接<strong>使用一个 $dp$ 数组</strong>，其中 $dp[i]$<strong>表示以第 $i$ 个元素结尾的最大连续子数组的乘积</strong>，此时<strong>当前位置的最优解未必是由前一个位置的最优解转移得到</strong>。</li>
<li>因此，我们可以<strong>根据正负性进行讨论</strong>：
<ol>
<li>如果<strong>当前位置是一个负数</strong>的话，那么<strong>我们希望以他前一个位置结尾的某个段的积也是个负数</strong>，<strong>这样就可以负负得正</strong>，<strong>并且我们希望这个积尽可能负得多</strong>，即<strong>尽可能小</strong>。</li>
<li>如果<strong>当前位置是一个正数的话</strong>，那么<strong>我们希望以他前一个位置结尾的某个段的积也是个正数</strong>，<strong>并且我们希望这个积尽可能大</strong>。</li>
</ol>
</li>
<li>因此我们需要<strong>维护两个 $dp$ 数组</strong>，**分别是 $dp_{max}$ 和**$dp_{min}$：
<ol>
<li>
<p>$dp_{max}$ 表示**以第 $i$ 个元素结尾的最大连续子数组的乘积**，且：</p>
<p>$$
dp_{max} = max(dp_{max}[i - 1] \times nums[i], dp_{min}[i - 1] \times nums[i], nums[i])
$$</p>
</li>
<li>
<p>$dp_{min}$ 表示**以第 $i$ 个元素结尾的最小连续子数组的乘积**，且：</p>
<p>$$
dp_{min} = min(dp_{max}[i - 1] \times nums[i], dp_{min}[i - 1] \times nums[i], nums[i])
$$</p>
</li>
</ol>
</li>
</ol>
<h6 id="23112-参考代码">
  2.3.1.1.2 参考代码
  <a class="anchor" href="#23112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 152. 乘积最大子数组（版本 1：动态规划（优化前））
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param nums 数组
</span><span style="color:#75715e"> * @return 数组中乘积最大的连续子数组的乘积
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxProductV1</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dp 数组，dpMax[i] 表示以第 i 个元素结尾的最大连续子数组的乘积
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dpMax <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>
    <span style="color:#75715e">//  dp 数组，dpMin[i] 表示以第 i 个元素结尾的最小连续子数组的乘积
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dpMin <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> res<span style="color:#f92672">;</span>

    dpMax<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    dpMin<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    res <span style="color:#f92672">=</span> dpMax<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> item <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>

        <span style="color:#75715e">//  dpMax[i] = max(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])
</span><span style="color:#75715e"></span>        dpMax<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>
                dpMax<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>
                        dpMin<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                        item
                <span style="color:#f92672">)</span>
        <span style="color:#f92672">);</span>

        <span style="color:#75715e">//  dpMin[i] = min(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])
</span><span style="color:#75715e"></span>        dpMin<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>
                dpMax<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>
                        dpMin<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                        item
                <span style="color:#f92672">)</span>
        <span style="color:#f92672">);</span>

        <span style="color:#75715e">//  去 dpMax 中的最大值
</span><span style="color:#75715e"></span>        res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dpMax<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回最后结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>由于<strong>第 $i$ 个状态只和第 $i - 1$ 个状态相关</strong>，根据<strong>滚动数组</strong>思想，我们可以<strong>只用两个变量来维护 $i - 1$ 时刻的状态</strong>，<strong>一个维护 $dpMax$</strong>，<strong>一个维护 $dpMin$</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 152. 乘积最大子数组（版本 2：动态规划（优化后））
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param nums 数组
</span><span style="color:#75715e"> * @return 数组中乘积最大的连续子数组的乘积
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxProductV2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dpMax 表示以第 i 个元素结尾的最大连续子数组的乘积
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> dpMax <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#75715e">//  dpMin 表示以第 i 个元素结尾的最小连续子数组的乘积
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> dpMin <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> res<span style="color:#f92672">;</span>

    res <span style="color:#f92672">=</span> dpMax<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> item <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">int</span> dpMaxTemp <span style="color:#f92672">=</span> dpMax<span style="color:#f92672">,</span> dpMinYemp <span style="color:#f92672">=</span> dpMin<span style="color:#f92672">;</span>

        <span style="color:#75715e">//  dpMax = max(dpMaxTemp * nums[i], dpMinYemp * nums[i], nums[i])
</span><span style="color:#75715e"></span>        dpMax <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>
                dpMaxTemp <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>
                        dpMinYemp <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                        item
                <span style="color:#f92672">)</span>
        <span style="color:#f92672">);</span>

        <span style="color:#75715e">//  dpMin = min(dpMaxTemp * nums[i], dpMinYemp * nums[i], nums[i])
</span><span style="color:#75715e"></span>        dpMin <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>
                dpMaxTemp <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>
                        dpMinYemp <span style="color:#f92672">*</span> item<span style="color:#f92672">,</span>
                        item
                <span style="color:#f92672">)</span>
        <span style="color:#f92672">);</span>

        <span style="color:#75715e">//  去 dpMax 中的最大值
</span><span style="color:#75715e"></span>        res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dpMax<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回最后结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.4 <h3 id="24-三角形最小路径和httpsleetcode-cncomproblemstriangle">
  
  <a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a>
  <a class="anchor" href="#24-%e4%b8%89%e8%a7%92%e5%bd%a2%e6%9c%80%e5%b0%8f%e8%b7%af%e5%be%84%e5%92%8chttpsleetcode-cncomproblemstriangle">#</a>
</h3>
<h4 id="241-解题思路">
  2.4.1 解题思路
  <a class="anchor" href="#241-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2411-动态规划">
  2.4.1.1 动态规划
  <a class="anchor" href="#2411-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="24111-问题分析">
  2.4.1.1.1 问题分析
  <a class="anchor" href="#24111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>该题目中 $dp$ 数组的含义为 $dp[i][j]$<strong>表示从顶点到 $triangle.get(i).get(j)$ 的最小路径和</strong>，且：</p>
<p>$$
dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j)
$$</p>
</li>
</ol>
<h6 id="24112-参考代码">
  2.4.1.1.2 参考代码
  <a class="anchor" href="#24112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 120. 三角形最小路径和
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param triangle 三角形顶点列表
</span><span style="color:#75715e"> * @return 三角形自顶向下的最小路径和
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minimumTotal</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> triangle<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i][j] 表示从顶点到 triangle.get(i).get(j) 的最小路径和
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">][</span>n<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> item <span style="color:#f92672">=</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>j<span style="color:#f92672">);</span>

            <span style="color:#75715e">//  转移关系为：dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j)
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//  需要确保数组下标不要越界，即：i - 1 &gt;= 0 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; j &lt; triangle.get(i - 1).size()
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">-</span> 1 <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">-</span> 1 <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">])</span> <span style="color:#f92672">+</span> item<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> item<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                    dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> item<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> item<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  三角形最后一行中的最小路径和即为整个三角形自顶向下的最小路径和
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> triangle<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dp<span style="color:#f92672">[</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.5 <h3 id="25-解码方法httpsleetcode-cncomproblemsdecode-ways">
  
  <a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>
  <a class="anchor" href="#25-%e8%a7%a3%e7%a0%81%e6%96%b9%e6%b3%95httpsleetcode-cncomproblemsdecode-ways">#</a>
</h3>
<h4 id="251-解题思路">
  2.5.1 解题思路
  <a class="anchor" href="#251-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2511-动态规划">
  2.5.1.1 动态规划
  <a class="anchor" href="#2511-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="25111-问题分析">
  2.5.1.1.1 问题分析
  <a class="anchor" href="#25111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>动态规划中：</p>
<ol>
<li>对于<strong>一维 $dp$ 数组</strong>一般<strong>有两种思路</strong>，<strong>一种是以 $nums[i]$ 开头</strong>，<strong>另一种是以 $nums[i]$ 结尾</strong>，我们在定义 $dp$ 数组时可以<strong>从这两个方面去考虑</strong>即可。</li>
<li>对于<strong>二维 $dp$ 数组</strong>一般<strong>可以从中间进行截取</strong>，例如
  <a href="https://notebook.grayson.top/project-21/doc-273">1.1.7 最长回文子序列</a>中 $dp$ 数组的定义为 $dp[i][j]$ 表示 $s[i&hellip;j]$ 中包含的最长回文子序列的长度。</li>
</ol>
</li>
<li>
<p>该题目中 $dp$ 数组的含义为 $dp[i]$ 表示以 $s.charAt(i)$ 开头的字符串的解码方法的总数，且：</p>
<p>$$
dp[i] = dp[i + 1] + dp[i + 2]
$$</p>
</li>
</ol>
<h6 id="25112-参考代码">
  2.5.1.1.2 参考代码
  <a class="anchor" href="#25112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 91. 解码方法
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param s 消息字符串
</span><span style="color:#75715e"> * @return 消息字符串解码方法的总数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numDecodings</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i] 表示以 s.charAt(i) 开头的消息字符串解码方法的总数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  如果当前字符为 0，那么以该字符开头的字符串的解码方法总数为 0
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">;}</span>
        <span style="color:#75715e">//  如果当前字符不为 0，并且当前字符位于最后一个位置，那么以该字符开头的字符串的解码方法总数为 1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> m <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;}</span>
        <span style="color:#75715e">//  当前字符不为 0，并且当前字符位于倒数第二个位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> m <span style="color:#f92672">-</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//  如果当前字符及其后两位所组成的数字大于 26，则当前字符及其后两位字符组成的字符串不能被解码，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> 2<span style="color:#f92672">))</span> <span style="color:#f92672">&gt;</span> 26<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">];}</span>
            <span style="color:#75715e">//  如果当前字符及其后两位所组成的数字不大于 26，则当前字符及其后两位字符组成的字符串可以被解码，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数加 1
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//  当前字符不为 0，并且当前字符不位于倒数第二个位置
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//  如果当前字符及其后两位所组成的数字大于 26，则当前字符及其后两位字符组成的字符串不能被解码，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> 2<span style="color:#f92672">))</span> <span style="color:#f92672">&gt;</span> 26<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">];}</span>
        <span style="color:#75715e">//  如果当前字符及其后两位所组成的数字不大于 26，则当前字符及其后两位字符组成的字符串可以被解码，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//  以该字符开头的字符串的解码方法总数等于以下一个字符开头的字符串的解码方法总数及以下面第二个字符开头的字符串的解码方法总数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 2<span style="color:#f92672">];}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回最后的结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dp<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.6 <h3 id="26-打家劫舍-iihttpsleetcode-cncomproblemshouse-robber-ii">
  
  <a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>
  <a class="anchor" href="#26-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d-iihttpsleetcode-cncomproblemshouse-robber-ii">#</a>
</h3>
<h4 id="261-解题思路">
  2.6.1 解题思路
  <a class="anchor" href="#261-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2611-动态规划">
  2.6.1.1 动态规划
  <a class="anchor" href="#2611-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="26111-问题分析">
  2.6.1.1.1 问题分析
  <a class="anchor" href="#26111-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>对于这种<strong>圆环型</strong>的问题，我们可以<strong>把他拆分成两部分</strong>，并对其<strong>分别去求结果</strong>，然后再<strong>将两部分的结果取最值</strong>即可。</p>
</li>
<li>
<p>该题目中 $dp$ 数组的含义为 $dp[i]$ 表示第 $i$ 户及之后所能偷到的最大金额，且：</p>
<p>$$
dp[i] = max(dp[i + 1], dp[i + 2] + nums[i]);
$$</p>
</li>
</ol>
<h6 id="26112-参考代码">
  2.6.1.1.2 参考代码
  <a class="anchor" href="#26112-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 213. 打家劫舍 II
</span><span style="color:#75715e"> * @param nums  每个房屋存放金额的非负整数数组
</span><span style="color:#75715e"> * @return  在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rob</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">//  将整个数组拆分成两部分，分别为 nums[0, nums.length - 2] 和 nums[1, nums.length - 1]，然后对这两部分分别求能够偷窃到的最大金额，并取二者的最大值即可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> m <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">?</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>subRob<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> m <span style="color:#f92672">-</span> 1<span style="color:#f92672">),</span> subRob<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> m<span style="color:#f92672">))</span> <span style="color:#f92672">:</span> nums<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
</span><span style="color:#75715e"> * @param nums  每个房屋存放金额的非负整数数组
</span><span style="color:#75715e"> * @param start 起始位置
</span><span style="color:#75715e"> * @param end   结束位置
</span><span style="color:#75715e"> * @return  在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">subRob</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> start<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> end<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i] 表示从第 i 户及后面住户中所能偷窃到的最高金额
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>

    <span style="color:#75715e">//   base case
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>end <span style="color:#f92672">&gt;=</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        dp<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>end <span style="color:#f92672">&gt;=</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> nums<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 1<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            dp<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 2<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            dp<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>end <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> 3<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> start<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//  第 i 户及之后所能偷到的最大金额 等于 第 i 户及之后所能偷到的最大金额 与 第 i + 2 户所能偷到的最大金额和第 i 户金额之和 的最大值
</span><span style="color:#75715e"></span>        dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">],</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> dp<span style="color:#f92672">[</span>start<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div>2.7 <h3 id="27-最长重复子数组httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray">
  
  <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray">最长重复子数组</a>
  <a class="anchor" href="#27-%e6%9c%80%e9%95%bf%e9%87%8d%e5%a4%8d%e5%ad%90%e6%95%b0%e7%bb%84httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray">#</a>
</h3>
<h4 id="271-题目">
  2.7.1 题目
  <a class="anchor" href="#271-%e9%a2%98%e7%9b%ae">#</a>
</h4>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p><strong>示例：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
</code></pre></div><p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ul>
<h4 id="272-解题思路">
  2.7.2 解题思路
  <a class="anchor" href="#272-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af">#</a>
</h4>
<h5 id="2721-暴力解法">
  2.7.2.1 暴力解法
  <a class="anchor" href="#2721-%e6%9a%b4%e5%8a%9b%e8%a7%a3%e6%b3%95">#</a>
</h5>
<h6 id="27211-问题分析">
  2.7.2.1.1 问题分析
  <a class="anchor" href="#27211-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>首先将 $nums2$ 中的元素对应的下标保存在 $map$ 中，这样便于查找 $nums1$ 中的元素是否在 $nums2$ 中出现。</li>
<li>然后遍历 $nums1$，假设当前遍历的元素为 $item$：
<ol>
<li>如果 $item$ 没有在 $nums2$ 中出现，则直接返回。</li>
<li>如果 $item$ 在 $nums2$ 中出现，则以 $item$ 为起点，<strong>同步遍历 $nums1$ 和 $nums2$ 的后续元素</strong>，<strong>直到两个数组中对应元素不相等</strong>，<strong>或达到任意数组的边界</strong>，<strong>计算两个数组相应部分的的重复子数组的大小</strong>，并<strong>对最终的结果进行更新</strong>。</li>
</ol>
</li>
<li>最后返回最终结果即可。</li>
</ol>
<h6 id="27212-参考代码">
  2.7.2.1.2 参考代码
  <a class="anchor" href="#27212-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 718. 最长重复子数组（版本 1：暴力解法）
</span><span style="color:#75715e"> * @param nums1 数组 1
</span><span style="color:#75715e"> * @param nums2 数组 2
</span><span style="color:#75715e"> * @return  两个数组中公共的、长度最长的子数组的长度
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findLengthV1</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">int</span> n1 <span style="color:#f92672">=</span> nums1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> n2 <span style="color:#f92672">=</span> nums2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> maxLength <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#75715e">//  将 nums2 中的元素对应的下标保存在 map 中，这样便于查找 nums1 中的元素是否在 nums2 中出现
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n2<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> item <span style="color:#f92672">=</span> nums2<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>item<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;</span> mapTemp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
            mapTemp<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>item<span style="color:#f92672">,</span> mapTemp<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;</span> mapTemp <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>item<span style="color:#f92672">);</span>
            mapTemp<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>item<span style="color:#f92672">,</span> mapTemp<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  遍历 nums1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n1<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> item <span style="color:#f92672">=</span> nums1<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#75715e">//  item 没有在 nums2 中出现，直接返回
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>item<span style="color:#f92672">))</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">continue</span><span style="color:#f92672">;}</span>
        <span style="color:#75715e">//  item 在 nums2 中出现，获取其在 nums2 中对应的下标
</span><span style="color:#75715e"></span>        Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;</span> mapTemp <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>item<span style="color:#f92672">);</span>
        <span style="color:#75715e">//  依次以 item 在 nums2 中的下标的下一个位置为起点，计算两个数组的重复子数组的大小
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;</span> entry<span style="color:#f92672">:</span> mapTemp<span style="color:#f92672">.</span><span style="color:#a6e22e">entrySet</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> tempLength <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> entry<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> key <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> n2<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> tempLength <span style="color:#f92672">&gt;=</span> n1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">break</span><span style="color:#f92672">;}</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums1<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> tempLength<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> nums2<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">break</span><span style="color:#f92672">;}</span>
                tempLength<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
            maxLength <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>maxLength<span style="color:#f92672">,</span> tempLength<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> maxLength<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="2722-动态规划">
  2.7.2.2 动态规划
  <a class="anchor" href="#2722-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h5>
<h6 id="27221-问题分析">
  2.7.2.2.1 问题分析
  <a class="anchor" href="#27221-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>对于求<strong>最值</strong>的题目，都可以思考一下看是否可以用<strong>动态规划</strong>来求解，而<strong>动态规划的核心就是定义 $dp$ 数组</strong>，<strong>寻找状态转移方程</strong>。</p>
</li>
<li>
<p>$dp$<strong>数组的定义有一维和二维数组两种</strong>，这个<strong>需要根据具体的题目来具体分析</strong>。</p>
</li>
<li>
<p>本题中 $dp$ 数组可以定义为 $dp[i][j]$，<strong>表示 $nums1[i]$ 和 $nums2[j]$ 的最长公共前缀的长度</strong>，这样 $dp$<strong>数组中最大的元素即为 $nums1$ 和 $nums2$ 的最长重复子数组的长度</strong>。</p>
</li>
<li>
<p>然后分别遍历 $nums1$ 和 $nums2$：</p>
<ol>
<li><strong>如果 $nums1[i] = nums2[j]$</strong>，<strong>则 $dp[i][j] = dp[i + 1][j + 1] + 1$</strong>。</li>
<li><strong>否则</strong>，$dp[i][j] = 0$。</li>
</ol>
<p>
  <img src="./../../../media/202107/2021-07-16_212026.png" alt="" /></p>
</li>
</ol>
<h6 id="27222-参考代码">
  2.7.2.2.2 参考代码
  <a class="anchor" href="#27222-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 718. 最长重复子数组（版本 2：动态规划）
</span><span style="color:#75715e"> * @param nums1 数组 1
</span><span style="color:#75715e"> * @param nums2 数组 2
</span><span style="color:#75715e"> * @return  两个数组中公共的、长度最长的子数组的长度
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findLengthV2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n1 <span style="color:#f92672">=</span> nums1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> n2 <span style="color:#f92672">=</span> nums2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  dp 数组，其中 dp[i][j] 表示 nums1[i:] 和 nums2[j:] 的最长公共前缀的长度，则 dp 数组中最大的元素即为 nums1 和 nums2 的最长重复子数组的长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n1 <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>n2 <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>

    <span style="color:#75715e">//  分别遍历 nums1 和 nums2，计算最长重复子数组的长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n1 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n2 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;=</span>0<span style="color:#f92672">;</span> j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//  如果 nums1[i] = nums2[j]，则 dp[i][j] = dp[i + 1][j + 1]，否则，dp[i][j] = 0
</span><span style="color:#75715e"></span>            dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>nums1<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> nums2<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">?</span> dp<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1 <span style="color:#f92672">:</span> 0<span style="color:#f92672">);</span>
            res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  返回结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h5 id="2723-滑动窗口">
  2.7.2.3 滑动窗口
  <a class="anchor" href="#2723-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h5>
<h6 id="27231-问题分析">
  2.7.2.3.1 问题分析
  <a class="anchor" href="#27231-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h6>
<ol>
<li>
<p>对于<strong>两个数组的遍历</strong>，可以<strong>通过滑动窗口的方法来减少遍历的次数</strong>，因为<strong>每次比较的只是滑动窗口内部相同区域的元素</strong>，<strong>相比于暴力解法而言</strong>，<strong>可以显著减少遍历的次数</strong>。</p>
</li>
<li>
<p>本题目中可以先<strong>把 $nums1$ 放在上面</strong>，$nums2$<strong>放在下边</strong>，然后<strong>将 $nums1$ 的第一个元素和 $nums2$ 的最后一个元素对齐</strong>，然后<strong>将 $nums2$ 从做往右滑动</strong>，<strong>直到 $nums1$ 的第一个元素和 $nums2$ 的第一个元素对齐</strong>，且<strong>每滑动一次</strong>，<strong>都对两个数组滑块内部相同区域的元素进行比较</strong>。</p>
</li>
<li>
<p>然后<strong>把 $nums2$ 放在上面</strong>，$nums1$<strong>放在下面</strong>，并且<strong>把 $nums2$ 的第一个元素和 $nums1$ 的第一个元素对齐</strong>，然后<strong>把 $nums1$ 从右往左滑动</strong>，<strong>直到 $nums2$ 的第一个元素和 $nums1$ 的最后一个元素对齐</strong>，且<strong>每滑动一次</strong>，<strong>都对两个数组滑块内部相同区域的元素进行比较</strong>。</p>
</li>
<li>
<p>其实<strong>第三步可以合到第二步里面</strong>，即<strong>在第二步中一直把 $nums2$ 滑动到第一个元素和 $nums1$ 的第一个元素对齐</strong>，但这样<strong>不太好实现</strong>，因此<strong>后面一步拆分成等价的第四步来实现</strong>。</p>
<p>
  <img src="./../../../media/202107/718-%e6%9c%80%e9%95%bf%e9%87%8d%e5%a4%8d%e5%ad%90%e6%95%b0%e7%bb%84%ef%bc%88%e8%a7%a3%e6%b3%95%e4%b8%89%ef%bc%9a%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%ef%bc%89_1626441966.gif" alt="" /></p>
</li>
</ol>
<h6 id="27232-参考代码">
  2.7.2.3.2 参考代码
  <a class="anchor" href="#27232-%e5%8f%82%e8%80%83%e4%bb%a3%e7%a0%81">#</a>
</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 718. 最长重复子数组（版本 3：滑动窗口）
</span><span style="color:#75715e"> * @param nums1 数组 1
</span><span style="color:#75715e"> * @param nums2 数组 2
</span><span style="color:#75715e"> * @return  两个数组中公共的、长度最长的子数组的长度
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findLengthV3</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n1 <span style="color:#f92672">=</span> nums1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> n2 <span style="color:#f92672">=</span> nums2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#75715e">//  nums1 的第一个元素和 nums2 的最后一个元素对齐，然后将 num2 从左往右滑动，直到 nums2 的第一个元素和 nums1 的第一个元素对齐
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n2 <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> minLen <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>n1<span style="color:#f92672">,</span> n2 <span style="color:#f92672">-</span> i<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> tempRes <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#75715e">//  遍历 nums1 和 nums2 交叉的部分，并计算这一部分的最长重复子数组的长度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> minLen<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tempRes <span style="color:#f92672">!=</span> 0 <span style="color:#f92672">&amp;&amp;</span> nums1<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> nums2<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> tempRes<span style="color:#f92672">);</span>
                tempRes <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums1<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> nums2<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                tempRes<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> tempRes<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//  nums2 的第一个元素和 nums1 的第一个元素对齐，然后将 num1 从右往左滑动，直到 nums2 的第一个元素和 nums1 的最后一个元素对齐
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n1<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> minLen <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>n1 <span style="color:#f92672">-</span> i<span style="color:#f92672">,</span> n2<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> tempRes <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#75715e">//  遍历 nums1 和 nums2 交叉的部分，并计算这一部分的最长重复子数组的长度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> minLen<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tempRes <span style="color:#f92672">!=</span> 0 <span style="color:#f92672">&amp;&amp;</span> nums1<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> j<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> nums2<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> tempRes<span style="color:#f92672">);</span>
                tempRes <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nums1<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> nums2<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                tempRes<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        res <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>res<span style="color:#f92672">,</span> tempRes<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="参考文献">
  参考文献
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#</a>
</h2>
<ol>
<li>
  <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">300. 最长递增子序列</a>。</li>
<li>
  <a href="https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-1/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie">动态规划设计：最长递增子序列</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">516. 最长回文子序列</a>。</li>
<li>
  <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zi-xu-lie-lei-xing-wen-ti/zi-xu-lie-wen-ti-mo-ban">动态规划之子序列问题解题模板</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-subarray">53. 最大子序和</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/house-robber">198. 打家劫舍</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f">最大子序和 c++ 实现四种解法 暴力法、动态规划、贪心法和分治法 图示讲解</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-product-subarray">152. 乘积最大子数组</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution">乘积最大子数组</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/triangle">120. 三角形最小路径和</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/decode-ways">91. 解码方法</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/house-robber-ii">213. 打家劫舍 II</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray">718. 最长重复子数组</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/longest-common-subsequence">1143. 最长公共子序列</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode-solution">最长重复子数组</a>。</li>
<li>
  <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2">滑动窗口解法</a>。</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/graysonwp/ComputerCookbook-SchoolRecruitment/edit/main/exampleSite/content/docs/algorithm/1%e3%80%81%e7%ae%97%e6%b3%95%e6%a1%86%e6%9e%b6/1.1%20%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/1.1.4%20%e5%ba%8f%e5%88%97%e5%92%8c%e6%95%b0%e7%bb%84%e7%b1%bb%e9%97%ae%e9%a2%98.md" target="_blank" rel="noopener">
      <img src="/school-recruitment/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


<div id="gitalk-container" style="width : 100%;"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '94880e59f97ce511eb59',
    clientSecret: '025de6989c2398fdb4bfc398994541421fe6d32b',
    repo: 'ComputerCookbook-SchoolRecruitment',
    owner: 'graysonwp',
    admin: ['graysonwp'],
    id: md5(location.pathname), 
    distractionFreeMode: false, 
    body: location.href, 
    proxy: 'https:\/\/shielded-brushlands-08810.herokuapp.com\/https:\/\/github.com\/login\/oauth\/access_token' 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#序列和数组类问题">序列和数组类问题</a>
      <ul>
        <li><a href="#1-序列类问题">1 序列类问题</a>
          <ul>
            <li><a href="#11-最长递增子序列httpsleetcode-cncomproblemslongest-increasing-subsequence">1.1 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">最长递增子序列</a></a>
              <ul>
                <li><a href="#111-题目">1.1.1 题目</a></li>
                <li><a href="#112-解题思路">1.1.2 解题思路</a>
                  <ul>
                    <li><a href="#1121-动态规划法">1.1.2.1 动态规划法</a>
                      <ul>
                        <li><a href="#11211-问题分析">1.1.2.1.1 问题分析</a></li>
                        <li><a href="#11212-参考代码">1.1.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#1122-二分查找法">1.1.2.2 二分查找法</a>
                      <ul>
                        <li><a href="#11221-问题分析">1.1.2.2.1 问题分析</a></li>
                        <li><a href="#11222-参考代码">1.1.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#12-最长回文子序列httpsleetcode-cncomproblemslongest-palindromic-subsequence">1.2 <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">最长回文子序列</a></a>
              <ul>
                <li><a href="#121-题目">1.2.1 题目</a></li>
                <li><a href="#122-解题思路">1.2.2 解题思路</a>
                  <ul>
                    <li><a href="#1221-子序列问题处理模板">1.2.2.1 子序列问题处理模板</a>
                      <ul>
                        <li><a href="#12211-一维-dp-数组">1.2.2.1.1 一维 dp 数组</a></li>
                        <li><a href="#12212-二维-dp-数组">1.2.2.1.2 二维 dp 数组</a></li>
                      </ul>
                    </li>
                    <li><a href="#1222-问题分析">1.2.2.2 问题分析</a></li>
                    <li><a href="#1223-参考代码">1.2.2.3 参考代码</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#13-最长公共子序列httpsleetcode-cncomproblemslongest-common-subsequence">1.3 <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></a>
              <ul>
                <li><a href="#131-解题思路">1.3.1 解题思路</a>
                  <ul>
                    <li><a href="#1311-动态规划">1.3.1.1 动态规划</a>
                      <ul>
                        <li><a href="#13111-问题分析">1.3.1.1.1 问题分析</a></li>
                        <li><a href="#13112-参考代码">1.3.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#2-数组类问题">2 数组类问题</a>
          <ul>
            <li><a href="#21-最大子序和httpsleetcode-cncomproblemsmaximum-subarray">2.1 <a href="https://leetcode-cn.com/problems/maximum-subarray">最大子序和</a></a>
              <ul>
                <li><a href="#211-题目">2.1.1 题目</a></li>
                <li><a href="#212-解题思路">2.1.2 解题思路</a>
                  <ul>
                    <li><a href="#2121-暴力法">2.1.2.1 暴力法</a>
                      <ul>
                        <li><a href="#21211-问题分析">2.1.2.1.1 问题分析</a></li>
                        <li><a href="#21212-参考代码">2.1.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2122-动态规划">2.1.2.2 动态规划</a>
                      <ul>
                        <li><a href="#21221-问题分析">2.1.2.2.1 问题分析</a></li>
                        <li><a href="#21222-参考代码">2.1.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2123-贪心法">2.1.2.3 贪心法</a>
                      <ul>
                        <li><a href="#21231-问题解析">2.1.2.3.1 问题解析</a></li>
                        <li><a href="#21232-参考代码">2.1.2.3.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-打家劫舍httpsleetcode-cncomproblemshouse-robber">2.2 <a href="https://leetcode-cn.com/problems/house-robber">打家劫舍</a></a>
              <ul>
                <li><a href="#221-解题思路">2.2.1 解题思路</a>
                  <ul>
                    <li><a href="#2211-动态规划">2.2.1.1 动态规划</a>
                      <ul>
                        <li><a href="#22111-问题分析">2.2.1.1.1 问题分析</a></li>
                        <li><a href="#22112-参考代码">2.2.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#23-乘积最大子数组httpsleetcode-cncomproblemsmaximum-product-subarray">2.3 <a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a></a>
              <ul>
                <li><a href="#231-解题思路">2.3.1 解题思路</a>
                  <ul>
                    <li><a href="#2311-动态规划">2.3.1.1 动态规划</a>
                      <ul>
                        <li><a href="#23111-问题分析">2.3.1.1.1 问题分析</a></li>
                        <li><a href="#23112-参考代码">2.3.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#24-三角形最小路径和httpsleetcode-cncomproblemstriangle">2.4 <a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></a>
              <ul>
                <li><a href="#241-解题思路">2.4.1 解题思路</a>
                  <ul>
                    <li><a href="#2411-动态规划">2.4.1.1 动态规划</a>
                      <ul>
                        <li><a href="#24111-问题分析">2.4.1.1.1 问题分析</a></li>
                        <li><a href="#24112-参考代码">2.4.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#25-解码方法httpsleetcode-cncomproblemsdecode-ways">2.5 <a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></a>
              <ul>
                <li><a href="#251-解题思路">2.5.1 解题思路</a>
                  <ul>
                    <li><a href="#2511-动态规划">2.5.1.1 动态规划</a>
                      <ul>
                        <li><a href="#25111-问题分析">2.5.1.1.1 问题分析</a></li>
                        <li><a href="#25112-参考代码">2.5.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#26-打家劫舍-iihttpsleetcode-cncomproblemshouse-robber-ii">2.6 <a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></a>
              <ul>
                <li><a href="#261-解题思路">2.6.1 解题思路</a>
                  <ul>
                    <li><a href="#2611-动态规划">2.6.1.1 动态规划</a>
                      <ul>
                        <li><a href="#26111-问题分析">2.6.1.1.1 问题分析</a></li>
                        <li><a href="#26112-参考代码">2.6.1.1.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#27-最长重复子数组httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray">2.7 <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray">最长重复子数组</a></a>
              <ul>
                <li><a href="#271-题目">2.7.1 题目</a></li>
                <li><a href="#272-解题思路">2.7.2 解题思路</a>
                  <ul>
                    <li><a href="#2721-暴力解法">2.7.2.1 暴力解法</a>
                      <ul>
                        <li><a href="#27211-问题分析">2.7.2.1.1 问题分析</a></li>
                        <li><a href="#27212-参考代码">2.7.2.1.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2722-动态规划">2.7.2.2 动态规划</a>
                      <ul>
                        <li><a href="#27221-问题分析">2.7.2.2.1 问题分析</a></li>
                        <li><a href="#27222-参考代码">2.7.2.2.2 参考代码</a></li>
                      </ul>
                    </li>
                    <li><a href="#2723-滑动窗口">2.7.2.3 滑动窗口</a>
                      <ul>
                        <li><a href="#27231-问题分析">2.7.2.3.1 问题分析</a></li>
                        <li><a href="#27232-参考代码">2.7.2.3.2 参考代码</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












