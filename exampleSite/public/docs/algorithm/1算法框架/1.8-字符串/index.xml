<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.1-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.1-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</guid>
      <description>最小覆盖子串 #  1 题目 #  给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot; 。
注意：
 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。  示例 1：
输入：s = &amp;#34;ADOBECODEBANC&amp;#34;, t = &amp;#34;ABC&amp;#34; 输出：&amp;#34;BANC&amp;#34; 示例 2：
输入：s = &amp;#34;a&amp;#34;, t = &amp;#34;a&amp;#34; 输出：&amp;#34;a&amp;#34; 示例 3:
输入: s = &amp;#34;a&amp;#34;, t = &amp;#34;aa&amp;#34; 输出: &amp;#34;&amp;#34; 解释: t 中两个字符 &amp;#39;a&amp;#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>字符串相乘 #  1 题目 #  给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = &amp;#34;2&amp;#34;, num2 = &amp;#34;3&amp;#34; 输出: &amp;#34;6&amp;#34; 示例 2:
输入: num1 = &amp;#34;123&amp;#34;, num2 = &amp;#34;456&amp;#34; 输出: &amp;#34;56088&amp;#34; 说明：
 num1 和 num2 的长度小于 110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。  2 问题分析 #   该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成，具体规律如下：  乘数 $num_1$位数为 $M$，被乘数$num_2$位数为 $N$，$num_1 \times num_2$结果$res$最大总位数为 $M + N$。 $num_1[i] \times num_2[j]$的结果为$tmp$（位数为两位，形如0x、xy），其中第一位位于 $res[i + j]$，第二位位于$res[i + j + 1]$。     3 参考代码 #  /** * 43.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.3-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.3-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>比较版本号 #  1 题目 #  给你两个版本号 version1 和 version2 ，请你比较它们。
版本号由一个或多个修订号组成，各修订号由一个 &amp;lsquo;.&amp;rsquo; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &amp;lt; 1 。
返回规则如下：
 如果 version1 &amp;gt; version2 返回 1， 如果 version1 &amp;lt; version2 返回 -1， 除此之外返回 0。  示例 1：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.4-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.4-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/</guid>
      <description>验证IP地址 #  1 题目 #  编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。
如果是有效的 IPv4 地址，返回 &amp;ldquo;IPv4&amp;rdquo; ； 如果是有效的 IPv6 地址，返回 &amp;ldquo;IPv6&amp;rdquo; ； 如果不是上述类型的 IP 地址，返回 &amp;ldquo;Neither&amp;rdquo; 。 IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(&amp;quot;.&amp;quot;)分割。比如，172.16.254.1；
同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。
IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (&amp;quot;:&amp;quot;)分割。比如, 2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address 地址 (即，忽略 0 开头，忽略大小写)。
然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.5-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.8-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.8.5-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II/</guid>
      <description>基本计算器 II #  1 题目 #  给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。
整数除法仅保留整数部分。
示例 1：
输入：s = &amp;#34;3+2*2&amp;#34; 输出：7 示例 2：
输入：s = &amp;#34; 3/2 &amp;#34; 输出：1 示例 3：
输入：s = &amp;#34; 3+5 / 2 &amp;#34; 输出：5 提示：
 1 &amp;lt;= s.length &amp;lt;= 3 * 105 s 由整数和算符 (&#39;+&#39;, &amp;lsquo;-&amp;rsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;/&#39;) 组成，中间由一些空格隔开 s 表示一个 有效表达式 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内 题目数据保证答案是一个 32-bit 整数 通过次数 90,862 提交次数 207,522  2 问题分析 #   对于【任何表达式】而言，我们都使用两个栈nums和 ops：  nums：存放所有的数字。 ops：存放所有的数字以外的操作。   然后从前往后做，对遍历到的字符做分情况讨论：  空格：跳过。 (：直接加入 ops 中，等待与之匹配的 )。 )：使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums。 数字：从当前位置开始继续往后取，将一个连续数字整体取出，加入 nums。 + - * / ^ %：需要将操作放入 ops 中，在放入之前先把栈内可以算的都算掉（只有【栈内运算符】比【当前运算符】优先级高/同等，才进行运算），使用现有的 nums 和 ops 进行计算，直到没有操作或者遇到左括号，计算结果放到 nums。   【栈内运算符】比【当前运算符】优先级高/同等，才进行运算的含义：  因为我们是从前往后做的，假设我们当前已经扫描到 2 + 1 了，此时栈内的操作为 +：  如果后面出现的 + 2 或者 - 1 的话，满足【栈内运算符】比【当前运算符】优先级高/同等，可以将 2 + 1 算掉，把结果放到 nums 中。 如果后面出现的是 * 2 或者 / 1 的话，不满足【栈内运算符】比【当前运算符】优先级高/同等，这时候不能计算 2 + 1。     一些细节：  由于第一个数可能是负数，为了减少边界判断，一个小技巧是先往 nums 添加一个 0。 为防止 () 内出现的首个字符为运算符，将所有的空格去掉，并将 (- 替换为 (0-，(+替换为 (0+。 从理论上分析，nums最好存放的是 long，而不是 int，因为可能存在 大数 + 大数 + 大数 + .</description>
    </item>
    
  </channel>
</rss>
