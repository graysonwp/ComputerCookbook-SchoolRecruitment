<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>构造 K 个回文字符串 #  1 题目 #  给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。
如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。 示例 1：
输入：s = &amp;quot;annabelle&amp;quot;, k = 2 输出：true 解释：可以用 s 中所有字符构造 2 个回文字符串。 一些可行的构造方案包括：&amp;quot;anna&amp;quot; + &amp;quot;elble&amp;quot;，&amp;quot;anbna&amp;quot; + &amp;quot;elle&amp;quot;，&amp;quot;anellena&amp;quot; + &amp;quot;b&amp;quot; 示例 2：
输入：s = &amp;quot;leetcode&amp;quot;, k = 3 输出：false 解释：无法用 s 中所有字符构造 3 个回文串。 示例 3：
输入：s = &amp;quot;true&amp;quot;, k = 4 输出：true 解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。 示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/</guid>
      <description>如何寻找最⻓回⽂⼦串 #  1 题目 #  给你一个字符串 s，找到 s 中最长的回文子串。
示例 1：
输入：s = &amp;quot;babad&amp;quot; 输出：&amp;quot;bab&amp;quot; 解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。 示例 2：
输入：s = &amp;quot;cbbd&amp;quot; 输出：&amp;quot;bb&amp;quot; 示例 3：
输入：s = &amp;quot;a&amp;quot; 输出：&amp;quot;a&amp;quot; 示例 4：
输入：s = &amp;quot;ac&amp;quot; 输出：&amp;quot;a&amp;quot; 2 问题分析 #  寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串。 可以通过双指针的方法来解决。
3 参考代码 #  package com.grayson.top; import org.apache.commons.lang3.time.StopWatch; import java.util.concurrent.TimeUnit; /** * @author peng.wei * @version 1.0 * @date 2021/3/23 15:05 * @Description 最长回文子串 */ public class L5 { /** * 寻找回文子串 * * @param s 字符串 * @param start 起始字符的下标 * @param end 结束字符的下标 * @return 偶数回文子串的长度 */ public static String palindrome(String s, int start, int end) { int slow = start, fast = end; while (slow &amp;gt;= 0 &amp;amp;&amp;amp; fast &amp;lt; s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/</guid>
      <description>如何判定括号的合法性 #  1 题目 #  给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。
示例 1：
输入：s = &amp;quot;()&amp;quot; 输出：true 示例 2：
输入：s = &amp;quot;()[]{}&amp;quot; 输出：true 示例 3：
输入：s = &amp;quot;(]&amp;quot; 输出：false 示例 4：
输入：s = &amp;quot;([)]&amp;quot; 输出：false 示例 5：
输入：s = &amp;quot;{[]}&amp;quot; 输出：true 2 问题解析 #  栈是一种后进先出的结构，处理括号的问题时尤其有用。
我们可以遍历字符串，然后遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。
3 参考代码 #  package com.grayson.top; import org.apache.commons.lang3.time.StopWatch; import javax.xml.stream.events.Characters; import java.util.Stack; import java.util.concurrent.TimeUnit; /** * @author peng.wei * @version 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</guid>
      <description>字符串转换整数 (atoi) #  1 题目 #  请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。  注意：
 本题中的空白字符只包括空格字符 &#39; &#39; 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。  示例 1：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>长度为3的不同回文子序列 #  1 题目 #  给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。
即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。
回文 是正着读和反着读一样的字符串。
子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
例如，&amp;ldquo;ace&amp;rdquo; 是 &amp;ldquo;abcde&amp;rdquo; 的一个子序列。 示例 1：
输入：s = &amp;#34;aabca&amp;#34; 输出：3 解释：长度为 3 的 3 个回文子序列分别是： - &amp;#34;aba&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) - &amp;#34;aaa&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) - &amp;#34;aca&amp;#34; (&amp;#34;aabca&amp;#34; 的子序列) 示例 2：
输入：s = &amp;#34;adc&amp;#34; 输出：0 解释：&amp;#34;adc&amp;#34; 不存在长度为 3 的回文子序列。 示例 3：
输入：s = &amp;#34;bbcbaba&amp;#34; 输出：4 解释：长度为 3 的 4 个回文子序列分别是： - &amp;#34;bbb&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;bcb&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;bab&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) - &amp;#34;aba&amp;#34; (&amp;#34;bbcbaba&amp;#34; 的子序列) 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>无重复字符的最长子串 #  1 题目 #  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2:
输入: s = &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。 示例 3:
输入: s = &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。 示例 4:
输入: s = &amp;quot;&amp;quot; 输出: 0 提示：
 0 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由英文字母、数字、符号和空格组成  2 解题思路 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>字符串相加 #  1 题目 #  给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。
提示：
 num1 和 num2 的长度都小于 5100 num1 和 num2 都只包含数字 0-9 num1 和 num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式  2 解题思路 #  2.1 模拟竖式算法 #  2.1.1 问题分析 #   如果两个字符串的长度不同，则将位数较短的字符串补零，使其和较长的字符串长度相同。 将两个字符串各位进行相加：  两个字符串当前数字分别是 $a$、$b$，进位值 $plus$ 初始为 0。 将 $a$、$b$、$plus$ 相加得 $tempRes$，同时令当前位相加结果 $add$ 等于 $tempRes$：  如果 $tempRes&amp;gt;9$，说明当前位有进位，则令 $plus=tempRes/10$，$add=tempRes-plus/10$。 否则令 $plus=0$，说明当前位没有进位。   将当前位相加得结果 $add$ 添加到最终结果 $res$ 中。   如果最后 $plus$ 大于 0，说明最后一位又有进位，将进位结果添加到最终结果 $res$ 中。 前面得到的结果 $res$ 是反的，将其反转一下返回即可。   2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>翻转字符串里的单词 #  1 题目 #  给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
说明：
 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。 翻转后单词间应当仅用一个空格分隔。 翻转后的字符串中不应包含额外的空格。  示例 1：
输入：s = &amp;#34;the sky is blue&amp;#34; 输出：&amp;#34;blue is sky the&amp;#34; 示例 2：
输入：s = &amp;#34; hello world &amp;#34; 输出：&amp;#34;world hello&amp;#34; 解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。 示例 3：
输入：s = &amp;#34;a good example&amp;#34; 输出：&amp;#34;example good a&amp;#34; 解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。 示例 4：
输入：s = &amp;#34; Bob Loves Alice &amp;#34; 输出：&amp;#34;Alice Loves Bob&amp;#34; 示例 5：</description>
    </item>
    
  </channel>
</rss>
