<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="线程池实现原理 #  1 前言 #  1.1 什么是线程池 #   线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如 MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。 线程池维护多个线程，等待监督管理者分配可并发执行的任务，这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。  1.2 线程池有哪些优点 #   降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能，比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。  1.3 线程池解决的问题是什么 #   线程池解决的核心问题就是资源管理问题，在并发环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入，这种不确定性将带来以下若干问题：  频繁申请、销毁资源和调度资源，将带来额外的损耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。   为解决资源分配这个问题，线程池采用了池化（Pooling）思想，即为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 除了线程池以外，池化思想在计算机领域的其他比较典型的几种使用策略包括：  内存池（Memory Pooling）：预先申请内存，提升内存申请速度，减少内存碎片。 连接池（Connection Pooling）：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池（Object Pooling）：循环使用对象，减少资源在初始化和释放时的昂贵损耗。    2 核心设计与实现 #  在前文中，我们了解到线程池是一种通过池化思想，帮助我们管理线程而获取并发性的工具，在 Java 中的体现是 ThreadPoolExecutor，下面我们将详细介绍该类的设计与实现。
 如无特殊说明，下面内容的叙述基于的 JDK 版本为 JDK 1.8.0_181。
 2.1 总体设计 #  ThreadPoolExecutor 的继承关系如下图所示：">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="线程池实现原理 #  1 前言 #  1.1 什么是线程池 #   线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如 MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。 线程池维护多个线程，等待监督管理者分配可并发执行的任务，这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。  1.2 线程池有哪些优点 #   降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能，比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。  1.3 线程池解决的问题是什么 #   线程池解决的核心问题就是资源管理问题，在并发环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入，这种不确定性将带来以下若干问题：  频繁申请、销毁资源和调度资源，将带来额外的损耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。   为解决资源分配这个问题，线程池采用了池化（Pooling）思想，即为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 除了线程池以外，池化思想在计算机领域的其他比较典型的几种使用策略包括：  内存池（Memory Pooling）：预先申请内存，提升内存申请速度，减少内存碎片。 连接池（Connection Pooling）：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池（Object Pooling）：循环使用对象，减少资源在初始化和释放时的昂贵损耗。    2 核心设计与实现 #  在前文中，我们了解到线程池是一种通过池化思想，帮助我们管理线程而获取并发性的工具，在 Java 中的体现是 ThreadPoolExecutor，下面我们将详细介绍该类的设计与实现。
 如无特殊说明，下面内容的叙述基于的 JDK 版本为 JDK 1.8.0_181。
 2.1 总体设计 #  ThreadPoolExecutor 的继承关系如下图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" /><meta property="article:section" content="docs" />



<title>2.8 线程池实现原理 | Computer Cookbook School Recruitment</title>
<link rel="manifest" href="/school-recruitment/manifest.json">
<link rel="icon" href="/school-recruitment/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/school-recruitment/book.min.57f7f660871517a5bfcfb5e2de853d806f7e34d94ebd5f3f3bad62e9ddbae209.css" integrity="sha256-V/f2YIcVF6W/z7Xi3oU9gG9&#43;NNlOvV8/O61i6d264gk=" crossorigin="anonymous">
  <script defer src="/school-recruitment/flexsearch.min.js"></script>
  <script defer src="/school-recruitment/en.search.min.aea6d96f0a2607e0554a26a0e35b009f9b612c62f43fa70f1c24c528cd1ae7b3.js" integrity="sha256-rqbZbwomB&#43;BVSiag41sAn5thLGL0P6cPHCTFKM0a57M=" crossorigin="anonymous"></script>

  <script defer src="/school-recruitment/sw.min.07899fc95e217f83f76b676678ae96a3d8d0d0b042f9f17c3f23eec2551b7b12.js" integrity="sha256-B4mfyV4hf4P3a2dmeK6Wo9jQ0LBC&#43;fF8PyPuwlUbexI=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />

  <a href="https://github.com/wpwbb510582246/ComputerCookbook-SchoolRecruitment" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;z-index: 100;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/school-recruitment/"><span>Computer Cookbook School Recruitment</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://www.grayson.top" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/wpwbb510582246" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






<hr>


  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-353f7a5578fa41dbc42c73ea30fe2255" class="toggle"  />
    <label for="section-353f7a5578fa41dbc42c73ea30fe2255" class="flex justify-between">
      <a role="button" class="">第一章 算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e0c159ebe8e8b165cd558008fb5f5074" class="toggle"  />
    <label for="section-e0c159ebe8e8b165cd558008fb5f5074" class="flex justify-between">
      <a role="button" class="">1、算法框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="toggle"  />
    <label for="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="flex justify-between">
      <a role="button" class="">1.1 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" class="">1.1.1 斐波那契数列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98/" class="">1.1.2 凑零钱问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="">1.1.3 贪心算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.4 最长递增子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" class="">1.1.5 编辑距离</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/" class="">1.1.6 高楼扔鸡蛋</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.7 最长回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" class="">1.1.8 最大子序和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/" class="">1.1.9 买卖股票</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/" class="">1.1.10 最长重复子数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/" class="">1.1.11 最长有效括号</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e36081c41f3a4d8d8355cae83c46c9b8" class="toggle"  />
    <label for="section-e36081c41f3a4d8d8355cae83c46c9b8" class="flex justify-between">
      <a role="button" class="">1.2 二分查找</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/" class="">1.2.1 二分查找框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">1.2.2 搜索旋转排序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="">1.2.3 如何运用二分查找算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ac9691c4865fdec0880b3cb638bc594" class="toggle"  />
    <label for="section-2ac9691c4865fdec0880b3cb638bc594" class="flex justify-between">
      <a role="button" class="">1.3 数据结构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">1.3.1 反转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" class="">1.3.2 数组中的第k个最大元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="">1.3.3 二叉树的最近公共祖先</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c6359aa6ff642b64a85093d9888f8ad" class="toggle"  />
    <label for="section-6c6359aa6ff642b64a85093d9888f8ad" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="">1.4 排序算法</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b9f975ded87a304ee48569c44f19492" class="toggle"  />
    <label for="section-9b9f975ded87a304ee48569c44f19492" class="flex justify-between">
      <a role="button" class="">1.5 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">1.5.1 二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/" class="">1.5.2 岛屿问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.3 平衡二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="">1.5.4 二叉树路径问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.5 构造二叉树</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4571e95d0021653ce2d27ee4b0838ca0" class="toggle"  />
    <label for="section-4571e95d0021653ce2d27ee4b0838ca0" class="flex justify-between">
      <a role="button" class="">1.6 回溯算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/" class="">1.6.1 回溯算法解题框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-%E5%85%A8%E6%8E%92%E5%88%97/" class="">1.6.2 全排列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.3-N%E7%9A%87%E5%90%8E/" class="">1.6.3 N皇后</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8b579ed4452b6a8d2017a24343689b5c" class="toggle"  />
    <label for="section-8b579ed4452b6a8d2017a24343689b5c" class="flex justify-between">
      <a role="button" class="">2、高频面试题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5a653711e83b11abc9ab6143b1a9fd64" class="toggle"  />
    <label for="section-5a653711e83b11abc9ab6143b1a9fd64" class="flex justify-between">
      <a role="button" class="">2.1 数学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/" class="">2.1.1 快速模幂算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/" class="">2.1.2 搜索二维矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="">2.1.3 螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" class="">2.1.4 X 的平方根</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5c279474332677699cd0b53888bd51ba" class="toggle"  />
    <label for="section-5c279474332677699cd0b53888bd51ba" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="">2.2 二分查找</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e057e8659d2f838952397ed15d20f46c" class="toggle"  />
    <label for="section-e057e8659d2f838952397ed15d20f46c" class="flex justify-between">
      <a role="button" class="">2.3 数组</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="">2.3.1 删除有序数组中的重复项</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/" class="">2.3.2 找出数组游戏的赢家</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.4 如何寻找消失的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.5 如何寻找缺失和重复的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E6%9C%80%E5%A4%A7%E6%95%B0/" class="">2.3.6 最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="">2.3.7 二维数组中的查找</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.8 两数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.9 三数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">2.3.10 合并两个有序数组</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="toggle"  />
    <label for="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="flex justify-between">
      <a role="button" class="">2.4 字符串</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">2.4.1 构造 K 个回文字符串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/" class="">2.4.2 如何寻找最 回 串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/" class="">2.4.3 如何判定括号的合法性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/" class="">2.4.4 字符串转换整数 (Atoi)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">2.4.5 长度为3的不同回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="">2.4.6 无重复字符的最长子串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/" class="">2.4.7 字符串相加</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/" class="">2.4.8 翻转字符串里的单词</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c2cc4653d849ecb4e8d0df9162693740" class="toggle"  />
    <label for="section-c2cc4653d849ecb4e8d0df9162693740" class="flex justify-between">
      <a role="button" class="">2.5 链表</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/" class="">2.5.1 环形链表 Ii</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" class="">2.5.2 如何高效判断回文链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">2.5.3 K 个一组翻转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="">2.5.4 相交链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" class="">2.5.5 链表中倒数第k个节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="">2.5.6 合并 K个升序链表</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-95a636b3d00f4ce42d96beeef34d9742" class="toggle"  />
    <label for="section-95a636b3d00f4ce42d96beeef34d9742" class="flex justify-between">
      <a role="button" class="">2.6 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/" class="">2.6.1 在二叉树中分配硬币</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="">2.6.2 将有序数组转换为二叉搜索树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">2.6.4 重建二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="">2.6.5 二叉树中的最大路径和</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2dca4a28932da6fd2ab80d6adf86f380" class="toggle"  />
    <label for="section-2dca4a28932da6fd2ab80d6adf86f380" class="flex justify-between">
      <a role="button" class="">2.7 队列</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" class="">2.7.1 用栈实现队列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9868fca37e026543bb4220219b385440" class="toggle"  />
    <label for="section-9868fca37e026543bb4220219b385440" class="flex justify-between">
      <a role="button" class="">2.8 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/" class="">2.8.1 如何高效解决接雨水问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/" class="">2.8.2 最少侧跳次数</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2b868ec58580c16b57b76d0e583b5ec9" class="toggle"  />
    <label for="section-2b868ec58580c16b57b76d0e583b5ec9" class="flex justify-between">
      <a role="button" class="">2.9 设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/" class="">2.9.1 实现 Trie (前缀树)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="">2.9.2 Lru 缓存机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0922907dd56f7a4a192db7338c0e7143" class="toggle"  />
    <label for="section-0922907dd56f7a4a192db7338c0e7143" class="flex justify-between">
      <a role="button" class="">第二章 计算机基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e090ea075956ea0a88f3be27eb8b8174" class="toggle"  />
    <label for="section-e090ea075956ea0a88f3be27eb8b8174" class="flex justify-between">
      <a role="button" class="">1、计算机网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-043e7911fd2d67fbc52b823c1516a0d8" class="toggle"  />
    <label for="section-043e7911fd2d67fbc52b823c1516a0d8" class="flex justify-between">
      <a role="button" class="">1.1 传输层： Tcp和 UDP</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="">1.1.1 三次握手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="">1.1.2 四次挥手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="">1.1.3 流量控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="">1.1.5 拥塞控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1.6 Tcp和 Udp的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="">1.1.7 Tcp如何保证传输的可靠性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" class="">1.1.8 Tcp长连接和短连接</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="toggle"  />
    <label for="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="flex justify-between">
      <a role="button" class="">1.2 应用层：HTTP和HTTPS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.1 Http和 HTTP S的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.2 Get和 Post的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.3 Session与 Cookie的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/" class="">1.2.4 从输入网址到获得页面的过程（越详细越好）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/" class="">1.2.5 Http请求有哪些常见的状态码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="">1.2.6 什么是 Rip，算法是什么</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/" class="">1.2.7 Http1.0、 Http1.1和 Http2.0的主要区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/" class="">1.2.8 DNS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" class="">1.2.9 HTTP S加密和认证过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" class="">1.2.10 常见网络攻击</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/" class="">1.2.11 Rest</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3-%E8%AE%A1%E7%AE%97%E5%85%B6%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="">1.3 计算其网络体系结构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="toggle"  />
    <label for="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="flex justify-between">
      <a role="button" class="">1.4 网络层协议</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" class="">1.4.1 Ip地址的分类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/" class="">1.4.2 划分子网</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/" class="">1.4.3 什么是 Arp协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/" class="">1.4.4 Nat协议</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-09f7d8995bc26810475d1c56597a312e" class="toggle"  />
    <label for="section-09f7d8995bc26810475d1c56597a312e" class="flex justify-between">
      <a role="button" class="">2、操作系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2f767bf946d6dc8ddeda6b6435471e5b" class="toggle"  />
    <label for="section-2f767bf946d6dc8ddeda6b6435471e5b" class="flex justify-between">
      <a role="button" class="">2.1 进程和线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.1.1 进程和线程的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="">2.1.2 进程间通信方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="">2.1.3 进程同步问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/" class="">2.1.4 进程有哪几种状态</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" class="">2.1.5 进程调度策略</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" class="">2.1.6 僵尸进程和孤儿进程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="">2.1.7 线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/" class="">2.1.8 协程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="">2.1.9 异常控制流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="">2.1.10 Io多路复用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/" class="">2.1.11 用户态和内核态</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.2-%E6%AD%BB%E9%94%81/" class="">2.2 死锁</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b2b1a78994c9898abed1b08fef134abd" class="toggle"  />
    <label for="section-b2b1a78994c9898abed1b08fef134abd" class="flex justify-between">
      <a role="button" class="">2.3 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/" class="">2.3.1 分页和分段</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="">2.3.2 虚拟内存</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="">2.3.3 页面置换算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/" class="">2.3.4 局部性原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="">2.3.5 缓冲区溢出</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/" class="">2.4 磁盘调度</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e28cc33fe5745d14abf4a0147d0624a5" class="toggle"  />
    <label for="section-e28cc33fe5745d14abf4a0147d0624a5" class="flex justify-between">
      <a role="button" class="">第三章 数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6fd3cab540793410b1ce567d790deadc" class="toggle"  />
    <label for="section-6fd3cab540793410b1ce567d790deadc" class="flex justify-between">
      <a role="button" class="">1、数据库基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/" class="">1.1 事务的概念和特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/" class="">1.2 锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/" class="">1.3 锁协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/" class="">1.4 事务日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.5 Mvcc实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12290256fbd76ac6014c39648c5827fe" class="toggle"  />
    <label for="section-12290256fbd76ac6014c39648c5827fe" class="flex justify-between">
      <a role="button" class="">1.6 基础知识</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/" class="">1.6.1 三范式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" class="">1.6.2 多表连接方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="">1.6.3 存储过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.6.4 Delete、 Truncate和 Drop的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/" class="">1.6.5 触发器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/" class="">1.6.6 视图</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d1b14978df09adfe15777e58b9b435ec" class="toggle"  />
    <label for="section-d1b14978df09adfe15777e58b9b435ec" class="flex justify-between">
      <a role="button" class="">2、 My SQL</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/" class="">2.1 索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="">2.2 B 树、 B 树索引算法原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/" class="">2.3 索引组织表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.4 Inno Db和 My Isam的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/" class="">2.5 Checkpoint技术</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/" class="">2.6 宕机恢复原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="">2.7 数据库优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="">2.8 分库分表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="">2.9 一致性哈希算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="">2.10 主从复制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-53f351d3e26dfa58c34e937b76a0c4ce" class="toggle"  />
    <label for="section-53f351d3e26dfa58c34e937b76a0c4ce" class="flex justify-between">
      <a role="button" class="">3、 Redis</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-356f36d039b40fdb10be19d36f2f2793" class="toggle"  />
    <label for="section-356f36d039b40fdb10be19d36f2f2793" class="flex justify-between">
      <a role="button" class="">3.1 概述</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/" class="">3.1.1 Redis为什么这么快</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="">3.1.2 Redis数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="">3.1.3 持久化机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="">3.1.4 过期机制和内存淘汰策略</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.2-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="">3.2 线程模型</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4731e97839509d5614da88af39acf326" class="toggle"  />
    <label for="section-4731e97839509d5614da88af39acf326" class="flex justify-between">
      <a role="button" class="">3.3 分布式问题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="">3.3.1 Redis实现分布式锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-555105a060edfd5dfac44ac6d49d31e5" class="toggle"  />
    <label for="section-555105a060edfd5dfac44ac6d49d31e5" class="flex justify-between">
      <a role="button" class="">3.4 缓存异常</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" class="">3.4.1 缓存穿透、缓存击穿、缓存雪崩</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f0d841e400bf38796a65a65ef72b420e" class="toggle"  />
    <label for="section-f0d841e400bf38796a65a65ef72b420e" class="flex justify-between">
      <a role="button" class="">第四章 设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/" class="">1、概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e796a2fc1bf6b4e9454f5a191dd15040" class="toggle"  />
    <label for="section-e796a2fc1bf6b4e9454f5a191dd15040" class="flex justify-between">
      <a role="button" class="">2、创建型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="">2.1 单例模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="">2.2 工厂模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="">2.3 代理模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-eca69da21de5b0cd25d8421dec09a327" class="toggle" checked />
    <label for="section-eca69da21de5b0cd25d8421dec09a327" class="flex justify-between">
      <a role="button" class="">第五章 Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a64d861c08691e8f06f1178d4d28cf04" class="toggle"  />
    <label for="section-a64d861c08691e8f06f1178d4d28cf04" class="flex justify-between">
      <a role="button" class="">1、 Java基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1 String、 String Buffer和 String Builder的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.2 Hash Map和 Concurrent Hash Map实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.3 Array List和 Linked List实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="">1.4 深拷贝与浅拷贝</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="toggle" checked />
    <label for="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="flex justify-between">
      <a role="button" class="">2、 Java多线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" class="">2.1 并发编程的三大特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" class="">2.2 指令重排</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Volatile%E5%8E%9F%E7%90%86/" class="">2.3 Volatile原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-CAS%E5%8E%9F%E7%90%86/" class="">2.4 Cas原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/" class="">2.5 Java的4种引用级别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="">2.6 Java中的锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.7 Synchronized实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class=" active">2.8 线程池实现原理</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65e183c484720f91ba3d1676e1ed5a16" class="toggle"  />
    <label for="section-65e183c484720f91ba3d1676e1ed5a16" class="flex justify-between">
      <a role="button" class="">3、JVM</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" class="">3.1 运行时数据区域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/" class="">3.2 判断对象是否存活的方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="">3.3 垃圾收集算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="">3.4 类的生命周期和加载过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/" class="">3.5 类加载时机</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="">3.6 类加载器的种类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/" class="">3.7 类加载机制的特点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="">3.8 Jvm内存结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.9 常见的垃圾收集算法有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/" class="">3.10 指针碰撞和空闲列表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.11 常见的垃圾收集器有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">3.12 内存溢出与内存泄漏的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.13 常用的 Jvm启动参数有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="">3.14 反射机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="toggle"  />
    <label for="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="flex justify-between">
      <a role="button" class="">第六章 Spring全家桶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/" class="">1.1 概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/" class="">1.2 Spring Ioc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/" class="">1.3 Spring Aop</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/school-recruitment/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.8 线程池实现原理</strong>

  <label for="toc-control">
    
    <img src="/school-recruitment/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"> </script>
  <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })</script>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#线程池实现原理">线程池实现原理</a>
      <ul>
        <li><a href="#1-前言">1 前言</a>
          <ul>
            <li><a href="#11-什么是线程池">1.1 什么是线程池</a></li>
            <li><a href="#12-线程池有哪些优点">1.2 线程池有哪些优点</a></li>
            <li><a href="#13-线程池解决的问题是什么">1.3 线程池解决的问题是什么</a></li>
          </ul>
        </li>
        <li><a href="#2-核心设计与实现">2 核心设计与实现</a>
          <ul>
            <li><a href="#21-总体设计">2.1 总体设计</a>
              <ul>
                <li><a href="#211-executor">2.1.1 Executor</a></li>
                <li><a href="#212-executorservice">2.1.2 ExecutorService</a></li>
                <li><a href="#213-abstractexecutorservice">2.1.3 AbstractExecutorService</a></li>
                <li><a href="#214-threadpoolexecutor">2.1.4 ThreadPoolExecutor</a>
                  <ul>
                    <li><a href="#2141-含义">2.1.4.1 含义</a></li>
                    <li><a href="#2142-构造函数">2.1.4.2 构造函数</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-生命周期管理">2.2 生命周期管理</a></li>
            <li><a href="#23-任务执行机制">2.3 任务执行机制</a>
              <ul>
                <li><a href="#231-任务调度">2.3.1 任务调度</a></li>
                <li><a href="#232-任务缓冲">2.3.2 任务缓冲</a></li>
                <li><a href="#233-任务申请">2.3.3 任务申请</a></li>
                <li><a href="#234-任务拒绝">2.3.4 任务拒绝</a></li>
                <li><a href="#235-worker-线程管理">2.3.5 Worker 线程管理</a>
                  <ul>
                    <li><a href="#2351-worker-线程">2.3.5.1 Worker 线程</a></li>
                    <li><a href="#2352-worker-线程增加">2.3.5.2 Worker 线程增加</a></li>
                    <li><a href="#2353-worker-线程回收">2.3.5.3 Worker 线程回收</a></li>
                    <li><a href="#2354-worker-线程执行任务">2.3.5.4 Worker 线程执行任务</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="线程池实现原理">
  线程池实现原理
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h1>
<h2 id="1-前言">
  1 前言
  <a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#</a>
</h2>
<h3 id="11-什么是线程池">
  1.1 什么是线程池
  <a class="anchor" href="#11-%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h3>
<ol>
<li>线程池（Thread Pool）<strong>是一种基于池化思想管理线程的工具</strong>，经常出现在多线程服务器中，如 MySQL。</li>
<li><strong>线程过多会带来额外的开销</strong>，其中包括<strong>创建销毁线程的开销</strong>、<strong>调度线程的开销</strong>等等，同时也<strong>降低了计算机的整体性能</strong>。</li>
<li>线程池<strong>维护多个线程</strong>，<strong>等待监督管理者分配可并发执行的任务</strong>，这种做法，一方面<strong>避免了处理任务时创建销毁线程开销的代价</strong>，另一方面<strong>避免了线程数量膨胀导致的过分调度问题</strong>，<strong>保证了对内核的充分利用</strong>。</li>
</ol>
<h3 id="12-线程池有哪些优点">
  1.2 线程池有哪些优点
  <a class="anchor" href="#12-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%82%b9">#</a>
</h3>
<ol>
<li><strong>降低资源消耗</strong>：<strong>通过池化技术重复利用已创建的线程</strong>，<strong>降低线程创建和销毁造成的损耗</strong>。</li>
<li><strong>提高响应速度</strong>：<strong>任务到达时</strong>，<strong>无需等待线程创建即可立即执行</strong>。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会<strong>消耗系统资源</strong>，还会<strong>因为线程的不合理分布导致资源调度失衡</strong>，<strong>降低系统的稳定性</strong>，使用线程池可以进行<strong>统一的分配</strong>、<strong>调优和监控</strong>。</li>
<li><strong>提供更多更强大的功能</strong>：<strong>线程池具备可拓展性</strong>，<strong>允许开发人员向其中增加更多的功能</strong>，比如延时定时线程池<code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定期执行。</li>
</ol>
<h3 id="13-线程池解决的问题是什么">
  1.3 线程池解决的问题是什么
  <a class="anchor" href="#13-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h3>
<ol>
<li>线程池解决的核心问题就是<strong>资源管理问题</strong>，在并发环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入，这种不确定性将带来以下若干问题：
<ol>
<li><strong>频繁申请</strong>、<strong>销毁资源和调度资源</strong>，<strong>将带来额外的损耗</strong>，<strong>可能会非常巨大</strong>。</li>
<li><strong>对资源无限申请缺少抑制手段</strong>，<strong>易引发系统资源耗尽的风险</strong>。</li>
<li><strong>系统无法合理管理内部的资源分布</strong>，<strong>会降低系统的稳定性</strong>。</li>
</ol>
</li>
<li>为解决资源分配这个问题，线程池采用了<strong>池化</strong>（Pooling）思想，即<strong>为了最大化收益并最小化风险</strong>，<strong>而将资源统一在一起管理的一种思想</strong>。</li>
<li>除了线程池以外，池化思想在计算机领域的其他比较典型的几种使用策略包括：
<ol>
<li><strong>内存池</strong>（Memory Pooling）：<strong>预先申请内存</strong>，<strong>提升内存申请速度</strong>，<strong>减少内存碎片</strong>。</li>
<li><strong>连接池</strong>（Connection Pooling）：<strong>预先申请数据库连接</strong>，<strong>提升申请连接的速度</strong>，<strong>降低系统的开销</strong>。</li>
<li><strong>实例池</strong>（Object Pooling）：<strong>循环使用对象</strong>，<strong>减少资源在初始化和释放时的昂贵损耗</strong>。</li>
</ol>
</li>
</ol>
<h2 id="2-核心设计与实现">
  2 核心设计与实现
  <a class="anchor" href="#2-%e6%a0%b8%e5%bf%83%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<p>在前文中，我们了解到<strong>线程池是一种通过池化思想</strong>，<strong>帮助我们管理线程而获取并发性的工具</strong>，在 Java 中的体现是 <code>ThreadPoolExecutor</code>，下面我们将详细介绍该类的设计与实现。</p>
<blockquote>
<p>如无特殊说明，下面内容的叙述基于的 JDK 版本为 
  <a href="https://notebook.grayson.to../../media/attachment/2021/08/jdk1.8.0_181.zip">JDK 1.8.0_181</a>。</p>
</blockquote>
<h3 id="21-总体设计">
  2.1 总体设计
  <a class="anchor" href="#21-%e6%80%bb%e4%bd%93%e8%ae%be%e8%ae%a1">#</a>
</h3>
<p><code>ThreadPoolExecutor</code> 的继承关系如下图所示：</p>
<p>
  <img src="../../media/202108/2021-08-03_153107.png" alt="" /></p>
<h4 id="211-executor">
  2.1.1 Executor
  <a class="anchor" href="#211-executor">#</a>
</h4>
<ol>
<li>提供了一种思想，<strong>将任务提交和任务执行进行解耦</strong>，用户无需关注如何创建线程，如何调度线程来执行任务，<strong>只需要提供 <code>Runnable</code> 对象</strong>，<strong>将任务的运行逻辑提交到执行器 <code>Executor</code> 中</strong>，<strong>由 <code>Executor</code> 框架完成线程的调配和任务的执行部分</strong>。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">);</span>
</code></pre></div></li>
</ol>
<h4 id="212-executorservice">
  2.1.2 ExecutorService
  <a class="anchor" href="#212-executorservice">#</a>
</h4>
<ol>
<li>
<p><strong>继承了 <code>Executor</code></strong>，<strong>提供了管控线程池的方法</strong>，比如 <code>shutdown()</code>、<code>submit()</code>，可以说<strong>是真正的线程池接口</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>    <span style="color:#75715e">/*启动一次有序的关闭，之前提交的任务执行，但不接受新的任务；这个方法不会等待之前提交的任务执行完毕*/</span>
List<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">shutdownNow</span><span style="color:#f92672">();</span>   <span style="color:#75715e">/*试图停止所有正在执行的任务。暂停处理正在等待的任务，返回一个等待执行的任务列表；这个方法不会等待正在执行的任务终止*/</span>
<span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isShutdown</span><span style="color:#f92672">();</span>   <span style="color:#75715e">/*如果已经被 shutdown，返回 true*/</span>
<span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isTerminated</span><span style="color:#f92672">();</span> <span style="color:#75715e">/*如果所有任务都已经被终止，返回 true*/</span>
<span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">awaitTermination</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span>   <span style="color:#75715e">/*在一个 shutdown 请求后，阻塞的等待所有任务执行完毕，或者到达超时时间，或者当前线程被中断*/</span>
        <span style="color:#66d9ef">throws</span> InterruptedException<span style="color:#f92672">;</span>
</code></pre></div></li>
<li>
<p><strong>扩充执行任务的能力</strong>，<strong>补充可以为一个或一批异步任务生成 <code>Future</code> 的方法</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Future<span style="color:#f92672">&lt;?&gt;</span> submit<span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">);</span> <span style="color:#75715e">/*提交一个可执行的任务，返回一个 Future 代表这个任务，等到任务成功执行，Future#get() 方法会返回 null*/</span>
<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">,</span> T result<span style="color:#f92672">);</span>  <span style="color:#75715e">/*提交一个可执行的任务，返回一个 Future 代表这个任务，等到任务成功执行，Future#get() 方法会返回这个给定的 result*/</span>
<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> task<span style="color:#f92672">);</span> <span style="color:#75715e">/*提交一个有返回值的任务，并返回一个 Future 代表等待的任务执行的结果，等到任务成功执行，Future#get() 方法会返回任务执行的结果*/</span>
</code></pre></div></li>
</ol>
<h4 id="213-abstractexecutorservice">
  2.1.3 AbstractExecutorService
  <a class="anchor" href="#213-abstractexecutorservice">#</a>
</h4>
<ol>
<li><strong>是上层的抽象类</strong>，<strong>将执行任务的流程串联了起来</strong>，<strong>保证下层的实现只需关注一个执行任务的方法即可</strong>。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Future<span style="color:#f92672">&lt;?&gt;</span> submit<span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*提交一个可执行的任务，返回一个 Future 代表这个任务，等到任务成功执行，Future#get() 方法会返回 null*/</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    RunnableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> ftask <span style="color:#f92672">=</span> newTaskFor<span style="color:#f92672">(</span>task<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
    execute<span style="color:#f92672">(</span>ftask<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> ftask<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">,</span> T result<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">/*提交一个可执行的任务，返回一个 Future 代表这个任务，等到任务成功执行，Future#get() 方法会返回这个给定的 result*/</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ftask <span style="color:#f92672">=</span> newTaskFor<span style="color:#f92672">(</span>task<span style="color:#f92672">,</span> result<span style="color:#f92672">);</span>
    execute<span style="color:#f92672">(</span>ftask<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> ftask<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Future<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> task<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">/*提交一个有返回值的任务，并返回一个 Future 代表等待的任务执行的结果，等到任务成功执行，Future#get() 方法会返回任务执行的结果*/</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ftask <span style="color:#f92672">=</span> newTaskFor<span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>
    execute<span style="color:#f92672">(</span>ftask<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> ftask<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
<h4 id="214-threadpoolexecutor">
  2.1.4 ThreadPoolExecutor
  <a class="anchor" href="#214-threadpoolexecutor">#</a>
</h4>
<h5 id="2141-含义">
  2.1.4.1 含义
  <a class="anchor" href="#2141-%e5%90%ab%e4%b9%89">#</a>
</h5>
<ol>
<li>
<p><strong>实现最复杂的运行部分</strong>，一方面<strong>维护自己的生命周期</strong>，另一方面<strong>同时管理线程和任务</strong>，<strong>使两者良好的结合从而执行并行任务</strong>，<strong>是线程池的具体实现</strong>。</p>
</li>
<li>
<p><code>ThreadPoolExecutor</code> 的运行机制如下图所示：
  <img src="../../media/202108/2021-08-03_1615400.49959836104551203.png" alt="图 2 ThreadPoolExecutor 运行流程" /></p>
<ol>
<li>线程池内部实际上<strong>构建了一个生产者消费者模型</strong>，<strong>将线程和任务两者解耦</strong>，<strong>并不直接关联</strong>，<strong>从而良好的缓冲任务</strong>，<strong>复用线程</strong>。</li>
<li>线程池的运行主要分成两部分，分别是<strong>任务管理</strong>、<strong>线程管理</strong>：
<ol>
<li><strong>任务管理部分充当生产者的角色</strong>，<strong>当任务提交后</strong>，<strong>线程池会判断该任务后续的流转</strong>：
<ol>
<li><strong>直接申请线程执行该任务</strong>。</li>
<li><strong>缓冲到队列中等待线程执行</strong>。</li>
<li><strong>拒绝该任务</strong>。</li>
</ol>
</li>
<li><strong>线程管理部分是消费者</strong>，<strong>他们被统一维护在线程池内</strong>，<strong>根据任务请求进行线程的分配</strong>，<strong>当线程执行完任务后则会继续获取新的任务去执行</strong>，<strong>最终当线程获取不到任务的时候</strong>，<strong>线程就会被回收</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="2142-构造函数">
  2.1.4.2 构造函数
  <a class="anchor" href="#2142-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0">#</a>
</h5>
<ol start="3">
<li>
<p>ThreadPoolExecutor 的构造函数如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span>
                          <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span>
                          <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span>
                          TimeUnit unit<span style="color:#f92672">,</span>
                          BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span>
                          ThreadFactory threadFactory<span style="color:#f92672">,</span>
                          RejectedExecutionHandler handler<span style="color:#f92672">)</span>
</code></pre></div><ol>
<li>
<p><code>corePoolSize</code>：</p>
<ol>
<li>线程池的<strong>核心线程数</strong>，当<strong>提交一个任务时</strong>，线程池<strong>创建一个新线程执行任务</strong>，<strong>直到线程数等于 <code>corePoolSize</code></strong>，然后<strong>继续提交的任务会被保存到阻塞队列中</strong>，<strong>等待被执行</strong>。</li>
<li><strong>如果执行了线程池的 <code>prestartAllCoreThreads()</code> 方法</strong>，<strong>线程池会提前创建并启动所有核心线程</strong>。</li>
</ol>
</li>
<li>
<p><code>maximumPoolSize</code>：</p>
<ol>
<li>线程池中<strong>允许的最大线程数</strong>，<strong>如果当前阻塞队列满了</strong>，<strong>且继续提交任务</strong>，<strong>则创建新的线程执行任务</strong>，<strong>前提是当前线程数小于 <code>maximumPoolSize</code></strong>。</li>
</ol>
</li>
<li>
<p><code>keepAliveTime</code>：</p>
<ol>
<li><strong>线程空闲时的存活时间</strong>，即<strong>当线程没有任务执行时</strong>，<strong>继续存活的时间</strong>。</li>
<li><strong>默认情况下</strong>，<strong>该参数只在线程数大于 <code>corePoolSize</code> 时才有用</strong>。</li>
</ol>
</li>
<li>
<p><code>workQueue</code>：</p>
<ol>
<li><code>workQueue</code><strong>必须是 <code>BlockingQueue</code> 阻塞队列</strong>。</li>
<li><strong>当线程池中的线程数超过他的 <code>corePoolSize</code> 的时候</strong>，<strong>线程会进入阻塞队列进行阻塞等待</strong>。</li>
<li><strong>通过 <code>workQueue</code></strong>，<strong>线程池实现了阻塞功能</strong>。</li>
<li>几种典型的阻塞队列及用法如下所示：
<ol>
<li>
<p><strong>ArrayBlockingQueue</strong>：</p>
<ol>
<li>一个<strong>数组</strong>实现的<strong>有界队列</strong>，按照<strong>先进先出</strong>（FIFO）的原则对元素进行排序，<strong>支持公平锁和非公平锁</strong>。</li>
</ol>
</li>
<li>
<p><strong>LinkedBlockingQueue</strong>：</p>
<ol>
<li>一个由<strong>链表</strong>结构组成的<strong>有界队列</strong>，按照<strong>先进先出</strong>（FIFO）的原则对元素进行排序。</li>
<li>此队列的<strong>默认长度为 <code>Integer.MAX_VALUE</code></strong>，所以<strong>默认创建的该队列有容量危险</strong>。</li>
</ol>
</li>
<li>
<p><strong>PriorityBlockingQueue</strong>：</p>
<ol>
<li>一个<strong>支持线程优先级排序</strong>的<strong>无界队列</strong>，<strong>默认自然序进行排序</strong>，<strong>也可以自定义实现 <code>compareTo()</code> 方法来指定元素排序规则</strong>，<strong>不能保证同优先级元素的顺序</strong>。</li>
</ol>
</li>
<li>
<p><strong>DelayQueue</strong>：</p>
<ol>
<li>一个<strong>实现 <code>PriorityBlockingQueue</code><strong>实现</strong>延迟获取</strong>的<strong>无界队列</strong>，在创建元素时，<strong>可以指定多久才能从队列中获取当前元素</strong>，<strong>只有延时期满后才能从队列中获取元素</strong>。</li>
</ol>
</li>
<li>
<p><strong>SynchronousQueue</strong>：</p>
<ol>
<li>一个<strong>不存储元素</strong>的阻塞队列，<strong>每一个 <code>put</code> 操作必须等待 <code>take</code> 操作</strong>，<strong>否则不能添加元素</strong>。</li>
<li><strong>支持公平锁和非公平锁</strong>。</li>
<li><code>SynchronousQueue</code> 的一个使用场景是在线程池里，<code>Executors.newCachedThreadPool()</code> 就使用了<code>SynchronousQueue</code>，这个线程池<strong>根据需要</strong>（新任务到来时）<strong>创建新的线程</strong>，<strong>如果有空闲线程则会重复使用</strong>，<strong>线程空闲了 60 秒后会被回收</strong>。</li>
</ol>
</li>
<li>
<p><strong>LinkedTransferQueue</strong>：</p>
<ol>
<li>一个由<strong>链表</strong>结构组成的<strong>无界队列</strong>，相比于其他队列，<code>LinkedTransferQueue</code> 队列<strong>多了 <code>transfer</code> 和 <code>tryTransfer</code> 方法</strong>。</li>
</ol>
</li>
<li>
<p><strong>LinkedBlockingDeque</strong>：</p>
<ol>
<li>一个由<strong>链表</strong>结构组成的<strong>双向队列</strong>，<strong>队列头部和尾部都可以添加和移除元素</strong>，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><code>threadFactory</code>：</p>
<ol>
<li>
<p><strong>创建线程的工厂</strong>，通过自定义的线程工厂<strong>可以给每个新建的线程设置一个具有识别度的线程名</strong>。</p>
</li>
<li>
<p><code>Executors</code><strong>静态工厂里默认的 <code>threadFactory</code></strong>，<strong>线程的命名规则是 <code>pool-数字-thread-数字 </code></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultThreadFactory</span> <span style="color:#66d9ef">implements</span> ThreadFactory <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> AtomicInteger poolNumber <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ThreadGroup group<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger threadNumber <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String namePrefix<span style="color:#f92672">;</span>

    DefaultThreadFactory<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        SecurityManager s <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">getSecurityManager</span><span style="color:#f92672">();</span>
        group <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getThreadGroup</span><span style="color:#f92672">()</span> <span style="color:#f92672">:</span>
                              Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getThreadGroup</span><span style="color:#f92672">();</span>
        namePrefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pool-&#34;</span> <span style="color:#f92672">+</span>
                      poolNumber<span style="color:#f92672">.</span><span style="color:#a6e22e">getAndIncrement</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span>
                     <span style="color:#e6db74">&#34;-thread-&#34;</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Thread <span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span>Runnable r<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>group<span style="color:#f92672">,</span> r<span style="color:#f92672">,</span>
                              namePrefix <span style="color:#f92672">+</span> threadNumber<span style="color:#f92672">.</span><span style="color:#a6e22e">getAndIncrement</span><span style="color:#f92672">(),</span>
                              0<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isDaemon</span><span style="color:#f92672">())</span>
            t<span style="color:#f92672">.</span><span style="color:#a6e22e">setDaemon</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">getPriority</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">NORM_PRIORITY</span><span style="color:#f92672">)</span>
            t<span style="color:#f92672">.</span><span style="color:#a6e22e">setPriority</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">NORM_PRIORITY</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><code>Executors</code> 静态工厂创建的几种常用的线程池如下：</p>
<ol>
<li><code>newFixedThreadPool</code>：
<ol>
<li>
<p>创建一个<strong>指定工作线程数的线程池</strong>，其中参数 <code>corePoolSize</code><strong>和 <code>maximumPoolSize</code> 相等</strong>，<strong>阻塞队列基于 <code>LinkedBlockingQueue</code></strong>。</p>
</li>
<li>
<p>他<strong>是一个典型且优秀的线程池</strong>，<strong>具有提高线程池执行效率和节省创建线程所耗开销的优点</strong>，但是<strong>在线程池空闲时</strong>，即<strong>线程池中没有可运行任务时</strong>，他<strong>也不会释放工作线程</strong>，<strong>还会占用一定的资源</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> nThreads<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>nThreads<span style="color:#f92672">,</span> nThreads<span style="color:#f92672">,</span>
                                  0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                  <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> nThreads<span style="color:#f92672">,</span> ThreadFactory threadFactory<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>nThreads<span style="color:#f92672">,</span> nThreads<span style="color:#f92672">,</span>
                                  0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                  <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;(),</span>
                                  threadFactory<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
</li>
<li><code>newSingleThreadExecutor</code>：
<ol>
<li>
<p><strong>初始化的线程只有一个线程</strong>，<strong>如果该线程异常结束</strong>，<strong>会重新创建一个新的线程继续执行任务</strong>。</p>
</li>
<li>
<p><strong>唯一的线程可以保证所提交任务的顺序执行</strong>，<strong>内部使用 <code>LinkedBlockingQueue</code>作为阻塞队列</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FinalizableDelegatedExecutorService
        <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span>
                                0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;()));</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">(</span>ThreadFactory threadFactory<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FinalizableDelegatedExecutorService
        <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span>
                                0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span>
                                <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;(),</span>
                                threadFactory<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
</li>
<li><code>newCachedThreadPool</code>：
<ol>
<li>
<p><strong>创建一个可缓存工作线程的线程池</strong>，<strong>默认存活时间60秒</strong>。</p>
</li>
<li>
<p><strong>线程池的线程数可达到 <code>Integer.MAX_VALUE</code></strong>，<strong>内部使用 <code>SynchronousQueue</code>作为阻塞队列</strong>。</p>
</li>
<li>
<p><strong>在没有任务执行时</strong>，<strong>当线程的空闲时间超过 <code>keepAliveTime</code></strong>，则<strong>工作线程会停止</strong>，<strong>当提交新任务时</strong>，<strong>如果没有空闲线程</strong>，则<strong>创建新线程执行任务</strong>，<strong>会导致一定的系统开销</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span>
                                  60L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span>
                                  <span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">(</span>ThreadFactory threadFactory<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span>
                                  60L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span>
                                  <span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;(),</span>
                                  threadFactory<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
</li>
<li><code>newScheduledThreadPool</code>：
<ol>
<li>
<p>初始化的线程池<strong>可以在指定的时间内周期性的执行所提交的任务</strong>，在实际的应用场景中<strong>可以使用该线程池定期的同步数据</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ScheduledExecutorService <span style="color:#a6e22e">newScheduledThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ScheduledExecutorService <span style="color:#a6e22e">newScheduledThreadPool</span><span style="color:#f92672">(</span>
        <span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span> ThreadFactory threadFactory<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">,</span> threadFactory<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><code>ScheduledExecutorService</code>中的定式策略有两种：</p>
<ol>
<li><code>scheduleAtFixedRate</code>：
<ol>
<li>
<p>指的是<strong>以固定的频率执行</strong>，<code>period</code>指的是<strong>两次成功执行之间的时间</strong>。</p>
</li>
<li>
<p>比如 <code>scheduleAtFixedRate(command, 5, 2, second)</code>，第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> ScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> scheduleAtFixedRate<span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">,</span>
                                              <span style="color:#66d9ef">long</span> initialDelay<span style="color:#f92672">,</span>
                                              <span style="color:#66d9ef">long</span> period<span style="color:#f92672">,</span>
                                              TimeUnit unit<span style="color:#f92672">);</span>
</code></pre></div></li>
</ol>
</li>
<li><code>scheduleWithFixedDelay</code>：
<ol>
<li>指的是<strong>以固定的延时</strong>执行，<code>delay</code>指的是<strong>一次执行终止和下一次执行开始之间的延迟</strong>。</li>
<li>还是上例，<code>scheduleAtFixedRate(command, 5, 2, second)</code>，第一次开始执行是5s后，假如执行耗时1s，执行完成时间是6s后，那么下次开始执行是8s后，再下次开始执行是11s后。
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> ScheduledFuture<span style="color:#f92672">&lt;?&gt;</span> scheduleWithFixedDelay<span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">,</span>
                                                 <span style="color:#66d9ef">long</span> initialDelay<span style="color:#f92672">,</span>
                                                 <span style="color:#66d9ef">long</span> delay<span style="color:#f92672">,</span>
                                                 TimeUnit unit<span style="color:#f92672">);</span>
</code></pre></div></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><code>RejectedExecutionHandler</code>：</p>
<ol>
<li>线程池的<strong>拒绝策略</strong>，当<strong>阻塞队列满了</strong>，且<strong>没有空闲的工作线程</strong>，如果<strong>继续提交任务</strong>，<strong>必须采取一种策略处理该任务</strong>。</li>
<li>线程池提供了 4 种拒绝策略：
<ul>
<li><strong>AbortPolicy</strong>：
<ol>
<li><strong>丢弃任务并抛出 <code>RejectedExecutionException</code></strong>，这是线程池<strong>默认的拒绝策略</strong>，在<strong>任务不能再提交的时候</strong>，<strong>抛出异常</strong>，<strong>及时反馈程序运行状态</strong>。</li>
<li>如果是<strong>比较关键的业务</strong>，<strong>推荐使用此拒绝策略</strong>，这样<strong>在系统不能承载更大的并发量的时候</strong>，<strong>能够及时的通过异常发现</strong>。</li>
</ol>
</li>
<li><strong>DiscardPolicy</strong>：
<ol>
<li><strong>丢弃任务</strong>，但是<strong>不抛出异常</strong>。</li>
<li>使用此策略，可能会使我们<strong>无法发现系统的异常状态</strong>，<strong>建议是一些无关紧要的业务采用此策略</strong>。</li>
</ol>
</li>
<li><strong>DiscardOldestPolicy</strong>：
<ol>
<li><strong>丢弃队列最前面的任务</strong>，然后<strong>重新提交被拒绝的任务</strong>。</li>
<li>是否要采用此种策略，还得<strong>根绝实际业务是否允许丢弃老任务来认真衡量</strong>。</li>
</ol>
</li>
<li><strong>CallerRunsPolicy</strong>：
<ol>
<li><strong>由调用线程</strong>（提交任务的线程）<strong>处理该任务</strong>。</li>
<li>这种情况是<strong>需要让所有任务都执行完毕</strong>，比较<strong>适合大量计算的任务类型去执行</strong>，多线程仅仅是增大吞吐量的手段，最终<strong>必须要让每个任务都执行完毕</strong>。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="22-生命周期管理">
  2.2 生命周期管理
  <a class="anchor" href="#22-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%ae%a1%e7%90%86">#</a>
</h3>
<ol>
<li>
<p><strong>线程池的运行状态</strong>，并不是用户显示设置的，而是伴随着线程池的运行，<strong>由内部来维护</strong>，线程池内部<strong>使用一个变量维护两个值</strong>，分别为<strong>运行状态</strong>（<code>runState</code>）和<strong>线程池数量</strong>（<code>workerCount</code>），具体代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger ctl <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>ctlOf<span style="color:#f92672">(</span>RUNNING<span style="color:#f92672">,</span> 0<span style="color:#f92672">));</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> COUNT_BITS <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">SIZE</span> <span style="color:#f92672">-</span> 3<span style="color:#f92672">;</span> <span style="color:#75715e">/*Integer.SIZE = 32;*/</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CAPACITY   <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>

    <span style="color:#75715e">// runState is stored in the high-order bits
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RUNNING    <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SHUTDOWN   <span style="color:#f92672">=</span>  0 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> STOP       <span style="color:#f92672">=</span>  1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TIDYING    <span style="color:#f92672">=</span>  2 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TERMINATED <span style="color:#f92672">=</span>  3 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>

    <span style="color:#75715e">// Packing and unpacking ctl
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runStateOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>     <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">workerCountOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>  <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ctlOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> rs<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> wc<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> rs <span style="color:#f92672">|</span> wc<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>    <span style="color:#75715e">/*rs：runState，运行状态 wc：wordCount，线程池数量*/</span>
</code></pre></div><ol>
<li><code>ctl</code> 这个<code>AtomInteger</code> 类型，是<strong>对线程池的运行状态和有效线程数量进行控制的一个字段</strong>，他同时包含两部分信息，分别是<strong>线程池的运行状态</strong>和<strong>线程池内有效线程的数量</strong>，其中，<strong>高 3 位用于维护线程池运行状态</strong>，<strong>低 29 位用于维护线程池中线程数量</strong>，两个变量之间互不干扰。</li>
<li>用<strong>一个变量去存储两个值</strong>，<strong>可以避免在做相关决策时出现不一致的情况</strong>，<strong>不必为了维护两者的一致而占用锁资源</strong>。</li>
<li>通过阅读线程池源代码也可以发现，<strong>经常出现需要同时判断线程池运行状态和线程数量的情况</strong>，线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数，这里<strong>使用的都是位运算的方式</strong>，<strong>相比于基本运算</strong>，<strong>速度也会快很多</strong>。</li>
</ol>
</li>
<li>
<p><code>ThreadPoolExecutor</code> 的运行状态有 5 种，具体如下所示：</p>
<ol>
<li><strong>RUNNING</strong>：<strong>能接受新提交的任务</strong>，并且<strong>也能处理阻塞队列中的任务</strong>。</li>
<li><strong>SHUTDOWN</strong>：<strong>不再接受新提交的任务</strong>，但却<strong>可以继续处理阻塞队列中已保存的任务</strong>。</li>
<li><strong>STOP</strong>：<strong>不能接受新任务</strong>，<strong>也不处理队列中的任务</strong>，<strong>会中断正在处理任务的线程</strong>。</li>
<li><strong>TIDYING</strong>：<strong>所有的任务都已终止了</strong>，<strong><code>workCount</code></strong>（有效线程数）<strong>为 0</strong>。</li>
<li><strong>TERMINATED</strong>：<strong>在 <code>terminated()</code> 方法执行完后进入该状态</strong>。</li>
</ol>
</li>
</ol>
<p>其生命周期转换如下图所示：</p>
<p>
  <img src="../../media/202108/2021-08-03_1737060.37733254829039.png" alt="图 3 线程池生命周期" /></p>
<h3 id="23-任务执行机制">
  2.3 任务执行机制
  <a class="anchor" href="#23-%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6">#</a>
</h3>
<h4 id="231-任务调度">
  2.3.1 任务调度
  <a class="anchor" href="#231-%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6">#</a>
</h4>
<blockquote>
<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的，了解这部分就相当于了解了线程池的核心运行机制。</p>
</blockquote>
<ol>
<li>首先，<strong>所有任务的调度都是由 <code>execute()</code> 方法完成的</strong>，这部分完成的工作是<strong>检查线程池的运行状态</strong>、<strong>运行线程数</strong>、<strong>运行策略</strong>，<strong>决定接下来执行的流程</strong>，<strong>是直接申请线程执行</strong>，<strong>或是缓冲到队列中执行</strong>，<strong>亦或是直接拒绝该任务</strong>。</li>
<li>当<strong>试图通过 <code>execute()</code> 方法将一个</strong><code>Runnable</code> 任务添加到线程池中时，按照如下顺序来处理：
<ol>
<li>
<p>首先<strong>检测线程池运行状态</strong>，如果<strong>不是 <code>RUNNING</code></strong>，则<strong>直接拒绝</strong>，<strong>线程池要保证在 <code>RUNNING</code> 的状态下执行任务</strong>。</p>
</li>
<li>
<p>然后<strong>检查运行线程数</strong>，<strong>决定接下来执行的流程</strong>：</p>
<ol>
<li>如果<strong>线程池中的线程数量少于 <code>corePoolSize</code></strong>，就<strong>创建新的线程来执行新添加的任务</strong>。</li>
<li>如果<strong>线程池中的线程数量大于等于 <code>corePoolSize</code></strong>，但<strong>队列 <code>workQueue</code> 未满</strong>，则<strong>将新添加的任务放到 <code>workQueue</code> 中</strong>，<strong>按照 FIFO 的原则依次等待执行</strong>（线程池中有线程空闲出来后依次将队列中的任务交付给空闲的线程执行）。</li>
<li>如果<strong>线程池中的线程数量大于等于 <code>corePoolSize</code></strong>，且<strong>队列 <code>workQueue</code> 已满</strong>，但<strong>线程池中的线程数量小于 <code>maximumPoolSize</code></strong>，则<strong>会创建新的线程来处理被添加的任务</strong>。</li>
<li>如果<strong>线程池中的线程数量等于了 <code>maximumPoolSize</code></strong>，就<strong>用 <code>RejectedExecutionHandler</code> 来做拒绝处理</strong>。</li>
</ol>
<p>
  <img src="../../media/202108/2021-08-04_0947410.23325597268259834.png" alt="" /></p>
<p>
  <img src="../../media/202108/2021-08-05_0958330.09879545066325768.png" alt="11" /></p>
<p>
  <img src="../../media/202108/2021-08-05_0958470.916503821148198.png" alt="22" /></p>
<blockquote>
<p>针对上面最后两张图的说明：</p>
<ol>
<li>在第二张图中，线程池中有 $N$ 个任务，任务 1、任务 2、任务 3 这三个任务在执行，而任务 4 到任务 $N$ 在阻塞队列中等待，在执行任务的 <code>Workers</code> 集合中，包含 3 个<code>Worker</code>，每一个<code>Worker</code> 对应一个<code>Thread</code> 线程，<code>Thread</code> 线程每次处理一个任务。</li>
<li>当<code>Worker</code> 集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如第三张图所示，第三张图表示任务 1 处理完毕之后，线程池将任务 4 从阻塞队列中取出，放到<code>Workers</code> 中进行处理。</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="232-任务缓冲">
  2.3.2 任务缓冲
  <a class="anchor" href="#232-%e4%bb%bb%e5%8a%a1%e7%bc%93%e5%86%b2">#</a>
</h4>
<ol>
<li><strong>任务缓冲模块是线程池能够管理任务的核心部分</strong>，<strong>线程池的本质是对任务和线程的管理</strong>，而<strong>做到这一点的关键的思想就是将任务和线程两者解耦</strong>，<strong>不让两者直接关联</strong>，<strong>才可以做后续的分配工作</strong>。</li>
<li><strong>线程池中是以生产者消费者模式</strong>，<strong>通过一个阻塞队列来实现的</strong>，<strong>阻塞队列缓存任务</strong>，<strong>工作线程从阻塞队列中获取任务</strong>。</li>
<li><strong>阻塞队列是一个支持两个附加操作的队列</strong>，这两个附加的操作是：
<ol>
<li><strong>在队列为空时</strong>，<strong>获取元素的线程会等待队列变为非空</strong>。</li>
<li><strong>当队列满时</strong>，<strong>存储元素的线程会等待队列可用</strong>。</li>
</ol>
</li>
<li><strong>阻塞队列常用于生产者和消费者的场景</strong>，<strong>生产者是往队列里添加元素的线程</strong>，<strong>消费者是从队列里拿元素的线程</strong>，<strong>阻塞队列就是生产者存放元素的容器</strong>，而<strong>消费者也只是从容器里拿元素</strong>，如下图所示：
  <img src="../../media/202108/2021-08-04_1035250.31094488351753713.png" alt="图 5 阻塞队列" /></li>
<li>使用不同的队列可以实现不一样的任务存取策略，几种典型的阻塞队列及用法详见
  <a href="/school-recruitment/#2-1-4-2-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0">2.1.4.2 构造函数</a>。</li>
</ol>
<h4 id="233-任务申请">
  2.3.3 任务申请
  <a class="anchor" href="#233-%e4%bb%bb%e5%8a%a1%e7%94%b3%e8%af%b7">#</a>
</h4>
<ol>
<li>由上文的任务分配部分可知，任务的执行有两种可能：
<ol>
<li><strong>任务直接由新创建的线程执行</strong>，这种情况<strong>仅出现在线程初始创建的时候</strong>。</li>
<li><strong>线程从任务队列中获取任务然后执行</strong>，<strong>执行完任务的空闲线程会再次去从队列中申请任务再去执行</strong>，这种情况<strong>出现在线程获取任务的绝大多数情况</strong>。</li>
</ol>
</li>
<li><strong>线程需要从任务缓存模块中不断地取任务执行</strong>，<strong>帮助线程从阻塞队列中获取任务</strong>，<strong>实现线程管理模块和任务管理模块之间的通信</strong>，<strong>这部分策略由 <code>getTask</code> 方法实现</strong>，其执行流程如下图所示：
  <img src="../../media/202108/2021-08-04_1140410.08117444125024054.png" alt="图 6 获取任务流程图" /></li>
<li><code>getTask()</code> 这部分<strong>进行了多次判断</strong>，为的是<strong>控制线程的数量</strong>，<strong>使其符合线程池的状态</strong>，<strong>如果线程池现在不应该持有那么多线程</strong>，<strong>则会返回 <code>null</code></strong>，<strong>工作线程 <code>Workder</code> 会不断接收新任务去执行</strong>，而<strong>当工作线程 <code>Worker</code> 接收不到任务的时候</strong>，<strong>就会开始被回收</strong>。</li>
</ol>
<h4 id="234-任务拒绝">
  2.3.4 任务拒绝
  <a class="anchor" href="#234-%e4%bb%bb%e5%8a%a1%e6%8b%92%e7%bb%9d">#</a>
</h4>
<ol>
<li><strong>任务拒绝模块是线程池的保护部分</strong>，<strong>线程池有一个最大的容量</strong>，<strong>当线程池的任务缓存队列已满</strong>，并且<strong>线程池中的线程数目达到 <code>maximumPoolSize</code> 时</strong>，<strong>就需要拒绝掉该服务</strong>，<strong>采取任务拒绝策略</strong>，<strong>保护线程池</strong>。</li>
<li><strong>拒绝策略是一个接口</strong>，<strong>用户可以通过实现这个接口去定制拒绝策略</strong>，也可以选择 JDK 提供的四种已有拒绝策略，详见
  <a href="/school-recruitment/#2-1-4-2-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0">2.1.4.2 构造函数</a>。</li>
</ol>
<h4 id="235-worker-线程管理">
  2.3.5 Worker 线程管理
  <a class="anchor" href="#235-worker-%e7%ba%bf%e7%a8%8b%e7%ae%a1%e7%90%86">#</a>
</h4>
<h5 id="2351-worker-线程">
  2.3.5.1 Worker 线程
  <a class="anchor" href="#2351-worker-%e7%ba%bf%e7%a8%8b">#</a>
</h5>
<ol>
<li>
<p>线程池为了<strong>掌握线程的状态并维护线程的生命周期</strong>，设计了线程池内的工作线程 Worker，部分代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span>
    <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer
    <span style="color:#66d9ef">implements</span> Runnable
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> Thread thread<span style="color:#f92672">;</span>    <span style="color:#75715e">/*Worker 持有的线程*/</span>
    Runnable firstTask<span style="color:#f92672">;</span> <span style="color:#75715e">/*初始化的任务，可以为 null*/</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>Worker 这个工作线程，实现了 <code>Runnable</code> 接口，并持有一个线程 <code>thread</code>，一个初始化的任务 <code>firstTask</code>：</p>
<ol>
<li><code>thread</code>：<strong>在调用构造方法时通过 <code>ThreadFactory</code> 来创建</strong>，<strong>可以用来执行任务</strong>。</li>
<li><code>firstTask</code>：<strong>用来保存传入的第一个任务</strong>，这个任务<strong>可以有也可以为 <code>null</code></strong>，如果这个值是<strong>非空</strong>的，那么<strong>线程就会在启动初期立即执行这个任务</strong>，也就<strong>对应核心线程创建时的情况</strong>，如果这个值是<code>null</code>，那么就<strong>需要创建一个线程去执行任务列表</strong>（<code>workQueue</code>）<strong>中的任务</strong>，也就是<strong>非核心线程的创建</strong>。</li>
</ol>
<p>
  <img src="../../media/202108/2021-08-04_1514310.9596805483939324.png" alt="图 7 Worker 执行任务" /></p>
</li>
<li>
<p>线程池需要<strong>管理线程的生命周期</strong>，<strong>在线程长时间不运行时需要对其进行回收</strong>，线程池<strong>使用一张 Hash 表去持有线程的引用</strong>，这样<strong>可以通过添加引用</strong>、<strong>移除引用这样的操作来控制线程的生命周期</strong>，这个时候重要的就是<strong>如何判断线程是否在运行</strong>。</p>
</li>
<li>
<p>Worker 是通过继承 AQS，<strong>使用 AQS 来实现独占锁这个功能</strong>，<strong>通过实现不可重入的特性去反映线程现在的执行状态</strong>：</p>
<ol>
<li><strong><code>lock</code> 方法一旦获取了独占锁</strong>，表示<strong>当前线程正在执行任务中</strong>，此时<strong>不应该中断线程</strong>。</li>
<li><strong>如果线程现在不是独占锁的状态</strong>，<strong>也就是空闲的状态</strong>，说明他<strong>没有在处理任务</strong>，这时<strong>可以对该线程进行中断</strong>。</li>
<li>线程池在<strong>执行 <code>shutdown()</code> 方法或 <code>tryTerminate()</code> 方法时会调用 <code>interruptIdleWorkers()</code> 方法来中断空闲的线程</strong>，<code>interruptIdleWorkers()</code> 方法会使用<code>tryLock()</code> 方法来判断线程池中的线程是否是空闲状态，如果线程是空闲状态，<strong>则可以安全回收</strong>。
  <img src="../../media/202108/2021-08-04_1537570.5383356998637554.png" alt="图 8 线程池回收过程" /></li>
</ol>
</li>
</ol>
<h5 id="2352-worker-线程增加">
  2.3.5.2 Worker 线程增加
  <a class="anchor" href="#2352-worker-%e7%ba%bf%e7%a8%8b%e5%a2%9e%e5%8a%a0">#</a>
</h5>
<ol>
<li>增加线程是通过线程池中的<code>addWorker()</code> 方法，该方法的功能就是<strong>增加一个线程</strong>，<strong>不考虑线程池是在哪个阶段增加的该线程</strong>，这个分配线程的策略是在上个步骤完成的，该步骤仅仅是完成<strong>增加线程</strong>，<strong>并使他运行</strong>，最后<strong>返回是否成功这个结果</strong>。</li>
<li><code>addWorker()</code> 方法有两个参数，分别是<code>firstTask</code>、<code>core</code>：
<ol>
<li><code>firstTask</code>：<strong>指定新增的线程执行的第一个任务</strong>，<strong>该参数可以为空</strong>。</li>
<li><code>core</code>：该参数为<code>true</code>，表示<strong>在新增线程时会判断当前活动线程数是否少于 <code>corePoolSize</code></strong>，<code>false</code> 表示<strong>在新增线程时会判断当前活动线程数是否少于 <code>maximumPoolSize</code></strong>。</li>
</ol>
</li>
<li><code>addWorker()</code> 方法的执行流程如下图所示：
  <img src="../../media/202108/2021-08-04_1550510.26064429955688506.png" alt="图 9 申请线程执行流程图" /></li>
</ol>
<h5 id="2353-worker-线程回收">
  2.3.5.3 Worker 线程回收
  <a class="anchor" href="#2353-worker-%e7%ba%bf%e7%a8%8b%e5%9b%9e%e6%94%b6">#</a>
</h5>
<ol>
<li>
<p>线程池中<strong>线程的销毁依赖 JVM 的自动回收</strong>，线程池做的工作是<strong>根据当前线程池的状态维护一定数量的线程引用</strong>，<strong>防止这部分线程被 JVM 回收</strong>，<strong>当线程池决定哪些线程需要回收时</strong>，<strong>只需要将其引用消除即可</strong>。</p>
</li>
<li>
<p><strong>Worker 被创建出来以后</strong>，就<strong>会不断地进行轮询</strong>，然后<strong>获取任务去执行</strong>，<strong>核心线程可以无限等待获取任务</strong>，<strong>非核心线程要限时获取任务</strong>，<strong>当 Worker 无法获取到任务</strong>，<strong>也就是获取的任务为空时</strong>，<strong>循环会结束</strong>，<strong>Worker 会主动消除自身在线程池内的引用</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">=</span> getTask<span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//执行任务
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
  processWorkerExit<span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> completedAbruptly<span style="color:#f92672">);</span><span style="color:#75715e">//获取不到任务时，主动回收自己
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>
  <img src="../../media/202108/2021-08-04_1600030.20263527686884708.png" alt="图 10 线程销毁流程" /></p>
<blockquote>
<p>需要注意的是：</p>
<ol>
<li>线程回收的工作是在<code>processWorkerExit()</code> 方法中完成的，在这个方法中，<strong>将线程引用移除线程池就已经结束了线程销毁的部分</strong>，但是由于<strong>引起线程销毁的可能性有很多</strong>，因此<strong>线程池还要判断是什么引发了这次销毁</strong>，<strong>是否要改变线程池的现阶段状态</strong>，<strong>是否要根据新状态重新分配线程</strong>。</li>
</ol>
</blockquote>
</li>
</ol>
<h5 id="2354-worker-线程执行任务">
  2.3.5.4 Worker 线程执行任务
  <a class="anchor" href="#2354-worker-%e7%ba%bf%e7%a8%8b%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1">#</a>
</h5>
<ol>
<li>在 Worker 类中的<code>run()</code> 方法调用了<code>runWorker()</code> 方法来执行任务，其执行过程如下：
<ol>
<li>
<p><code>while</code><strong>循环不断地通过 <code>getTask()</code> 方法获取任务</strong>。</p>
</li>
<li>
<p><code>getTask()</code><strong>方法从阻塞队列中获取任务</strong>：</p>
<ol>
<li>如果<strong>获取到任务</strong>：
<ul>
<li><strong>如果线程池正在停止</strong>，那么<strong>要保证当前线程是中断状态</strong>，<strong>否则要保证当前线程不是中断状态</strong>。</li>
<li><strong>执行任务</strong>。</li>
</ul>
</li>
<li>如果<strong>没有获取到任务</strong>，<strong>执行 <code>processWorkerExit()</code> 方法</strong>，<strong>销毁线程</strong>。</li>
</ol>
<p>
  <img src="../../media/202108/2021-08-04_1624560.0730340580168457.png" alt="图 11 执行任务流程" /></p>
</li>
</ol>
</li>
</ol>
<h2 id="参考文献">
  参考文献
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#</a>
</h2>
<ol>
<li>
  <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java 线程池实现原理及其在美团业务中的实践</a>。</li>
<li>
  <a href="https://www.cnblogs.com/trust-freedom/p/6594270.html">Java 线程池 ThreadPoolExecutor 使用和分析(一)</a>。</li>
<li>
  <a href="https://www.cnblogs.com/trust-freedom/p/6681948.html">Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理</a>。</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/wpwbb510582246/ComputerCookbook-SchoolRecruitment/edit/main/exampleSite/content/docs/java/2%e3%80%81Java%e5%a4%9a%e7%ba%bf%e7%a8%8b/2.8%20%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.md" target="_blank" rel="noopener">
      <img src="/school-recruitment/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


<div id="gitalk-container" style="width : 100%;"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '94880e59f97ce511eb59',
    clientSecret: '025de6989c2398fdb4bfc398994541421fe6d32b',
    repo: 'ComputerCookbook-SchoolRecruitment',
    owner: 'wpwbb510582246',
    admin: ['wpwbb510582246'],
    id: md5(location.pathname), 
    distractionFreeMode: false, 
    body: location.href, 
    proxy: 'https:\/\/shielded-brushlands-08810.herokuapp.com\/https:\/\/github.com\/login\/oauth\/access_token' 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#线程池实现原理">线程池实现原理</a>
      <ul>
        <li><a href="#1-前言">1 前言</a>
          <ul>
            <li><a href="#11-什么是线程池">1.1 什么是线程池</a></li>
            <li><a href="#12-线程池有哪些优点">1.2 线程池有哪些优点</a></li>
            <li><a href="#13-线程池解决的问题是什么">1.3 线程池解决的问题是什么</a></li>
          </ul>
        </li>
        <li><a href="#2-核心设计与实现">2 核心设计与实现</a>
          <ul>
            <li><a href="#21-总体设计">2.1 总体设计</a>
              <ul>
                <li><a href="#211-executor">2.1.1 Executor</a></li>
                <li><a href="#212-executorservice">2.1.2 ExecutorService</a></li>
                <li><a href="#213-abstractexecutorservice">2.1.3 AbstractExecutorService</a></li>
                <li><a href="#214-threadpoolexecutor">2.1.4 ThreadPoolExecutor</a>
                  <ul>
                    <li><a href="#2141-含义">2.1.4.1 含义</a></li>
                    <li><a href="#2142-构造函数">2.1.4.2 构造函数</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-生命周期管理">2.2 生命周期管理</a></li>
            <li><a href="#23-任务执行机制">2.3 任务执行机制</a>
              <ul>
                <li><a href="#231-任务调度">2.3.1 任务调度</a></li>
                <li><a href="#232-任务缓冲">2.3.2 任务缓冲</a></li>
                <li><a href="#233-任务申请">2.3.3 任务申请</a></li>
                <li><a href="#234-任务拒绝">2.3.4 任务拒绝</a></li>
                <li><a href="#235-worker-线程管理">2.3.5 Worker 线程管理</a>
                  <ul>
                    <li><a href="#2351-worker-线程">2.3.5.1 Worker 线程</a></li>
                    <li><a href="#2352-worker-线程增加">2.3.5.2 Worker 线程增加</a></li>
                    <li><a href="#2353-worker-线程回收">2.3.5.3 Worker 线程回收</a></li>
                    <li><a href="#2354-worker-线程执行任务">2.3.5.4 Worker 线程执行任务</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












