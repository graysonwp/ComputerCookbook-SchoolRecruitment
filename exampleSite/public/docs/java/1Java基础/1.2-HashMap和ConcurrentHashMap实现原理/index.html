<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="HashMap和ConcurrentHashMap实现原理 #  1 HashMap #  1.1 简介 #   Java 为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、HashTable、LinkedHashMap和TreeMap，类继承关系如下图所示：  下面针对各个实现类的特点做一些说明：  HashMap：  根据键的 hashCode 值存储数据，大多数情况下可以直接定位到他的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 最多只允许一条记录的键为 null，允许多条记录为 null。 非线程安全，任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。 如果需要满足线程安全，可以用 Collections 的 synchronizedMap() 方法（该方法也是使用一个全局锁来同步多个线程间的并发访问）使 HashMap 具有线程安全能力，或者使用 ConcurrentHashMap。   HashTable：  HashTable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是他继承自 Dictionary 类，并且是线程安全的：  HashTable线程安全的策略实现代价比较大，简单粗暴，get/put所有相关的操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问的时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。    HashTable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换，因为ConcurrentHashMap 采用了分段锁，并发性比 HashTable 要高很多，具体可参考 2.1 实现原理。    LinkedHashMap：  LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。   TreeMap：  TreeMap 实现了 SortedMap 接口，能够把保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的，如果使用排序的映射，建议使用 TreeMap。 在使用 TreeMap 时，key必须实现 Comparable 接口，或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="HashMap和ConcurrentHashMap实现原理 #  1 HashMap #  1.1 简介 #   Java 为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、HashTable、LinkedHashMap和TreeMap，类继承关系如下图所示：  下面针对各个实现类的特点做一些说明：  HashMap：  根据键的 hashCode 值存储数据，大多数情况下可以直接定位到他的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 最多只允许一条记录的键为 null，允许多条记录为 null。 非线程安全，任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。 如果需要满足线程安全，可以用 Collections 的 synchronizedMap() 方法（该方法也是使用一个全局锁来同步多个线程间的并发访问）使 HashMap 具有线程安全能力，或者使用 ConcurrentHashMap。   HashTable：  HashTable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是他继承自 Dictionary 类，并且是线程安全的：  HashTable线程安全的策略实现代价比较大，简单粗暴，get/put所有相关的操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问的时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。    HashTable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换，因为ConcurrentHashMap 采用了分段锁，并发性比 HashTable 要高很多，具体可参考 2.1 实现原理。    LinkedHashMap：  LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。   TreeMap：  TreeMap 实现了 SortedMap 接口，能够把保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的，如果使用排序的映射，建议使用 TreeMap。 在使用 TreeMap 时，key必须实现 Comparable 接口，或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" /><meta property="article:section" content="docs" />



<title>1.2 Hash Map和 Concurrent Hash Map实现原理 | Computer Cookbook School Recruitment</title>
<link rel="manifest" href="/school-recruitment/manifest.json">
<link rel="icon" href="/school-recruitment/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/school-recruitment/book.min.57f7f660871517a5bfcfb5e2de853d806f7e34d94ebd5f3f3bad62e9ddbae209.css" integrity="sha256-V/f2YIcVF6W/z7Xi3oU9gG9&#43;NNlOvV8/O61i6d264gk=" crossorigin="anonymous">
  <script defer src="/school-recruitment/flexsearch.min.js"></script>
  <script defer src="/school-recruitment/en.search.min.7bbd06cb6208fbd8206562c1c0fdb8da9b0a3891a9c03c00c1133212c05fe978.js" integrity="sha256-e70Gy2II&#43;9ggZWLBwP242psKOJGpwDwAwRMyEsBf6Xg=" crossorigin="anonymous"></script>

  <script defer src="/school-recruitment/sw.min.07899fc95e217f83f76b676678ae96a3d8d0d0b042f9f17c3f23eec2551b7b12.js" integrity="sha256-B4mfyV4hf4P3a2dmeK6Wo9jQ0LBC&#43;fF8PyPuwlUbexI=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />

  <a href="https://github.com/wpwbb510582246/ComputerCookbook-SchoolRecruitment" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;z-index: 100;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/school-recruitment/"><span>Computer Cookbook School Recruitment</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://www.grayson.top" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/graysonwp" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






<hr>


  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-353f7a5578fa41dbc42c73ea30fe2255" class="toggle"  />
    <label for="section-353f7a5578fa41dbc42c73ea30fe2255" class="flex justify-between">
      <a role="button" class="">第一章 算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e0c159ebe8e8b165cd558008fb5f5074" class="toggle"  />
    <label for="section-e0c159ebe8e8b165cd558008fb5f5074" class="flex justify-between">
      <a role="button" class="">1、算法框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="toggle"  />
    <label for="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="flex justify-between">
      <a role="button" class="">1.1 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" class="">1.1.1 斐波那契数列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="">1.1.2 背包问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="">1.1.3 贪心算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.4 最长递增子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" class="">1.1.5 编辑距离</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/" class="">1.1.6 高楼扔鸡蛋</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.7 最长回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" class="">1.1.8 最大子序和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/" class="">1.1.9 股票问题系列通解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/" class="">1.1.10 最长重复子数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/" class="">1.1.11 最长有效括号</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e36081c41f3a4d8d8355cae83c46c9b8" class="toggle"  />
    <label for="section-e36081c41f3a4d8d8355cae83c46c9b8" class="flex justify-between">
      <a role="button" class="">1.2 二分查找</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/" class="">1.2.1 二分查找框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">1.2.2 搜索旋转排序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="">1.2.3 如何运用二分查找算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ac9691c4865fdec0880b3cb638bc594" class="toggle"  />
    <label for="section-2ac9691c4865fdec0880b3cb638bc594" class="flex justify-between">
      <a role="button" class="">1.3 数据结构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">1.3.1 反转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" class="">1.3.2 数组中的第k个最大元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="">1.3.3 二叉树的最近公共祖先</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c6359aa6ff642b64a85093d9888f8ad" class="toggle"  />
    <label for="section-6c6359aa6ff642b64a85093d9888f8ad" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="">1.4 排序算法</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b9f975ded87a304ee48569c44f19492" class="toggle"  />
    <label for="section-9b9f975ded87a304ee48569c44f19492" class="flex justify-between">
      <a role="button" class="">1.5 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">1.5.1 二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/" class="">1.5.2 岛屿问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.3 平衡二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="">1.5.4 二叉树路径问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.5 构造二叉树</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4571e95d0021653ce2d27ee4b0838ca0" class="toggle"  />
    <label for="section-4571e95d0021653ce2d27ee4b0838ca0" class="flex justify-between">
      <a role="button" class="">1.6 回溯算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/" class="">1.6.1 回溯算法解题框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-N%E7%9A%87%E5%90%8E/" class="">1.6.2 N皇后</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8b579ed4452b6a8d2017a24343689b5c" class="toggle"  />
    <label for="section-8b579ed4452b6a8d2017a24343689b5c" class="flex justify-between">
      <a role="button" class="">2、高频面试题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5a653711e83b11abc9ab6143b1a9fd64" class="toggle"  />
    <label for="section-5a653711e83b11abc9ab6143b1a9fd64" class="flex justify-between">
      <a role="button" class="">2.1 数学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/" class="">2.1.1 快速模幂算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/" class="">2.1.2 搜索二维矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="">2.1.3 螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" class="">2.1.4 X 的平方根</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5c279474332677699cd0b53888bd51ba" class="toggle"  />
    <label for="section-5c279474332677699cd0b53888bd51ba" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="">2.2 二分查找</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e057e8659d2f838952397ed15d20f46c" class="toggle"  />
    <label for="section-e057e8659d2f838952397ed15d20f46c" class="flex justify-between">
      <a role="button" class="">2.3 数组</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="">2.3.1 删除有序数组中的重复项</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/" class="">2.3.2 找出数组游戏的赢家</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.4 如何寻找消失的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.5 如何寻找缺失和重复的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E6%9C%80%E5%A4%A7%E6%95%B0/" class="">2.3.6 最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="">2.3.7 二维数组中的查找</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.8 两数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.9 三数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">2.3.10 合并两个有序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.11-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/" class="">2.3.11 下一个排列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.12-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/" class="">2.3.12 缺失的第一个正数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.13-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="">2.3.13 寻找两个正序数组的中位数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.14-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" class="">2.3.14 多数元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.15-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" class="">2.3.15 最长连续序列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="toggle"  />
    <label for="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="flex justify-between">
      <a role="button" class="">2.4 字符串</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">2.4.1 构造 K 个回文字符串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/" class="">2.4.2 如何寻找最 回 串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/" class="">2.4.3 如何判定括号的合法性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/" class="">2.4.4 字符串转换整数 (Atoi)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">2.4.5 长度为3的不同回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="">2.4.6 无重复字符的最长子串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/" class="">2.4.7 字符串相加</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/" class="">2.4.8 翻转字符串里的单词</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c2cc4653d849ecb4e8d0df9162693740" class="toggle"  />
    <label for="section-c2cc4653d849ecb4e8d0df9162693740" class="flex justify-between">
      <a role="button" class="">2.5 链表</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/" class="">2.5.1 环形链表 Ii</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" class="">2.5.2 如何高效判断回文链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">2.5.3 K 个一组翻转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="">2.5.4 相交链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" class="">2.5.5 链表中倒数第k个节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="">2.5.6 合并 K个升序链表</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-95a636b3d00f4ce42d96beeef34d9742" class="toggle"  />
    <label for="section-95a636b3d00f4ce42d96beeef34d9742" class="flex justify-between">
      <a role="button" class="">2.6 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/" class="">2.6.1 在二叉树中分配硬币</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="">2.6.2 将有序数组转换为二叉搜索树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">2.6.4 重建二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="">2.6.5 二叉树中的最大路径和</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2dca4a28932da6fd2ab80d6adf86f380" class="toggle"  />
    <label for="section-2dca4a28932da6fd2ab80d6adf86f380" class="flex justify-between">
      <a role="button" class="">2.7 队列</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" class="">2.7.1 用栈实现队列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9868fca37e026543bb4220219b385440" class="toggle"  />
    <label for="section-9868fca37e026543bb4220219b385440" class="flex justify-between">
      <a role="button" class="">2.8 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/" class="">2.8.1 如何高效解决接雨水问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/" class="">2.8.2 最少侧跳次数</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2b868ec58580c16b57b76d0e583b5ec9" class="toggle"  />
    <label for="section-2b868ec58580c16b57b76d0e583b5ec9" class="flex justify-between">
      <a role="button" class="">2.9 设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/" class="">2.9.1 实现 Trie (前缀树)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="">2.9.2 Lru 缓存机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0922907dd56f7a4a192db7338c0e7143" class="toggle"  />
    <label for="section-0922907dd56f7a4a192db7338c0e7143" class="flex justify-between">
      <a role="button" class="">第二章 计算机基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e090ea075956ea0a88f3be27eb8b8174" class="toggle"  />
    <label for="section-e090ea075956ea0a88f3be27eb8b8174" class="flex justify-between">
      <a role="button" class="">1、计算机网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-043e7911fd2d67fbc52b823c1516a0d8" class="toggle"  />
    <label for="section-043e7911fd2d67fbc52b823c1516a0d8" class="flex justify-between">
      <a role="button" class="">1.1 传输层： Tcp和 UDP</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="">1.1.1 三次握手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="">1.1.2 四次挥手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="">1.1.3 流量控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="">1.1.5 拥塞控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1.6 Tcp和 Udp的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="">1.1.7 Tcp如何保证传输的可靠性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" class="">1.1.8 Tcp长连接和短连接</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="toggle"  />
    <label for="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="flex justify-between">
      <a role="button" class="">1.2 应用层：HTTP和HTTPS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.1 Http和 HTTP S的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.2 Get和 Post的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.3 Session与 Cookie的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/" class="">1.2.4 从输入网址到获得页面的过程（越详细越好）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/" class="">1.2.5 Http请求有哪些常见的状态码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="">1.2.6 什么是 Rip，算法是什么</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/" class="">1.2.7 Http1.0、 Http1.1和 Http2.0的主要区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/" class="">1.2.8 DNS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" class="">1.2.9 HTTP S加密和认证过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" class="">1.2.10 常见网络攻击</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/" class="">1.2.11 Rest</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3-%E8%AE%A1%E7%AE%97%E5%85%B6%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="">1.3 计算其网络体系结构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="toggle"  />
    <label for="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="flex justify-between">
      <a role="button" class="">1.4 网络层协议</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" class="">1.4.1 Ip地址的分类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/" class="">1.4.2 划分子网</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/" class="">1.4.3 什么是 Arp协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/" class="">1.4.4 Nat协议</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-09f7d8995bc26810475d1c56597a312e" class="toggle"  />
    <label for="section-09f7d8995bc26810475d1c56597a312e" class="flex justify-between">
      <a role="button" class="">2、操作系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2f767bf946d6dc8ddeda6b6435471e5b" class="toggle"  />
    <label for="section-2f767bf946d6dc8ddeda6b6435471e5b" class="flex justify-between">
      <a role="button" class="">2.1 进程和线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.1.1 进程和线程的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="">2.1.2 进程间通信方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="">2.1.3 进程同步问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/" class="">2.1.4 进程有哪几种状态</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" class="">2.1.5 进程调度策略</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" class="">2.1.6 僵尸进程和孤儿进程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="">2.1.7 线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/" class="">2.1.8 协程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="">2.1.9 异常控制流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="">2.1.10 Io多路复用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/" class="">2.1.11 用户态和内核态</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.2-%E6%AD%BB%E9%94%81/" class="">2.2 死锁</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b2b1a78994c9898abed1b08fef134abd" class="toggle"  />
    <label for="section-b2b1a78994c9898abed1b08fef134abd" class="flex justify-between">
      <a role="button" class="">2.3 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/" class="">2.3.1 分页和分段</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="">2.3.2 虚拟内存</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="">2.3.3 页面置换算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/" class="">2.3.4 局部性原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="">2.3.5 缓冲区溢出</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/" class="">2.4 磁盘调度</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e28cc33fe5745d14abf4a0147d0624a5" class="toggle"  />
    <label for="section-e28cc33fe5745d14abf4a0147d0624a5" class="flex justify-between">
      <a role="button" class="">第三章 数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6fd3cab540793410b1ce567d790deadc" class="toggle"  />
    <label for="section-6fd3cab540793410b1ce567d790deadc" class="flex justify-between">
      <a role="button" class="">1、数据库基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/" class="">1.1 事务的概念和特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/" class="">1.2 锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/" class="">1.3 锁协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/" class="">1.4 事务日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.5 Mvcc实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12290256fbd76ac6014c39648c5827fe" class="toggle"  />
    <label for="section-12290256fbd76ac6014c39648c5827fe" class="flex justify-between">
      <a role="button" class="">1.6 基础知识</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/" class="">1.6.1 三范式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" class="">1.6.2 多表连接方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="">1.6.3 存储过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.6.4 Delete、 Truncate和 Drop的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/" class="">1.6.5 触发器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/" class="">1.6.6 视图</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d1b14978df09adfe15777e58b9b435ec" class="toggle"  />
    <label for="section-d1b14978df09adfe15777e58b9b435ec" class="flex justify-between">
      <a role="button" class="">2、 My SQL</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/" class="">2.1 索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="">2.2 B 树、 B 树索引算法原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/" class="">2.3 索引组织表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.4 Inno Db和 My Isam的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/" class="">2.5 Checkpoint技术</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/" class="">2.6 宕机恢复原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="">2.7 数据库优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="">2.8 分库分表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="">2.9 一致性哈希算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="">2.10 主从复制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-53f351d3e26dfa58c34e937b76a0c4ce" class="toggle"  />
    <label for="section-53f351d3e26dfa58c34e937b76a0c4ce" class="flex justify-between">
      <a role="button" class="">3、 Redis</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-356f36d039b40fdb10be19d36f2f2793" class="toggle"  />
    <label for="section-356f36d039b40fdb10be19d36f2f2793" class="flex justify-between">
      <a role="button" class="">3.1 概述</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/" class="">3.1.1 Redis为什么这么快</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="">3.1.2 Redis数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="">3.1.3 持久化机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="">3.1.4 过期机制和内存淘汰策略</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.2-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="">3.2 线程模型</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4731e97839509d5614da88af39acf326" class="toggle"  />
    <label for="section-4731e97839509d5614da88af39acf326" class="flex justify-between">
      <a role="button" class="">3.3 分布式问题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="">3.3.1 Redis实现分布式锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-555105a060edfd5dfac44ac6d49d31e5" class="toggle"  />
    <label for="section-555105a060edfd5dfac44ac6d49d31e5" class="flex justify-between">
      <a role="button" class="">3.4 缓存异常</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" class="">3.4.1 缓存穿透、缓存击穿、缓存雪崩</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f0d841e400bf38796a65a65ef72b420e" class="toggle"  />
    <label for="section-f0d841e400bf38796a65a65ef72b420e" class="flex justify-between">
      <a role="button" class="">第四章 设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/" class="">1、概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e796a2fc1bf6b4e9454f5a191dd15040" class="toggle"  />
    <label for="section-e796a2fc1bf6b4e9454f5a191dd15040" class="flex justify-between">
      <a role="button" class="">2、创建型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="">2.1 单例模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="">2.2 工厂模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="toggle"  />
    <label for="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="flex justify-between">
      <a role="button" class="">3、结构型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="">3.1 代理模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="">3.2 装饰器模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0f94fb8c7e53c880650621fdcc596283" class="toggle"  />
    <label for="section-0f94fb8c7e53c880650621fdcc596283" class="flex justify-between">
      <a role="button" class="">4、行为型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/4%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="">4.1 策略模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-eca69da21de5b0cd25d8421dec09a327" class="toggle" checked />
    <label for="section-eca69da21de5b0cd25d8421dec09a327" class="flex justify-between">
      <a role="button" class="">第五章 Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a64d861c08691e8f06f1178d4d28cf04" class="toggle" checked />
    <label for="section-a64d861c08691e8f06f1178d4d28cf04" class="flex justify-between">
      <a role="button" class="">1、 Java基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1 String、 String Buffer和 String Builder的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class=" active">1.2 Hash Map和 Concurrent Hash Map实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.3 Array List和 Linked List实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="">1.4 深拷贝与浅拷贝</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="toggle"  />
    <label for="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="flex justify-between">
      <a role="button" class="">2、 Java多线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" class="">2.1 并发编程的三大特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" class="">2.2 指令重排</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Volatile%E5%8E%9F%E7%90%86/" class="">2.3 Volatile原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-CAS%E5%8E%9F%E7%90%86/" class="">2.4 Cas原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/" class="">2.5 Java的4种引用级别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="">2.6 Java中的锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.7 Synchronized实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.8 线程池实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-AQS/" class="">2.9 Aqs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65e183c484720f91ba3d1676e1ed5a16" class="toggle"  />
    <label for="section-65e183c484720f91ba3d1676e1ed5a16" class="flex justify-between">
      <a role="button" class="">3、 Jvm</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" class="">3.1 运行时数据区域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/" class="">3.2 判断对象是否存活的方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="">3.3 垃圾收集算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="">3.4 类的生命周期和加载过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/" class="">3.5 类加载时机</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="">3.6 类加载器的种类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/" class="">3.7 类加载机制的特点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="">3.8 Jvm内存结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.9 常见的垃圾收集算法有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/" class="">3.10 指针碰撞和空闲列表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.11 常见的垃圾收集器有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">3.12 内存溢出与内存泄漏的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.13 常用的 Jvm启动参数有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="">3.14 反射机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-78e3fdb9e302e0ddb1abf0723557c671" class="toggle"  />
    <label for="section-78e3fdb9e302e0ddb1abf0723557c671" class="flex justify-between">
      <a role="button" class="">4、 Nio</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/4NIO/4.1-%E6%A6%82%E8%BF%B0/" class="">4.1 概述</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="toggle"  />
    <label for="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="flex justify-between">
      <a role="button" class="">第六章 Spring全家桶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-afe35ec73fb23fd24d05388dd4f6d178" class="toggle"  />
    <label for="section-afe35ec73fb23fd24d05388dd4f6d178" class="flex justify-between">
      <a role="button" class="">1、 Spring</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/" class="">1.1 概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/" class="">1.2 Spring Ioc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/" class="">1.3 Spring Aop</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b63cda05fe80f821d31813480ebd8acb" class="toggle"  />
    <label for="section-b63cda05fe80f821d31813480ebd8acb" class="flex justify-between">
      <a role="button" class="">2、 Spring Boot</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/2SpringBoot/2.1-SpringSpringBootSpringCloud%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/" class="">2.1 Spring、 Spring Boot、 Spring Cloud的联系与区别</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/school-recruitment/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>1.2 Hash Map和 Concurrent Hash Map实现原理</strong>

  <label for="toc-control">
    
    <img src="/school-recruitment/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"> </script>
  <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })</script>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#hashmap和concurrenthashmap实现原理">HashMap和ConcurrentHashMap实现原理</a>
      <ul>
        <li><a href="#1-hashmap">1 HashMap</a>
          <ul>
            <li><a href="#11-简介">1.1 简介</a></li>
            <li><a href="#12-内部实现">1.2 内部实现</a>
              <ul>
                <li><a href="#121-存储结构">1.2.1 存储结构</a></li>
                <li><a href="#122-功能实现">1.2.2 功能实现</a>
                  <ul>
                    <li><a href="#1221-确定哈希桶数组索引位置">1.2.2.1 确定哈希桶数组索引位置</a></li>
                    <li><a href="#1322-put-方法的执行原理">1.3.2.2 put 方法的执行原理</a></li>
                    <li><a href="#1223-扩容机制">1.2.2.3 扩容机制</a></li>
                    <li><a href="#1224-线程安全性">1.2.2.4 线程安全性</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#13-hashmap-在-jdk-17-和-jdk-18-之间的区别">1.3 HashMap 在 JDK 1.7 和 JDK 1.8 之间的区别</a></li>
          </ul>
        </li>
        <li><a href="#2-concurrenthashmap">2 ConcurrentHashMap</a>
          <ul>
            <li><a href="#21-实现原理">2.1 实现原理</a>
              <ul>
                <li><a href="#211-segment">2.1.1 Segment</a></li>
                <li><a href="#212-构造方法">2.1.2 构造方法</a></li>
                <li><a href="#213-get-方法">2.1.3 get 方法</a></li>
                <li><a href="#214-put-方法">2.1.4 put 方法</a></li>
              </ul>
            </li>
            <li><a href="#22-jdk-18中的concurrenthashmap">2.2 JDK 1.8中的ConcurrentHashMap</a>
              <ul>
                <li><a href="#221-与jdk-17中的concurrenthashmap的区别">2.2.1 与JDK 1.7中的ConcurrentHashMap的区别</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="hashmap和concurrenthashmap实现原理">
  HashMap和ConcurrentHashMap实现原理
  <a class="anchor" href="#hashmap%e5%92%8cconcurrenthashmap%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h1>
<h2 id="1-hashmap">
  1 HashMap
  <a class="anchor" href="#1-hashmap">#</a>
</h2>
<h3 id="11-简介">
  1.1 简介
  <a class="anchor" href="#11-%e7%ae%80%e4%bb%8b">#</a>
</h3>
<ol>
<li>Java 为数据结构中的映射定义了一个接口<code>java.util.Map</code>，此接口主要有四个常用的实现类，分别是<strong>HashMap</strong>、<strong>HashTable</strong>、<strong>LinkedHashMap</strong>和<strong>TreeMap</strong>，类继承关系如下图所示：
  <img src="../../media/202107/2021-07-28_1649030.15704050584702112.png" alt="" /></li>
<li>下面针对各个实现类的特点做一些说明：
<ol>
<li><strong>HashMap</strong>：
<ol>
<li><strong>根据键的 <code>hashCode</code> 值存储数据</strong>，<strong>大多数情况下可以直接定位到他的值</strong>，<strong>因而具有很快的访问速度</strong>，<strong>但遍历顺序却是不确定的</strong>。</li>
<li><strong>最多只允许一条记录的键为 <code>null</code></strong>，<strong>允许多条记录为 <code>null</code></strong>。</li>
<li><strong>非线程安全</strong>，<strong>任一时刻可以有多个线程同时写 HashMap</strong>，<strong>可能会导致数据的不一致</strong>。</li>
<li><strong>如果需要满足线程安全</strong>，<strong>可以用 Collections 的 <code>synchronizedMap()</code> 方法</strong>（该方法也是使用一个全局锁来同步多个线程间的并发访问）<strong>使 HashMap 具有线程安全能力</strong>，<strong>或者使用 ConcurrentHashMap</strong>。</li>
</ol>
</li>
<li><strong>HashTable</strong>：
<ol>
<li><strong>HashTable 是遗留类</strong>，<strong>很多映射的常用功能与 HashMap 类似</strong>，<strong>不同的是他继承自 Dictionary 类</strong>，<strong>并且是线程安全的</strong>：
<ol>
<li>HashTable<strong>线程安全的策略实现代价比较大</strong>，简单粗暴，<code>get/put</code><strong>所有相关的操作都是 <code>synchronized</code> 的</strong>，这<strong>相当于给整个哈希表加了一把大锁</strong>，<strong>多线程访问的时候</strong>，<strong>只要有一个线程访问或操作该对象</strong>，<strong>那其他线程只能阻塞</strong>，<strong>相当于将所有的操作串行化</strong>，<strong>在竞争激烈的并发场景中性能就会非常差</strong>。
  <img src="../../media/202107/2021-07-29_1707350.2864095646869024.png" alt="" /></li>
</ol>
</li>
<li><strong>HashTable 不建议在新代码中使用</strong>，<strong>不需要线程安全的场合可以用 HashMap 替换</strong>，<strong>需要线程安全的场合可以用 ConcurrentHashMap 替换</strong>，因为<strong>ConcurrentHashMap 采用了分段锁</strong>，<strong>并发性比 HashTable 要高很多</strong>，具体可参考
  <a href="/school-recruitment/#2-1-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">2.1 实现原理</a>。
  <img src="../../media/202107/2021-07-29_1710410.7268898193128783.png" alt="" /></li>
</ol>
</li>
<li><strong>LinkedHashMap</strong>：
<ol>
<li><strong>LinkedHashMap 是 HashMap 的一个子类</strong>，<strong>保存了记录的插入顺序</strong>，<strong>在用 Iterator 遍历 LinkedHashMap 时</strong>，<strong>先得到的记录肯定是先插入的</strong>，<strong>也可以在构造时带参数</strong>，<strong>按照访问次序排序</strong>。</li>
</ol>
</li>
<li><strong>TreeMap</strong>：
<ol>
<li><strong>TreeMap 实现了 SortedMap 接口</strong>，<strong>能够把保存的记录根据键排序</strong>，<strong>默认是按键值的升序排序</strong>，<strong>也可以指定排序的比较器</strong>，<strong>当用 Iterator 遍历 TreeMap 时</strong>，<strong>得到的记录是排过序的</strong>，<strong>如果使用排序的映射</strong>，<strong>建议使用 TreeMap</strong>。</li>
<li><strong>在使用 TreeMap 时</strong>，<code>key</code><strong>必须实现 Comparable 接口</strong>，<strong>或者在构造 TreeMap 传入自定义的 Comparator</strong>，<strong>否则会在运行时抛出 <code>java.lang.ClassCastException</code> 类型的异常</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>对于上述四种 Map 类型的类，要求<strong>映射中的 <code>key</code> 是不可变对象</strong>，即<strong>该对象在创建后他的哈希值不会被改变</strong>，<strong>如果对象的哈希值发生变化</strong>，<strong>Map 对象很可能就定位不到映射的位置了</strong>。</li>
</ol>
<h3 id="12-内部实现">
  1.2 内部实现
  <a class="anchor" href="#12-%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<h4 id="121-存储结构">
  1.2.1 存储结构
  <a class="anchor" href="#121-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li>
<p>从<strong>结构实现</strong>来讲，HashMap 是<strong>数组</strong>+<strong>链表</strong>+<strong>红黑树</strong>（JDK1.8 增加了红黑树部分）实现的，如下图所示：
  <img src="../../media/202107/2021-07-28_1717200.8508396937310263.png" alt="" /></p>
</li>
<li>
<p>从源码可知，HashMap 类中有一个非常重要的字段，就是 <code>Node&lt;K,V&gt;[] table;</code>，即<strong>哈希桶数组</strong>，他是一个<strong>Node 数组</strong>，Node 是<strong>HashMap 的一个内部类</strong>，<strong>实现了 <code>Map.Entry</code> 接口</strong>，<strong>本质就是一个映射</strong>（键值对），<strong>上图中的每个黑色圆点就是一个 Node 对象</strong>，Node 的源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">final</span> K key<span style="color:#f92672">;</span>
    V value<span style="color:#f92672">;</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>

    Node<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">{...}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> K <span style="color:#a6e22e">getKey</span><span style="color:#f92672">()</span>        <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> key<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span>      <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> key <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;=&#34;</span> <span style="color:#f92672">+</span> value<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{...}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>V newValue<span style="color:#f92672">)</span> <span style="color:#f92672">{...}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{...}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>HashMap 就是<strong>使用哈希表来存储</strong>的，哈希表为<strong>解决冲突</strong>，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>，Java 中<strong>HashMap 采用了链地址法</strong>，即<strong>数组加链表的结合</strong>，<strong>在每个数组元素上都有一个链表结构</strong>，<strong>当数据被 Hash 后</strong>，<strong>得到数组下标</strong>，<strong>把数据放在对应下标元素的链表上</strong>。</p>
</li>
<li>
<p>HashMap 中其他几个字段如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>             <span style="color:#75715e">// 所能容纳的 key-value 对极限 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span>    <span style="color:#75715e">// 负载因子
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span>  
<span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>
</code></pre></div><ol>
<li><code>threshold</code>：
<ol>
<li>HashMap<strong>所能容纳的最大数据量的 Node</strong>（键值对）<strong>的个数</strong>，计算公式为 $threshold = length * loadFactor$，其中 <code>length</code><strong>为 <code>table</code> 的长度</strong>，<strong>默认为 16</strong>，而且<code>length</code><strong>的大小必须为 2 的 $n$ 次方</strong>，主要是<strong>为了在取模和扩容时做优化</strong>，<strong>同时为了减少冲突</strong>，<strong>HashMap 定位哈希桶索引位置时</strong>，<strong>也加入了高位参与运算的过程</strong>。</li>
<li>当 HashMap 中<strong>键值对的数量超过这个数目就需要重新扩容</strong>，<strong>扩容后的 HashMap 容量是之前容量的两倍</strong>。</li>
</ol>
</li>
<li><code>loadFactor</code>：
<ol>
<li><strong>负载因子</strong>，<strong>默认为 0.75</strong>，<strong>该值是对空间和时间效率的一个平衡选择</strong>，<strong>建议不要修改</strong>。</li>
</ol>
</li>
<li><code>modCount</code>：
<ol>
<li>主要用来<strong>记录 HashMap 内部结构发生变化的次数</strong>，<strong>主要用于迭代的快速失败</strong>，其中<strong>内部结构发生变化指的是结构发生变化</strong>，例如<code>put</code> 新键值对，但是某个<code>key</code> 对应的<code>value</code> 值被覆盖不属于结构变化。</li>
</ol>
</li>
<li><code>size</code>：
<ol>
<li>HashMap 中<strong>实际存在的键值对数量</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>即使负载因子和 Hash 算法设计的再合理</strong>，<strong>也免不了出现拉链过长的情况</strong>，<strong>一旦出现拉链过长</strong>，<strong>则会严重影响 HashMap 的性能</strong>，<strong>于是</strong>，<strong>在 JDK1.8 版本中</strong>，<strong>对数据结构做了进一步优化</strong>，<strong>引入了红黑树</strong>，<strong>当链表长度太长</strong>（默认超过 8）<strong>时</strong>，<strong>链表就转化为红黑树</strong>，<strong>利用红黑树快速增删改查的特点提高 HashMap 的性能</strong>。</p>
</li>
</ol>
<h4 id="122-功能实现">
  1.2.2 功能实现
  <a class="anchor" href="#122-%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<p>HashMap 的内部功能实现很多，本文主要从<strong>根据 <code>key</code> 获取哈希桶数组索引位置</strong>、<code>put</code><strong>方法的执行原理</strong>、<strong>扩容机制</strong>三个具有代表性的点深入展开讲解。</p>
<h5 id="1221-确定哈希桶数组索引位置">
  1.2.2.1 确定哈希桶数组索引位置
  <a class="anchor" href="#1221-%e7%a1%ae%e5%ae%9a%e5%93%88%e5%b8%8c%e6%a1%b6%e6%95%b0%e7%bb%84%e7%b4%a2%e5%bc%95%e4%bd%8d%e7%bd%ae">#</a>
</h5>
<ol>
<li>
<p>HashMap 中<strong>使用 Hash 算法确定哈希桶数组索引位置</strong>，具体源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> getNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 方法一：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">// jdk1.8 &amp; jdk1.7
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> h<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  h = key.hashCode()  1. 取 hashCode 值
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  h ^ (h &gt;&gt;&gt; 16)    2. 高位参与运算
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 方法二：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">indexFor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> length<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>      <span style="color:#75715e">//    jdk1.7 的源码，jdk1.8 没有这个方法，但是实现原理一样的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>length<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>  <span style="color:#75715e">//  3. 取模运算
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>这里的 Hash 算法本质上就是三步，分比为<strong>取 <code>key</code> 的 <code>hashCode</code> 值</strong>、<strong>高位运算</strong>、<strong>取模运算</strong>。</p>
</li>
<li>
<p>对于任意给定的对象，<strong>只要他的 <code>hashCode</code> 返回值相同</strong>，那么程序调用方法一所<strong>计算得到的 Hash 码值总是相同的</strong>。</p>
</li>
<li>
<p>对于<strong>索引位置的确定</strong>，我们首先想到的是把 <code>hash</code> 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的，但是<strong>模运算的消耗是比较大的</strong>，在 HashMap 中是<strong>通过调用方法二来计算该对象应该保存在 <code>table</code> 数组的哪个索引处</strong>，<strong>这个方法非常巧妙</strong>，<strong>他通过 <code>h &amp; (length - 1)</code> 来得到该对象的保存位</strong>，而<strong>HashMap 底层数组的长度总是 2 的 $n$ 次方</strong>，此时 <code>h &amp; (length - 1)</code><strong>运算等价于对 <code>length</code> 取模</strong>，<strong>也就是 <code>h % length</code></strong>，但是 <code>&amp;</code><strong>比 <code>%</code> 具有更高的效率</strong>。</p>
</li>
<li>
<p>在 JDK 1.8 的实现中，<strong>优化了高位运算的算法</strong>，<strong>通过 <code>hashCode</code> 的高 16 为异或低 16 位实现的</strong>，即 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这样做<strong>可以在数组 <code>table</code> 的长度比较小的时候</strong>，<strong>也能保证到高低 <code>bit</code> 都参与到 Hash 的计算中</strong>，<strong>同时不会有太大的开销</strong>，具体示例如下：</p>
<p>
  <img src="../../media/202107/2021-07-29_1028090.24429923051565483.png" alt="" /></p>
</li>
</ol>
<h5 id="1322-put-方法的执行原理">
  1.3.2.2 put 方法的执行原理
  <a class="anchor" href="#1322-put-%e6%96%b9%e6%b3%95%e7%9a%84%e6%89%a7%e8%a1%8c%e5%8e%9f%e7%90%86">#</a>
</h5>
<ol>
<li>
<p>HashMap 的 <code>put</code> 方法执行过程如下图所示：
  <img src="../../media/202107/2021-07-29_1051260.7361479512008406.png" alt="" /></p>
<ol>
<li><strong>判断键值对数组 <code>table[i]</code> 是否为空或 <code>null</code></strong>，<strong>如果是的话</strong>，<strong>则对 HashMap 进行扩容</strong>。</li>
<li><strong>根据键值 <code>key</code> 计算 <code>hash</code> 值得到插入的数组索引 <code>i</code></strong>：
<ol>
<li><strong>如果 <code>table[i] == null</code></strong>，<strong>直接新建节点添加</strong>，<strong>然后转向 6</strong>。</li>
<li><strong>否则</strong>，<strong>转向 3</strong>。</li>
</ol>
</li>
<li><strong>判断 <code>table[i]</code> 的首个元素是否和 <code>key</code> 一样</strong>：
<ol>
<li><strong>如果相同</strong>（<code>hashCode</code> 和<code>equals</code> 值均相同），<strong>直接覆盖 <code>value</code></strong>。</li>
<li><strong>否则</strong>，<strong>转向 4</strong>。</li>
</ol>
</li>
<li><strong>判断 <code>table[i]</code> 是否为 TreeNode</strong>，<strong>即红黑树</strong>：
<ol>
<li><strong>如果是红黑树</strong>，<strong>则直接在树中插入键值对</strong>。</li>
<li><strong>否则</strong>，<strong>转向 5</strong>。</li>
</ol>
</li>
<li><strong>遍历 <code>table[i]</code></strong>，<strong>判断链表长度是否大于 8</strong>：
<ol>
<li><strong>如果大于 8 的话</strong>，<strong>则把链表转换为红黑树</strong>，<strong>然后在红黑树中执行插入操作</strong>。</li>
<li><strong>否则</strong>，<strong>进行链表的插入操作</strong>，<strong>遍历过程中</strong>，<strong>如果发现 <code>key</code> 已经存在</strong>，<strong>则直接覆盖 <code>value</code> 即可</strong>。</li>
</ol>
</li>
<li><strong>插入成功后</strong>，<strong>判断实际存在的键值对数量</strong><code>size</code><strong>是否超过了最大容量</strong><code>threshold</code>：
<ol>
<li><strong>如果超过了</strong>，<strong>则进行扩容</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>JDK 1.8 中 HashMap 的 <code>put</code> 方法源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">,</span>
               <span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  1. 判断键值对数组 table 是否为空或者 table 的长度是否为 0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
        <span style="color:#75715e">//  如果是，则对 HashMap 进行扩容
</span><span style="color:#75715e"></span>        n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> resize<span style="color:#f92672">()).</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">//  2. 根据键值 key 计算 hash 值得到插入的数组索引 i，判断 table[i] 是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#75715e">//  如果 table[i] 为空，则创建新的节点
</span><span style="color:#75715e"></span>        tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span> K k<span style="color:#f92672">;</span>
        <span style="color:#75715e">//  3. 判断 table[i] 的首个元素是否和 key 一样（hashCode 和 equals 值均相同）
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
            <span style="color:#75715e">//  如果一样，则直接覆盖 value
</span><span style="color:#75715e"></span>            e <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
        <span style="color:#75715e">//  4. 判断 table[i] 是否为红黑树
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#66d9ef">instanceof</span> TreeNode<span style="color:#f92672">)</span>
            <span style="color:#75715e">//  如果是红黑树，则直接在树中插入键值对
</span><span style="color:#75715e"></span>            e <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>p<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//  5. 遍历 table[i]
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#f92672">;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                    <span style="color:#75715e">//  判断链表长度是否大于 8
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#75715e">// -1 for 1st
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">//  如果链表长度大于 8，则把链表转换为红黑树，在红黑树中执行插入操作
</span><span style="color:#75715e"></span>                        treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> hash<span style="color:#f92672">);</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#75715e">//  进行链表的插入操作，如果 key 已经存在，则直接覆盖 value 即可
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                    <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))))</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                p <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// existing mapping for key
</span><span style="color:#75715e"></span>            V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent <span style="color:#f92672">||</span> oldValue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
            afterNodeAccess<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
    <span style="color:#75715e">//  6. 插入成功之后，判断实际存在的键值对数量 size 是否超过了最大容量 threshold，如果超过，则进行扩容
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>size <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span>
        resize<span style="color:#f92672">();</span>
    afterNodeInsertion<span style="color:#f92672">(</span>evict<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
<h5 id="1223-扩容机制">
  1.2.2.3 扩容机制
  <a class="anchor" href="#1223-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6">#</a>
</h5>
<ol>
<li>
<p>扩容就是<strong>重新计算容量</strong>，当<strong>向 HashMap 对象中不同的添加元素</strong>，而<strong>HashMap 对象内部的数组无法承载更多的元素时</strong>，<strong>对象就需要扩大数组的长度</strong>，<strong>以便能装入更多的元素</strong>，但是<strong>Java 里的数组是无法自动扩容的</strong>，<strong>方法是使用一个新的数组代替已有的容量小的数组</strong>，<strong>就像我们用一个小桶装水</strong>，<strong>如果想装更多的水</strong>，<strong>就得换大水桶</strong>。</p>
</li>
<li>
<p>下面我们分析下 <code>resize</code> 的源码，因为 JDK 1.8 融入了红黑树，较复杂，为了便于理解，我们仍使用 JDK 1.7 的源码，这样好理解一些，本质上区别不大，具体区别后文再说：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">/*传入新的容量*/</span>
    Entry<span style="color:#f92672">[]</span> oldTable <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>   <span style="color:#75715e">/*引用扩容前的 Entry 数组*/</span>
    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> oldTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">==</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">/*扩容前的数组大小如果已经达到最大（2^30）了*/</span>
        threshold <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>  <span style="color:#75715e">/*修改阈值为 int 的最大值（2^31 - 1），这样以后就不会扩容了*/</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    Entry<span style="color:#f92672">[]</span> newTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>  <span style="color:#75715e">/*初始化一个新的 Entry 数组*/</span>
    <span style="color:#66d9ef">boolean</span> oldAltHashing <span style="color:#f92672">=</span> useAltHashing<span style="color:#f92672">;</span>
    useAltHashing <span style="color:#f92672">|=</span> sun<span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">VM</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isBooted</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&gt;=</span> Holder<span style="color:#f92672">.</span><span style="color:#a6e22e">ALTERNATIVE_HASHING_THRESHOLD</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">boolean</span> rehash <span style="color:#f92672">=</span> oldAltHashing <span style="color:#f92672">^</span> useAltHashing<span style="color:#f92672">;</span>
    transfer<span style="color:#f92672">(</span>newTable<span style="color:#f92672">,</span> rehash<span style="color:#f92672">);</span> <span style="color:#75715e">/*将数据转移到新的 Entry 数组里*/</span>
    table <span style="color:#f92672">=</span> newTable<span style="color:#f92672">;</span>   <span style="color:#75715e">/*HashMap 的 table 属性引用新的 Entry 数组*/</span>
    threshold <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">,</span> MAXIMUM_CAPACITY <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>  <span style="color:#75715e">/*修改阈值*/</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里就是<strong>使用一个容量更大的数组来代替已有的容量小的数组</strong>，<code>transfer()</code><strong>方法将原有 <code>Entry</code> 数组的元素拷贝到新的 <code>Entry</code> 数组里</strong>，具体源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">5void <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Entry<span style="color:#f92672">[]</span> newTable<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> newTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">:</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*遍历旧的 Entry 数组*/</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> hash<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>  <span style="color:#75715e">/*重新计算每个元素在数组中的位置*/</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>   <span style="color:#75715e">/*标记*/</span>
            newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>    <span style="color:#75715e">/*将元素放在数组上*/</span>
            e <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>   <span style="color:#75715e">/*访问下一个 Entry 链上的元素*/</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>newTable[i]</code> 的引用赋给了 <code>e.next</code>，也就是<strong>使用了单链表的头插入方式</strong>，<strong>同一位置上新元素总会被放在链表的头部位置</strong>，这样<strong>先放在一个索引上的元素终会被放到 <code>Entry</code> 链的尾部</strong>（如果发生了 <code>hash</code> 冲突的话），这一点和 JDK 1.8 有区别，下文讲解，<strong>在旧数组中同一条 <code>Entry</code> 链上的元素</strong>，<strong>通过重新计算索引位置后</strong>，<strong>有可能被放到了新数组的不同位置上</strong>。</p>
</li>
<li>
<p>下面举个例子说明下扩容过程，假设我们的 <code>hash</code> 算法就是简单的用 <code>key</code> 去 <code>mod</code> 一下表的大小（也就是数组的长度），负载因子 <code>loadFactor</code> 为 1，即当键值对的实际大小 <code>size</code> 大于 <code>table</code> 的实际大小时进行扩容，具体的过程如下图所示：</p>
<p>
  <img src="../../media/202107/2021-07-29_1137300.5816776400600694.png" alt="" /></p>
</li>
<li>
<p>下面我们讲解下 JDK 1.8 做了哪些优化：</p>
<ol>
<li>
<p>经过观测可以发现，我们使用的是<strong>2 次幂的扩展</strong>（指长度扩展为原来的 2 倍），所以，<strong>元素的位置要么是在原位置</strong>，<strong>要么是在原位置再移动 2 次幂的位置</strong>，看下图就可以明白这个意思，$n$ 为 <code>table</code> 的长度，图（a）表示扩容前的 <code>key1</code> 和 <code>key2</code> 两种 <code>key</code> 确定索引位置的示例，图（b）表示扩容后 <code>key1</code> 和 <code>key2</code> 两种 <code>key</code> 确定索引位置的示例，其中 <code>hash1</code> 是 <code>key1</code> 对应的哈希与高位运算结果：
  <img src="../../media/202107/2021-07-29_1436240.5522429648167162.png" alt="" /></p>
</li>
<li>
<p>元素在重新计算 <code>hash</code> 之后，因为 $n$<strong>变为 2 倍</strong>，那么 $n-1$<strong>的 <code>mask</code> 范围在高位多 1bit</strong>（红色），因此，<strong>新的 <code>index</code> 就会发生这样的变化</strong>：
  <img src="../../media/202107/2021-07-29_1439560.29372264905797085.png" alt="" /></p>
</li>
<li>
<p>因此，我们<strong>在扩充 HashMap 的时候</strong>，<strong>不需要像 JDK 1.7 那样重新计算 <code>hash</code></strong>，<strong>只需要看看原来的 <code>hash</code> 值新增的那个 <code>bit</code> 是 1 还是 0 就好了</strong>，<strong>如果是 0 的话</strong>，<strong>索引没变</strong>，<strong>如果是 1 的话</strong>，<strong>索引变成原索引 + 扩容前 HashMap 的容量</strong>，下图为 16 扩充为 32 的扩容示意图：
  <img src="../../media/202107/2021-07-29_1446130.0976090829432632.png" alt="" /></p>
</li>
<li>
<p>这个设计确实非常巧妙，既<strong>省去了重新计算 <code>hash</code> 值的时间</strong>，而且同时，由于<strong>新增的 1bit 是 0 还是 1 可以认为是随机的</strong>，因此<strong>扩容的过程中</strong>，<strong>均匀的把之前冲突的节点分散到新的桶中了</strong>，<strong>这一块就是 JDK 1.8 新增的优化点</strong>。</p>
</li>
<li>
<p>有一点需要注意的是，<strong>JDK 1.7 中 <code>rehash</code> 的时候</strong>，<strong>如果在新表的数组的索引位置相同</strong>，则<strong>链表元素会倒置</strong>，但是从上图可以看出，<strong>JDK 1.8 不会倒置</strong>。</p>
<blockquote>
<p>为什么 HashMap 的数组长度一定是 2 的次幂？</p>
<ol>
<li>这样可以<strong>保证扩容后与原容量相比只有一位差异</strong>，例如：
<ol>
<li>假设初始 HashMap 的长度 $length$ 为 16，用二进制表示为 10000，则 $length - 1$ 为 15，用二进制表示为 01111。</li>
<li>扩容后数组的长度 $newLength$ 为 32，用二进制表示为 100000，则 $newLength - 1$ 为 011111。</li>
<li>这样可以保证最低位全为 1，而且扩容后只有一位差异，也就是最左位的 1。</li>
</ol>
</li>
<li>这样既<strong>省去了重新计算 <code>hash</code> 的时间</strong>，同时<strong>可以把之前冲突的节点均匀的分散到新的桶中</strong>，具体的原因可以参考
  <a href="/school-recruitment/#1-3-2-3-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6">1.3.2.3 扩容机制</a>中第 4 点的描述。
  <img src="../../media/202107/2021-07-29_1528120.7520437480289052.png" alt="" /></li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<h5 id="1224-线程安全性">
  1.2.2.4 线程安全性
  <a class="anchor" href="#1224-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7">#</a>
</h5>
<ol>
<li>在多线程使用场景中，应该<strong>尽量避免使用线程不安全的 HashMap</strong>，而<strong>使用线程安全的 ConcurrentHashMap</strong>，因为：
<ol>
<li><strong>HashMap 不是线程安全的</strong>，<strong>在多线程并发的情况下容易发生线程安全问题</strong>，<strong>在进行扩容时也会出现死循环问题</strong>，例如在并发的情况下，线程进行了<code>put</code> 操作，由于某种情况随后<code>sleep</code> 了两秒，在这两秒期间，线程 2 修改了线程 1 之前<code>put</code> 的值，等到线程 1 结束<code>sleep</code> 后再次<code>get</code> 到原来值的时候，就有可能取到的值已经不是原来的值了，就会存在问题。</li>
<li><strong>在并发的多线程使用场景中使用 HashMap 可能会在扩容的时候形成环状链表</strong>，<strong>导致 <code>get</code> 操作时 CPU 空转</strong>。</li>
</ol>
</li>
</ol>
<h3 id="13-hashmap-在-jdk-17-和-jdk-18-之间的区别">
  1.3 HashMap 在 JDK 1.7 和 JDK 1.8 之间的区别
  <a class="anchor" href="#13-hashmap-%e5%9c%a8-jdk-17-%e5%92%8c-jdk-18-%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h3>
<ol>
<li><strong>数据结构</strong>：
<ol>
<li>JDK 1.7 的底层结构是<strong>数组 + 链表</strong>。</li>
<li>JDK 1.8 的底层结构是<strong>数组 + 链表 + 红黑树</strong>，<strong>当单条链表的长度大于 8 时</strong>，<strong>将链表转换为红黑树</strong>，<strong>然后插入键值对</strong>。</li>
</ol>
</li>
<li><strong>扩容机制</strong>：
<ol>
<li>JDK 1.7 为<strong>先判断是否需要扩容</strong>，<strong>再插入</strong>。</li>
<li>JDK 1.8 为<strong>先插入</strong>，<strong>再判断是否需要扩容</strong>。</li>
</ol>
</li>
<li><strong>节点插入</strong>：
<ol>
<li>JDK 1.7 为<strong>头插法</strong>，存在<strong>多线程成环</strong>的问题。</li>
<li>JDK 1.8 为<strong>尾插法</strong>，存在<strong>数据丢失</strong>问题。</li>
</ol>
</li>
</ol>
<h2 id="2-concurrenthashmap">
  2 ConcurrentHashMap
  <a class="anchor" href="#2-concurrenthashmap">#</a>
</h2>
<h3 id="21-实现原理">
  2.1 实现原理
  <a class="anchor" href="#21-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h3>
<blockquote>
<p>如无特殊说明，下面关于 ConcurrentHashMap 原理的分析是基于 JDK 1.7 的。</p>
</blockquote>
<h4 id="211-segment">
  2.1.1 Segment
  <a class="anchor" href="#211-segment">#</a>
</h4>
<ol>
<li>
<p>ConcurrentHashMap 采用了非常精妙的<strong>分段锁</strong>策略，COncurrentHashMap 的<strong>主干是个 Segment 数组</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> segments<span style="color:#f92672">;</span>
</code></pre></div><blockquote>
<p>分段锁的优缺点是什么？</p>
<ol>
<li><strong>优点：</strong>
<ol>
<li><strong>保证在操作不同段Map的时候可以并发执行</strong>，<strong>操作同段Map的时候</strong>，<strong>进行锁的竞争和等待</strong>，这<strong>相对于对整个Map同步</strong>（Synchronized）<strong>是有优势的</strong>。</li>
</ol>
</li>
<li><strong>缺点</strong>：
<ol>
<li>分段锁<strong>每个锁控制的是一段</strong>，<strong>当每个Segment越来越大时</strong>，<strong>锁的粒度就变得有些大了</strong>。</li>
<li><strong>分成很多段会比较浪费内存空间</strong>（不连续，碎片化）。</li>
<li>操作Map时<strong>竞争同一个分段锁的概率非常小</strong>，<strong>分段锁反而会造成更新操作的长时间等待</strong>。</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li>
<p>Segment<strong>继承了 ReentrantLock</strong>，所以<strong>他就是一种
  <a href="https://notebook.grayson.top/project-34/doc-531/#2-1-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">可重入锁</a></strong>（ReentrantLock），同时，一个 Segment 就<strong>是一个子哈希表</strong>（一些属性和
  <a href="/school-recruitment/#1-HashMap">HashMap</a>差不多，例如负载因子、阈值），Segment 里<strong>维护了一个 HashEntry 数组</strong>，<strong>并发环境下</strong>，<strong>对于不同 Segment 的数据进行操作是不用考虑锁竞争的</strong>，所以<strong>对于同一个 Segment 的操作才需要考虑线程同步</strong>，<strong>不同的 Segment 则无需考虑</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>  <span style="color:#75715e">/*链表数组，使用 volatile 修饰，保证可见性*/</span>

<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>    <span style="color:#75715e">/*Segment 中元素的个数*/</span>

<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span> <span style="color:#75715e">/*Segment 中可变操作的总次数*/</span>

<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>    <span style="color:#75715e">/*阈值，当 Segment 的大小超过此阈值时，将对其进行 rehash 操作*/</span>

<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span> <span style="color:#75715e">/*负载因子，默认为 0.75*/</span>

Segment<span style="color:#f92672">(</span><span style="color:#66d9ef">float</span> lf<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">,</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactor</span> <span style="color:#f92672">=</span> lf<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">threshold</span> <span style="color:#f92672">=</span> threshold<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">table</span> <span style="color:#f92672">=</span> tab<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
<h4 id="212-构造方法">
  2.1.2 构造方法
  <a class="anchor" href="#212-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95">#</a>
</h4>
<ol>
<li>
<p>我们来看一下 ConcurrentHashMap 的构造方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span>
                         <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> concurrencyLevel<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>loadFactor <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> initialCapacity <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> concurrencyLevel <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>concurrencyLevel <span style="color:#f92672">&gt;</span> MAX_SEGMENTS<span style="color:#f92672">)</span>    <span style="color:#75715e">/*MAX_SEGMENTS 为 1 &lt;&lt; 16 = 65536，即最大并发数为 65536*/</span>
        concurrencyLevel <span style="color:#f92672">=</span> MAX_SEGMENTS<span style="color:#f92672">;</span>
    <span style="color:#75715e">// Find power-of-two sizes best matching arguments
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sshift <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#75715e">/*2 的 sshift 次方等于 ssize，例如 ssize = 16，ssift = 4；ssize = 32，sshit = 5*/</span>
    <span style="color:#66d9ef">int</span> ssize <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">/*ssize 为 segments 数组的长度，根据 concurrentLevel 计算得出*/</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>ssize <span style="color:#f92672">&lt;</span> concurrencyLevel<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#f92672">++</span>sshift<span style="color:#f92672">;</span>
        ssize <span style="color:#f92672">&lt;&lt;=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segmentShift</span> <span style="color:#f92672">=</span> 32 <span style="color:#f92672">-</span> sshift<span style="color:#f92672">;</span>    <span style="color:#75715e">/*segmentShift 和 segmentMask 这两个变量在定位 segment 时会用到，后面会详细讲*/</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segmentMask</span> <span style="color:#f92672">=</span> ssize <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&gt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span>
        initialCapacity <span style="color:#f92672">=</span> MAXIMUM_CAPACITY<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> initialCapacity <span style="color:#f92672">/</span> ssize<span style="color:#f92672">;</span>    <span style="color:#75715e">/*计算 cap 的大小，即 segment 中 HashEntry 的数组长度，cap 也一定为 2 的 n 次方*/</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">*</span> ssize <span style="color:#f92672">&lt;</span> initialCapacity<span style="color:#f92672">)</span>
        <span style="color:#f92672">++</span>c<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> MIN_SEGMENT_TABLE_CAPACITY<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cap <span style="color:#f92672">&lt;</span> c<span style="color:#f92672">)</span>
        cap <span style="color:#f92672">&lt;&lt;=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#75715e">// create segments and segments[0]
</span><span style="color:#75715e"></span>    Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> s0 <span style="color:#f92672">=</span>   <span style="color:#75715e">/*创建 segments 数组并初始化第一个 Segment，其余的 Segment 延迟初始化*/</span>
        <span style="color:#66d9ef">new</span> Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>loadFactor<span style="color:#f92672">,</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)(</span>cap <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">),</span>
                         <span style="color:#f92672">(</span>HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> HashEntry<span style="color:#f92672">[</span>cap<span style="color:#f92672">]);</span>
    Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> ss <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Segment<span style="color:#f92672">[</span>ssize<span style="color:#f92672">];</span>
    UNSAFE<span style="color:#f92672">.</span><span style="color:#a6e22e">putOrderedObject</span><span style="color:#f92672">(</span>ss<span style="color:#f92672">,</span> SBASE<span style="color:#f92672">,</span> s0<span style="color:#f92672">);</span> <span style="color:#75715e">// ordered write of segments[0]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segments</span> <span style="color:#f92672">=</span> ss<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol>
<li>
<p>初始化方法有<strong>三个参数</strong>，分别为 <code>initialCapacity</code>（默认为 16）、<code>loadFactor</code>（默认为 0.75）、<code>concurrencyLevel</code>（默认为 16），如果用户不指定，则会使用默认值。</p>
</li>
<li>
<p><strong>Segment 数组的大小 <code>ssize</code> 是由 <code>concurrencyLevel</code> 决定</strong>，为<strong>大于或等于 <code>concurrencyLevel</code> 的最小的 2 的次幂</strong>，例如，默认情况下 <code>concurrencyLevel</code> 为 16，则 <code>ssize</code> 为 16；若 <code>concurrencyLevel</code> 为 14，则 <code>ssize</code> 为 16；若 <code>concurrencyLevel</code> 为 17，则 <code>ssize</code> 为 32。</p>
<blockquote>
<p>为什么 Segment 的数组大小一定是 2 的次幂？</p>
<ol>
<li>主要是<strong>便于通过按位与的散列算法来定位 Segment 的 Index</strong>，具体可参考
  <a href="https://notebook.grayson.top/project-34/doc-813/#1-2-2-3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">1.2.2.3 扩容机制</a>。</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="213-get-方法">
  2.1.3 get 方法
  <a class="anchor" href="#213-get-%e6%96%b9%e6%b3%95">#</a>
</h4>
<ol>
<li>
<p>ConcurrentHashMap 的 <code>get</code> 方法的源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> s<span style="color:#f92672">;</span> <span style="color:#75715e">// manually integrate access methods to reduce overhead
</span><span style="color:#75715e"></span>    HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">long</span> u <span style="color:#f92672">=</span> <span style="color:#f92672">(((</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> segmentShift<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> segmentMask<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span> SSHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> SBASE<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>s <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>UNSAFE<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectVolatile</span><span style="color:#f92672">(</span>segments<span style="color:#f92672">,</span> u<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>    <span style="color:#75715e">/*先定位到 Segment，再定位到 HashEntry*/</span>
        <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">table</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span> UNSAFE<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectVolatile</span>
                 <span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#f92672">((</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)(((</span>tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> h<span style="color:#f92672">))</span> <span style="color:#f92672">&lt;&lt;</span> TSHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> TBASE<span style="color:#f92672">);</span>
             e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            K k<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">)))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><code>get</code> <strong>方法无需加锁</strong>，由于其中<strong>涉及到的共享变量都使用 
  <a href="https://notebook.grayson.top/project-34/doc-528">volatile</a>修饰</strong>，<code>volatile</code><strong>可以保证内存可见性</strong>，所以<strong>不会读取到过期的数据</strong>。</p>
</li>
</ol>
<h4 id="214-put-方法">
  2.1.4 put 方法
  <a class="anchor" href="#214-put-%e6%96%b9%e6%b3%95">#</a>
</h4>
<ol>
<li>
<p>ConcurrentHashMap 的 <code>put</code> 方法的源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> s<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>  <span style="color:#75715e">/*这里的 value 不能为空*/</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>   <span style="color:#75715e">/*计算 key 的 hash 值*/</span>
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>hash <span style="color:#f92672">&gt;&gt;&gt;</span> segmentShift<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> segmentMask<span style="color:#f92672">;</span>  <span style="color:#75715e">/*根据 hash 值计算待插入对象在 segments 数组中的位置*/</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>s <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>UNSAFE<span style="color:#f92672">.</span><span style="color:#a6e22e">getObject</span>     <span style="color:#75715e">/*检查当前数组中指定位置的 Segment 是否为空，如果为空，则先初始化 Segment 再进行 put，如果不为空，则直接执行 put 操作*/</span>
         <span style="color:#f92672">(</span>segments<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;&lt;</span> SSHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> SBASE<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        s <span style="color:#f92672">=</span> ensureSegment<span style="color:#f92672">(</span>j<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>SegmentShift 和 SegmentMask 主要用来定位 Segment，其中 <code>int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</code>：</p>
<ol>
<li><strong>segmentShift</strong>：
<ol>
<li>2 的<code>sshift</code> 次方等于<code>ssize</code>，<code>segmentShift = 32 - sshift</code>，若<code>segments</code> 的长度为 16，，则<code>segmentShift = 32 - 4 = 28</code>。</li>
<li>计算得出的<code>hash</code> 值最大为 32 位，无符号右移<code>segmentShift</code>，则意味着只保留高几位（其余位是没用的），然后与段掩码进行与运算来定位 Segment。</li>
</ol>
</li>
<li><strong>segmentMask</strong>：
<ol>
<li><strong>段掩码</strong>，等于<code>segments</code> 的长度减 1，即<code>segmentMask = ssize - 1;</code>，若<code>segments</code> 长度为 16，则<code>segmentMask = 16 - 1 = 15</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>从源码可以看出，<code>put</code> 的主要逻辑也就两步：</p>
<ol>
<li>
<p><strong>定位 Segment</strong>，<strong>并确保定位的 Segment 已经初始化</strong>。</p>
</li>
<li>
<p><strong>调用 Segment 的 <code>put</code> 方法</strong>，Segment 的 <code>put</code> 方法源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> node <span style="color:#f92672">=</span> tryLock<span style="color:#f92672">()</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span>    <span style="color:#75715e">/*先获取锁，获取到则返回 null，否则执行 scanAndLockForPut*/</span>
        scanAndLockForPut<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
    V oldValue<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>   <span style="color:#75715e">/*此 table 被 volatile 修饰*/</span>
        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">;</span>    <span style="color:#75715e">/*计算在 HashEntry[] 中的位置*/</span>
        HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first <span style="color:#f92672">=</span> entryAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> index<span style="color:#f92672">);</span> <span style="color:#75715e">/*找到 HashEntry[] 中指定位置的第一个节点，即 first 指向桶中链表的第一个节点*/</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> first<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*如果当前节点不为空，则遍历该链表*/</span>
                K k<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>   <span style="color:#75715e">/*如果之前已经存在了该 key，则用新值替换旧值*/</span>
                    <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                    oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                        <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> <span style="color:#75715e">/*来到下一个节点*/</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">/*如果当前节点为空，则进入 else*/</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    node<span style="color:#f92672">.</span><span style="color:#a6e22e">setNext</span><span style="color:#f92672">(</span>first<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">else</span>
                    node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> first<span style="color:#f92672">);</span> <span style="color:#75715e">/*采用链表的头插法新建一个节点*/</span>
                <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> count <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">/*键值对数量加 1*/</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">&gt;</span> threshold <span style="color:#f92672">&amp;&amp;</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#75715e">/*如果超过阈值则扩容*/</span>
                    rehash<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">else</span>
                    setEntryAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> node<span style="color:#f92672">);</span>   <span style="color:#75715e">/*没有超过阈值的话，则放在指定的位置*/</span>
                <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
                count <span style="color:#f92672">=</span> c<span style="color:#f92672">;</span>
                oldValue <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>    <span style="color:#75715e">/*桶中不存在相同 key 的节点，所以返回 null*/</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        unlock<span style="color:#f92672">();</span>   <span style="color:#75715e">/*解锁操作*/</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>    <span style="color:#75715e">/*put 成功，则返回旧值*/</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol>
<li>
<p>首先会<strong>尝试获取锁</strong>，<strong>如果获取失败则肯定有其他线程存在竞争</strong>，<strong>则利用 <code>scanAndLockForPut</code> 自旋获取锁</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> node <span style="color:#f92672">=</span> tryLock<span style="color:#f92672">()</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> scanAndLockForPut<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">scanAndLockForPut</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first <span style="color:#f92672">=</span> entryForHash<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> hash<span style="color:#f92672">);</span>    <span style="color:#75715e">/*通过 Segment 和 hash 寻找匹配的 HashEntry*/</span>
    HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> first<span style="color:#f92672">;</span>
    HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> retries <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> <span style="color:#75715e">// 重试次数   negative while locating node
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>tryLock<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*不断循环，尝试获取锁*/</span>
        HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#75715e">// to recheck first below
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>retries <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*之前表中不存在当前 key*/</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#75715e">// speculatively create node
</span><span style="color:#75715e"></span>                    node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>  <span style="color:#75715e">/*新增一个节点*/</span>
                retries <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>    <span style="color:#75715e">/*将重试次数置为 0*/</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">))</span>
                retries <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">else</span>
                e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> <span style="color:#75715e">/*第一个节点也不是，则继续来到下一个节点*/</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>retries <span style="color:#f92672">&gt;</span> MAX_SCAN_RETRIES<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">/*尝试次数大于了最大次数（64）的话，则改为阻塞式获取，保证能获取成功*/</span>
            lock<span style="color:#f92672">();</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>retries <span style="color:#f92672">&amp;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#75715e">/*在 MAX_SCAN_RETRIES 次过程中，key 对应的 entry 发生了变化，则从头开始*/</span>
                 <span style="color:#f92672">(</span>f <span style="color:#f92672">=</span> entryForHash<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> hash<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> first<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e <span style="color:#f92672">=</span> first <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span> <span style="color:#75715e">// re-traverse if entry changed
</span><span style="color:#75715e"></span>            retries <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol>
<li>假如当前环境下没有任何线程进行<code>put</code> 操作，此时如果线程 1 进行了<code>put</code> 操作，他首先会去尝试获得锁，由于之前没有任何一个线程持有锁，所以线程 1 是可以执行到<code>tryLock()</code> 并返回<code>null</code> 的，即线程 1<strong>成功的拿到了锁</strong>，然后<strong>根据计算找到对应桶的位置</strong>，<strong>新添加一个键值对</strong>。</li>
<li>如果此时在<strong>线程 1 还没有释放锁</strong>的情况下，<strong>线程 2 又执行了 <code>put</code> 操作</strong>，则假如<strong>线程 2 恰好也定位到了和线程 1 同一个段</strong>，然后尝试去进行<code>put</code> 操作，即尝试获取锁，但是线程 1 还没有释放锁，所以<strong>线程 2 在一开始的时候会执行 <code>scanAndLockForPut</code> 方法</strong>。</li>
<li>线程 2 虽然没有得到锁，但是也没有闲着，而是<strong>将准备存放的键值对在对应数组中相应的位置给计算了出来</strong>，<strong>一旦线程 2 获取到了锁</strong>，那么就可以利用等待获取锁的这段时间所做的工作，<strong>直接定位到具体的位置</strong>，从而<strong>节省了时间</strong>，<strong>提高了执行效率</strong>。</li>
<li>如果<strong>线程 2 在等待锁的期间</strong>，<strong>线程 1 将 <code>key</code> 对应的 <code>entry</code> 进行了修改</strong>，则<strong>线程 2 需要重新确定接下来要定位的位置</strong>。</li>
</ol>
</li>
<li>
<p>如果<strong>获取锁成功</strong>，则<strong>将当前的 Segment 中的 <code>table</code> 通过 <code>key</code> 的 <code>hash</code> 值定位到 HashEntry</strong>。</p>
</li>
<li>
<p>然后<strong>遍历该 HashEntry</strong>：</p>
<ol>
<li><strong>如果当前节点不为空</strong>，<strong>则判断传入的 <code>key</code> 和当前遍历到的 <code>key</code> 是否相等</strong>，<strong>如果相等</strong>，<strong>则覆盖旧的 <code>value</code></strong>。</li>
<li><strong>如果当前节点为空</strong>，<strong>则新建一个 HashEntry 并加入到 Segment 中</strong>，<strong>再判断是否需要扩容</strong>。</li>
</ol>
</li>
<li>
<p>最后<strong>在 <code>finally</code> 中解除之前获得的锁</strong>。</p>
</li>
</ol>
</li>
</ol>
<p>
  <img src="../../media/202107/2021-07-30_1539390.0048849912925379435.png" alt="1604851702c89293 (1031×1501)" /></p>
</li>
</ol>
<h3 id="22-jdk-18中的concurrenthashmap">
  2.2 JDK 1.8中的ConcurrentHashMap
  <a class="anchor" href="#22-jdk-18%e4%b8%ad%e7%9a%84concurrenthashmap">#</a>
</h3>
<h4 id="221-与jdk-17中的concurrenthashmap的区别">
  2.2.1 与JDK 1.7中的ConcurrentHashMap的区别
  <a class="anchor" href="#221-%e4%b8%8ejdk-17%e4%b8%ad%e7%9a%84concurrenthashmap%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h4>
<ol>
<li>
<p><strong>抛弃了JDK 1.7中的Segment锁分段技术</strong>，而是<strong>采用CAS + Synchronized的方式保证并发的安全性</strong>，<strong>体现在 <code>put</code>操作的不同</strong>，<strong>在JDK 1.8 中则是对数组中单个位置加锁</strong>。</p>
<blockquote>
<p>为什么要使用CAS + Synchronized取代Segment + ReentrantLock？</p>
<ol>
<li>分段锁具有相应的缺点，具体可参考
  <a href="/school-recruitment/#2-1-1-Segment">2.1.1 Segment</a>。</li>
<li><strong>使用ReentrantLock需要节点继承AQS来获得同步支持</strong>，<strong>锁定的是一整个段</strong>，<strong>增加内存开销</strong>，<strong>而JDK 1.8中加锁的对象是每个链表的头结点</strong>，也就是<strong>锁定的是冲突的链表</strong>，因此<strong>提高了并发度</strong>，同时<strong>降低了内存开销</strong>。</li>
<li><strong>Synchronized是JVM直接支持的</strong>，<strong>JDK 1.8之后进行了许多优化</strong>，<strong>能够在运行期间调整锁的粒度</strong>，<strong>而不需要在开始就是用重量级锁操作</strong>。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>将JDK 1.7中用于存放数据的内部类HashEntry替换成了内部类Node</strong>，<strong>但作用相同</strong>。</p>
</li>
<li>
<p>JDK 1.8中的<strong>结构转换为数组 + 链表 + 红黑树</strong>。</p>
</li>
</ol>
<h2 id="参考文献">
  参考文献
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#</a>
</h2>
<ol>
<li>
  <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8 系列之重新认识 HashMap</a>。</li>
<li>
  <a href="https://zhuanlan.zhihu.com/p/42703011">第三天：HashMap 为什么是线程不安全的</a>。</li>
<li>
  <a href="https://www.cnblogs.com/chengxiao/p/6842045.html">ConcurrentHashMap 实现原理及源码分析</a>。</li>
<li>
  <a href="https://www.cnblogs.com/chengxiao/p/6059914.html">HashMap 实现原理及源码分析</a>。</li>
<li>
  <a href="https://www.geek-share.com/detail/2810195384.html">HashMap 1.7 和 1.8 的区别 &ndash;答到面试官怀疑人生</a>。</li>
<li>
  <a href="https://dyfloveslife.github.io/2020/03/24/JavaSrc-ConcurrentHashMap">Java 容器之 ConcurrentHashMap</a>。</li>
<li>
  <a href="https://github.com/woniu201/interview-reference/blob/main/04.%E8%85%BE%E8%AE%AF%E7%AF%87/4.1.6%20JAVA8%E7%9A%84ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E4%BA%86%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.md">JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</a></li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/graysonwp/ComputerCookbook-SchoolRecruitment/edit/main/exampleSite/content/docs/java/1%e3%80%81Java%e5%9f%ba%e7%a1%80/1.2%20HashMap%e5%92%8cConcurrentHashMap%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.md" target="_blank" rel="noopener">
      <img src="/school-recruitment/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


<div id="gitalk-container" style="width : 100%;"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '94880e59f97ce511eb59',
    clientSecret: '025de6989c2398fdb4bfc398994541421fe6d32b',
    repo: 'ComputerCookbook-SchoolRecruitment',
    owner: 'graysonwp',
    admin: ['graysonwp'],
    id: md5(location.pathname), 
    distractionFreeMode: false, 
    body: location.href, 
    proxy: 'https:\/\/shielded-brushlands-08810.herokuapp.com\/https:\/\/github.com\/login\/oauth\/access_token' 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#hashmap和concurrenthashmap实现原理">HashMap和ConcurrentHashMap实现原理</a>
      <ul>
        <li><a href="#1-hashmap">1 HashMap</a>
          <ul>
            <li><a href="#11-简介">1.1 简介</a></li>
            <li><a href="#12-内部实现">1.2 内部实现</a>
              <ul>
                <li><a href="#121-存储结构">1.2.1 存储结构</a></li>
                <li><a href="#122-功能实现">1.2.2 功能实现</a>
                  <ul>
                    <li><a href="#1221-确定哈希桶数组索引位置">1.2.2.1 确定哈希桶数组索引位置</a></li>
                    <li><a href="#1322-put-方法的执行原理">1.3.2.2 put 方法的执行原理</a></li>
                    <li><a href="#1223-扩容机制">1.2.2.3 扩容机制</a></li>
                    <li><a href="#1224-线程安全性">1.2.2.4 线程安全性</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#13-hashmap-在-jdk-17-和-jdk-18-之间的区别">1.3 HashMap 在 JDK 1.7 和 JDK 1.8 之间的区别</a></li>
          </ul>
        </li>
        <li><a href="#2-concurrenthashmap">2 ConcurrentHashMap</a>
          <ul>
            <li><a href="#21-实现原理">2.1 实现原理</a>
              <ul>
                <li><a href="#211-segment">2.1.1 Segment</a></li>
                <li><a href="#212-构造方法">2.1.2 构造方法</a></li>
                <li><a href="#213-get-方法">2.1.3 get 方法</a></li>
                <li><a href="#214-put-方法">2.1.4 put 方法</a></li>
              </ul>
            </li>
            <li><a href="#22-jdk-18中的concurrenthashmap">2.2 JDK 1.8中的ConcurrentHashMap</a>
              <ul>
                <li><a href="#221-与jdk-17中的concurrenthashmap的区别">2.2.1 与JDK 1.7中的ConcurrentHashMap的区别</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












