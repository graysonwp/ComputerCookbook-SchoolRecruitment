<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 #  1 含义 #   单例模式（Singleton Design Pattern）是指保证一个类只能有一个实例，并且提供一个全局访问点。 单例模式的实现需要三个必要条件：   单例类的构造函数必须是私有的，这样才能将类的创建权控制在内部，从而使得类的外部不能创建类的实例。
  单例类通过一个私有的静态变量来存储其唯一实例。
  单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。
 因为单例类的构造函数是私有的，所以单例类不能被继承。
    实现单例类时，需要考虑三个问题：  创建单例对象时，是否线程安全。 单例对象的创建，是否延时加载。 获取单例对象时，是否需要锁（锁会导致低性能）。    2 优缺点 #  2.1 优点 #   在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例，这样就可以防止其他对象对自己的实例化，确保所有的对象都访问一个实例，避免对共享资源的多重占用。 单例模式具有一定的伸缩性，类自己来控制实例化进程，因此在改变实例化进程上有相应的伸缩性。 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁对象时，单例模式无疑可以提高系统的性能。  2.2 缺点 #   不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 由于单例模式没有抽象层，因此单例类的扩展有很大的困难。 滥用单例会带来一些负面影响，例如：  为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。 如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。    3 使用场景 #  在下面几个场景中适合使用单例模式：
 有频繁实例化然后销毁的情况，也就是频繁的new 对象，可以考虑单例模式。 创建对象耗时过多或者耗资源过多，但又经常用到的对象。 频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件。  下面举几个例子来说明一下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂模式 #  1 含义 #   工厂模式提供了一种创建对象的最佳方式， 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象，实现了创建者和调用者的分离。 工厂模式可分为简单工厂模式、工厂方法模式、抽象工厂模式。  2 优缺点 #  2.1 优点 #   工厂模式是我们最常用的实例化对象模式，是用工厂方法代替 new操作的一种模式。 利用工厂模式可以降低程序的耦合性，为后期的维护修改提供很大的便利。 将选择实现类、创建对象统一管理和控制，从而将调用者跟我们的实现类解耦。  3 使用场景 #   首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂模式，而对于简单对象，特别是只需要 new就可以完成创建的对象，无需使用工厂模式，因为如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 其次，工厂模式是一种典型的解耦模式，假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，这会大大降低对象之间的耦合度。 最后，由于工厂模式是依赖抽象架构的，他把实例化产品的任务交由实现类完成，扩展性比较好，也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。  4 分类 #  4.1 简单工厂模式 #  4.1.1 含义 #   简单工厂模式相当于一个工厂中有各种产品，创建一个类时，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。 但是工厂的职责过重，而且类型过多时不利于系统的扩展维护。  4.1.2 UML类图 #   4.1.3 实例 #    创建工厂：
public interface Car { void run(); }   创建工厂的产品（宝马）：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式 #  1 含义 #    代理模式是指通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。
  代码在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能。
 关于代理，以下小例子可以帮助我们理解代理的含义：
 游戏代练 游戏代练这件事就是一个代理模式，所谓代练，就是Proxy，也即代理类，代理的流程是我们把自己的账号交给代练人员，让他们帮我们打怪升级，而我们只需提供账号即可，代练人员那边，他所要做的就是登陆我们的账号，然后替我们打游戏，从第三者的角度看，我们这个角色在打怪升级，但这个第三者并不知道是不是我们本人在打游戏，他只能看到我们这个账号正在打怪升级，但并不需要知道后面打游戏的是谁，这就是代理模式，由他人代理玩游戏。 邀请明星 假设我们现在要邀请明星来上节目，我们应该先给他的经纪人打电话，然后再由经纪人通知到该明星，这里经纪人充当的就是代理的角色。     2 应用场景 #   当不想访问某个对象或访问某个对象存在困难时，就可以为这个对象创建一个代理，通过代理来间接的访问这个对象。 如果原始对象有不同的访问权限，可以使用代理控制对原始对象的访问，保护原始对象。 在访问原始对象时执行一些自己的附加条件。 为某个对象在不同的地址空间提供局部代理，使得系统可以将服务端的实现隐藏，客户端不必考虑服务端的存在。 具体应用场景主要包括Spring AOP、日志打印、异常处理、事务控制、权限控制。  3 分类 #  代理模式主要分为静态代理模式和动态代理模式两类，其中动态代理模式可分为 JDK 动态代理和 cglib 动态代理两种。
3.1 静态代理 #  3.1.1 含义 #   静态代理是由程序员或工具生成代理类的源码，再编译代理类。 所谓静态也就是在程序运行之前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。  3.1.2 类图 #    Subject：抽象主题类，定义了代理对象和真实对象的共同接口方法，既可以是接口，也可以是抽象类。 RealSubject：真实主题类，该类可以称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了 Subject 接口，而Client端通过代理类间接的调用真实主题类的方法，由其执行真实的业务逻辑。 ProxySubject：代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了 Subject 接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。 Client：客户端，使用代理。   相关近义词：</description>
    </item>
    
  </channel>
</rss>
