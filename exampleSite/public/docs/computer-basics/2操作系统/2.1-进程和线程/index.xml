<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Cookbook School Recruitment</title>
    <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content on Computer Cookbook School Recruitment</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>进程和线程的区别 #  1 进程和线程有哪些区别 #   进程（Process）是系统进行资源分配和调度的基本单位，线程是CPU 调度和分配的基本单位。 线程依赖于进程而存在，一个进程至少有一个线程。 进程有自己的独立地址空间，线程共享所属进程的地址空间。 进程是拥有系统资源的一个独立单位，而线程基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），和其他线程共享本进程的相关资源如内存、I/O、CPU 等。 在进程切换时，涉及到整个当前进程 CPU 环境的设置以及新被调度运行的 CPU 环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换时的开销远大于线程切换的开销。 线程间的通信更方便，同一进程下的线程共享全局变量等数据，而进程间的通信需要以进程间通信（IPC）的方式进行。 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其他进程造成影响，因为进程有自己独立的地址空间，因此，多进程更加健壮。  2 同一进程中的线程可以共享哪些变量 #   进程代码块。 进程的公有数据（全局变量、静态变量&amp;hellip;）。 进程打开的文件描述符。 进程的当前目录。 信号处理器/信号处理函数：对收到的信号的处理方式。 进程 ID与进程组 ID。  3 线程独占哪些资源 #   线程 ID。 一组寄存器的值。 线程自身的栈（堆是共享的）。 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其他线程修改。 信号掩码/信号屏蔽字：表示是否屏蔽/阻塞相应的信号（SIGKILL 和 SIGSTOP 除外）。  参考文献 #    进程和线程有什么区别？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid>
      <description>进程间通信方式 #  进程间的通信方式主要有六种，分别是管道、消息队列、共享内存、信号量、信号（Signal）、套接字（Socket）。
1 管道 #  管道分为两种，分别为匿名管道（Pipe）和命名管道（FIFO）。
1.1 匿名管道 #  1.1.1 含义 #   匿名管道是一种半双工的方式，数据只能单向流动，也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。 只能在具有亲缘关系的进程间使用，进程的亲缘关系一般指父子关系。 当一个进程创建了一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道，子进程关闭写管道，这样就提供了两个进程间数据流动的一种方式。  1.1.2 优缺点 #  1.1.2.1 优点 #   简单方便。  1.1.2.2 缺点 #   这个管道只能在具有亲缘关系的进程之间通信。 他只能实现一个进程写另一个进程读，而如果需要两者同时进行，就得重新打开一个管道。  1.2 命名管道 #  1.2.1 含义 #   为了使任意两个进程之间通信，就提出了命名管道。 与管道的区别是提出了一个路径名与之关联，以 FIFO 的形式存储于文件系统中，能够实现任何两个进程之间通信，而匿名管道对于文件系统是不可见的，只限于在父子进程之间的通信。 FIFO 是一个设备文件，在文件系统中以文件名的形式存在，因此，即使进程与创建 FIFO 的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。 FIFO 遵循先进先出原则，即第一个进来的数据会第一个被读走。  1.2.2 优缺点 #  1.2.2.1 优点 #   可以实现任意关系的进程间的通信。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>进程同步问题 #   进程的同步是目的，而进程间通信是实现进程同步的手段。
 1 管程 #  1.1 含义 #   管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定功能接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源，使用完之后必须释放管程并唤醒入口等待队列中的进程。 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复。 管程使用锁确保了在任何情况下管程中只有一个活跃的线程，即确保线程互斥访问临界区。 管程使用条件变量提供的等待队列实现线程间协作，当线程暂时不能获得所需资源时，进入队列等待，当线程可以获得所需资源时，从等待队列中唤醒。  1.2 组成 #  管程主要有三部分组成，具体如下：
 一个锁： 控制管程代码的互斥访问。 入口队列： 每次只能有一个线程进入。 条件变量： 管理数据的并发访问。   1.3 条件变量 #   条件变量是管程内的等待机制。 每个条件变量表示一种等待原因，对应一个等待队列。 条件变量有两种操作：  wait() 操作：  将自己阻塞在队列中。 唤醒一个等待者或者释放管程的互斥访问（即允许另外一个线程进入管程）。   signal() 操作：  将等待队列中的一个线程唤醒。 如果等待队列为空，这就相当于是一个空操作。      1.4 语义 #  事实上管程一共有三种语义：
 Hoare 语义。 Mesa 语义。 Hansen 语义。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/</guid>
      <description>进程有哪几种状态 #   1 进程的三种状态 #   就绪状态： 进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。 运行状态： 进程正在处理器上运行，在单处理器环境下，每个时刻最多只有一个进程处于运行状态。 阻塞状态： 进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入输出完成，此时即使处理器空闲，该进程也不能运行。  2 进程三种状态之间的切换 #   当一个就绪进程获得处理器时，其状态就由就绪变为运行。 当一个运行进程被剥夺处理器时，如用完系统分给他的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪。 当一个运行进程因为某件事情受阻时，如所申请资源被占用、启动I/O传输未完成，其状态就会由运行变为阻塞。 当一个阻塞进程所等待事情发生时，如得到申请资源、I/O传输完成，其状态就会由阻塞变为就绪。  3 参考文献 #    进程有哪几种状态？  进程的几种状态。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</guid>
      <description>进程调度策略 #  1 批处理系统 #  1.1 先来先服务（first-come first-service，FCFS） #  1.1.1 含义 #   先来先服务调度算法是一种非抢占式的算法，先进入就绪队列的进程，先分配处理器运行。 一个进程一旦占有了处理器，他就一直运行下去，直到该进程完成工作或者因为等待某事件发生而不能继续运行时才释放处理器。  1.1.2 优缺点 #  1.1.2.1 优点 #   非抢占式，开销小，无饥饿问题。  1.1.2.2 缺点 #   响应时间不确定，可能很慢。 对长进程有利，对短进程不利。 对CPU 繁忙型进程有利，对I/O 繁忙型进程不利。   为什么 FCFS 对 I/O 繁忙型进程不利？
 因为每次进行 I/O 操作都会进入阻塞态，I/O 完成之后变成就绪态，会重新进入就绪队列队尾。 因为是 FCFS，所以会重新排队。 然而每次调度这个进程只会运行很短时间就又需要 I/O，然后又到队尾，如此往复，所以效率很低。   1.2 最短作业优先（shortest job first，SJF） #  1.2.1 含义 #   最短作业优先调度算法将每个进程与其下次 CPU 执行时间关联起来，当 CPU 变为空闲时，他会被赋予给具有最短 CPU 执行的进程。 如果两个进程具有同样长度的 CPU 执行时间，那么可以由FCFS处理。 SJF 算法是对 FCFS 算法的改进，其目标是减少平均周转时间。  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</guid>
      <description>僵尸进程和孤儿进程 #  1 僵尸进程 #  1.1 含义 #   当一个子进程结束运行（一般是调用 exit、运行时发生致命错误或收到终止信号导致）时，其退出状态会汇报给操作系统，系统则以 SIGCHLD 信号将子进程被结束的事件告知父进程，此时，子进程的进程控制块（PCB）仍驻留在内存中。 一般来说，收到 SIGCHLD 后，父进程会使用 wait 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB。 如果父进程没有调用 wait 或 waitpid 获取子进程的状态信息时，子进程的 PCB 就会一直驻留在内存中，成为僵尸进程。  1.2 特点 #   僵尸进程是一个死亡的进程，但是并没有真正被销毁。 他已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程 ID、终止状态以及资源利用信息（CPU 时间，内存使用量等）供父进程收集，除此之外，僵尸进程不再占用任何内存空间。 这个僵尸进程可能会一直留在系统中，直到系统重启。  1.3 危害 #   占用进程号，而系统所能使用的进程号是有限的，如果产生大量的僵尸进程，就会因为没有可用的进程号而导致系统不能产生新的进程。  1.4 如何杀死僵尸进程 #   重启服务器。 找到该僵尸进程的父进程，并将该进程的父进程杀掉，则此僵尸进程会自动消失。   查找僵尸进程的方法：ps aux | grep -w &#39;Z&#39;
 1.5 如何避免僵尸进程 #   父进程在创建子进程之前，就调用 signal(SIGCHLD,SIG_IGN) 向系统申明自己不会对这个子进程的 exit 动作进行任何关注行为，这样子进程一旦退出，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。 父进程创建子进程后调用 wait 或 waitpid 等待子进程结束，但是这会导致父进程挂起。 父进程在创建子进程的时候，连续调用两次 fork()，而且使紧跟的子进程退出，使其孙子进程成为孤儿进程，从而 init 进程将代替父进程来接手，负责清除这个孤儿进程，于是父进程就无须进行任何的清理行为，系统会自动处理。 采用信号量处理函数，父进程首先注册一个信号处理函数 signal(SIGCHLD, sig_chld_handler)，然后每当子进程退出的时候，父进程都会收到 SIGCHLD，然后在 sig_chld_handler 中调用 wait 函数等待子进程的退出。  2 孤儿进程 #  2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid>
      <description>线程同步 #  1 为什么需要线程同步 #   线程有时候会和其他线程共享一些资源，比如内存、数据库等。 当多个线程同时读写一份共享资源的时候，可能会发生冲突，因此需要线程的同步，多个线程按顺序访问资源。  2 线程同步有哪些方式 #  线程同步主要有四种方式，分别是互斥量（Mutex）、信号量（Semaphore）、事件（Event）、临界区（Critical Section）。
2.1 互斥量 #   互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。 因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问。 当前拥有互斥对象的线程处理完任务后，必须将互斥对象交出，以便其他线程访问该资源。  2.2 信号量 #   信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1。 只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。 线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1. 如果信号量的取值只能是0或1，那么信号量就成了互斥量。  2.3 事件 #   事件允许一个线程在处理完任务后，主动唤醒另外一个线程执行任务。 事件分为手动重置事件和自动重置事件：  手动重置事件被设为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。 自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。    2.4 临界区 #   临界区是一段代码，这段代码使用来访问临界资源的。 任意时刻只允许一个线程对临界资源进行访问。 拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，临界区被释放后，其它线程可继续抢占该临界区。 临界区是一种轻量级的同步机制，是用户态下的对象，即只能在同一进程中实现线程互斥，因此无需在用户态和核心态切换，工作效率比互斥来说要高很多。  3 互斥量和临界区有什么区别 #   互斥量是可以命名的，可以用于不同进程之间的同步。 临界区只能用于同一进程中线程的同步。 创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。  参考文献 #    线程同步有哪些方式？  临界区与互斥量区别。  [多线程] 互斥量和临界区的区别。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/</guid>
      <description>协程 #  1 含义 #   协程是一种轻量级线程，位于用户态，完全由用户自己控制。   2 特点 #   线程的切换由操作系统负责调度，协程由用户进行调度，因此减少了上下文切换，提高了效率。 线程的默认栈大小是1M，而协程更轻量，接近1K，因此可以在相同的内存中开启更多的协程。 由于在同一个线程上，可以避免竞争关系而使用锁。 适用于 I/O密集型的场景，不适用于计算密集型的场景。  3 注意事项 #  3.1 协程中不能调用导致线程阻塞的操作 #   假设协程运行在线程之上，并且协程调用了一个阻塞IO操作。 由于操作系统并不知道协程的存在，只知道线程，因此在协程调用阻塞IO的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度。 因此，在协程中不能调用导致线程阻塞的操作，也就是说，协程只有和异步IO结合起来，才能发挥最大的作用。  3.2 在协程中调用阻塞IO操作的处理方式 #   在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，同时将当前协程休眠（让出执行权），等执行完成之后，再唤醒协程，让协程去读取结果，这其实和多线程没有太大区别。 对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。  4 线程与协程的比较 #   线程占用的资源初始时是1MB，固定不可变，协程占用的资源初始时一般为2KB，可随需求而增大。 线程的调度是由操作系统的内核完成，协程的调度是由用户来完成。 线程资源占用太高，频繁创建销毁会带来严重的性能问题，协程资源占用小，不会带来严重的性能问题。 线程需要用锁来保证数据的一致性和可见性，协程不需要多线程的锁机制，因为只有一个线程，所以不存在同时写变量冲突，所以执行效率比多线程高很多。  5 参考文献 #    什么是协程？  一文读懂什么是进程、线程、协程。  什么是协程？  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>异常控制流 #  1 什么是控制流 #   假设在计算机运行过程中，其指令序列为 $a_1,a_2,&amp;hellip;,a_n$，则每次从 $a_n$ 到 $a_{n+1}$ 的过渡叫做**控制转移**，而 $a_1,a_2,&amp;hellip;,a_n$ 这条**完整的控制转移序列**叫做处理器的**控制流**。 所以，控制流说白了就是CPU 执行指令的序列。  2 什么是控制流的异常 #   程序在加载进内存时指令序列也会跟着一同被加载。 指令序列在内存中是相邻的，程序计数器在通常情况下会依次加载这些相邻的指令交给 CPU 执行。 但是在某些情况下可能会发生突变，从而打破 CPU 本应该顺序执行这些指令序列的预期行为，这种突变就叫做控制流的异常，简称ECF（Exception Control Flow）。  3 理解异常控制流的必要性 #   ECF 是操作系统用来实现 I/O、进程和虚拟内存的基本机制。 陷阱和系统调用都是 ECF 的一种。 操作系统实现并发机制依靠的也是 ECF。 类似于 Java 的 try/catch 异常机制，属于应用层的 ECF。  4 异常处理程序 #  4.1 基本概念 #   异常处理程序就是处理异常的程序。 相关物理含义：  CPU 的状态：  CPU 的状态就是指其内部特定范围的一些数据位和电信号，CPU 状态的变化可以理解为这些数据位或电信号的变化。 CPU 状态的变化可能与当前执行的应用程序的指令有关，比如虚拟内存缺页、算术溢出、除以 0 等，也有可能与当前执行的指令无关，比如I/O 请求完成。   CPU 的事件：  CPU 的状态变化就是 CPU 的事件。   异常表：  在任何情况下，当 CPU 检测到有事件发生时，会通过一张映射表，找到一个被设计用来专门处理这类事件的操作系统的子程序，这个子程序就是异常处理程序。 而记录不同类型的异常处理程序之间的映射关系的映射表就是异常表。 异常表中对于每种可能类型的异常都分配了一个唯一的非负整数的异常号。 其中一些号码是由CPU 的设计者设计的，比如零除异常、缺页异常、内存访问违规异常、算术运算溢出异常，这些属于系统无关的异常。 而有一些异常号码则是由操作系统内核的设计者分配的，比如系统调用和IO 设备的信号，这些属于系统相关的异常。 操作系统在启动时会整合 CPU 异常和内核异常，并且将其记录成一张完整的异常表加载到内存中，然后将其起始地址放在一个叫做异常表基址寄存器的一个特殊的 CPU 寄存器里。      异常处理的基本过程：  假设当前 CPU 正在执行的指令为lcurr，此时CPU 检测到一个异常发生，进而 CPU 转去执行异常处理程序的相关指令。 当异常处理程序执行完之后，根据其处理结果可能有几种动作：  继续执行异常发生时正在执行的应用程序的指令 lcurr。 执行异常发生时正在执行的应用程序的指令 lcurr 的下一条指令 lnext。 该应用程序直接被终止，不再执行其指令。     无论是硬件触发了异常还是软件触发了异常，剩下的工作都是由异常处理程序在软件中完成。 在处理程序处理完事件之后，可以通过执行一条特殊的“从中断返回”的指令可选的返回到被中断的程序。  4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>IO多路复用 #  1 什么是文件描述符 #   文件描述符在形式上是一个非负整数。 实际上，他是一个索引值，指向内核为每一个进程所维护该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符。  2 水平触发和边缘触发 #  2.1 含义 #   水平触发（LT, Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知。 边缘触发（ET, Edge Trigger）模式下，当文件描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪。  2.2 区别 #   边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。  2.3 为什么边缘触发一定要用非阻塞 IO #   避免由于一个描述符的阻塞读/写操作让处理其他描述符的任务出现饥饿状态。  3 五种 IO 模型 #  常见的 IO 模型主要有五种，分别是阻塞 IO（Blocking IO, BIO）、非阻塞 IO（NoneBlocking IO, NIO）、IO 多路复用（IO Multiplexing）、信号驱动 IO（Signal Driven IO）、异步 IO（Asynchronous IO, AIO）。
3.1 阻塞 IO #   阻塞 IO 是一种最传统的 IO 模型，在读写数据过程中会发生阻塞现象。 当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，此时用户线程就会处于阻塞状态，同时用户线程会交出 CPU。 当数据就绪之后，内核会将数据拷贝到用户线程，此时用户线程才会解除阻塞状态。 比如 A 同学排队买票，他只能排队买上票才可以离开，这一过程就可以看成是使用了阻塞 IO 模型，因为在没买到票之前，他不能离开队伍做别的事情。 很显然，阻塞 IO 模型是同步的。   3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</guid>
      <description>用户态和内核态 #  1 什么是用户态和内核态 #   为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，CPU划分了用户态和内核态两个权限等级：  用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他程序获取。 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。   所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换回用户态并返回系统调用的结果。  2 为什么要区分用户态和内核态 #   主要是为了区别执行特权指令和非特权指令。 在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如清内存、设置时钟等。 所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。  3 用户态和内核态之间如何切换 #  用户态和内核态之间的切换主要有三种方式，分别是系统调用、中断、异常。
3.1 系统调用 #   这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。 而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现的。  3.2 中断 #   当外围设备完成用户请求操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。 如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换，比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作。  3.3 异常 #   当CPU在执行运行在用户态下的程序时，发生了某些事不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。  参考文献 #    什么是用户态和内核态？  用户态和核心态的概念以及为什么要区别？以及两者之间的切换？  </description>
    </item>
    
  </channel>
</rss>
