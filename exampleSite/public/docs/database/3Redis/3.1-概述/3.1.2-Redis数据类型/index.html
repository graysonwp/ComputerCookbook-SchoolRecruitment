<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="如无特殊说明，本文内容针对的 Redis 版本为 3.0.0，源码下载地址为 redis-3.0.0。
 1 前言 #    Redis 的 key 是顶层模型，他的 value 是扁平化的，所有的 value 都是一个 object，它的结构如下：
typedef struct redisObject { unsigned [type] 4; unsigned [encoding] 4; unsigned [lru] REDIS_LRU_BITS; int refcount; void *ptr; } robj;   上面的几个字段的意义如下：
 type：数据类型，就是我们熟悉的string、hash、list 等。 encoding：内部编码，其实就是数据结构，指的是当前这个 value 底层是用的什么数据结构，因为同一个数据类型底层也有多种数据结构的实现，所以这里需要指定数据结构。 REDIS_LRU_BITS：当前对象可以保留的时长。 refcount：对象引用计数，用于 GC。 ptr：指针，指向以 encoding 的方式实现这个对象的实际地址。    整个 Redis 的数据结构组织如下图所示：
   2 数据类型 #  Redis 中主要有 5 种数据类型，分别是字符串（String）、列表（List）、集合（Set）、有序集合（ZSet）、哈希（Hash）。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="如无特殊说明，本文内容针对的 Redis 版本为 3.0.0，源码下载地址为 redis-3.0.0。
 1 前言 #    Redis 的 key 是顶层模型，他的 value 是扁平化的，所有的 value 都是一个 object，它的结构如下：
typedef struct redisObject { unsigned [type] 4; unsigned [encoding] 4; unsigned [lru] REDIS_LRU_BITS; int refcount; void *ptr; } robj;   上面的几个字段的意义如下：
 type：数据类型，就是我们熟悉的string、hash、list 等。 encoding：内部编码，其实就是数据结构，指的是当前这个 value 底层是用的什么数据结构，因为同一个数据类型底层也有多种数据结构的实现，所以这里需要指定数据结构。 REDIS_LRU_BITS：当前对象可以保留的时长。 refcount：对象引用计数，用于 GC。 ptr：指针，指向以 encoding 的方式实现这个对象的实际地址。    整个 Redis 的数据结构组织如下图所示：
   2 数据类型 #  Redis 中主要有 5 种数据类型，分别是字符串（String）、列表（List）、集合（Set）、有序集合（ZSet）、哈希（Hash）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" /><meta property="article:section" content="docs" />



<title>3.1.2 Redis数据类型 | Computer Cookbook School Recruitment</title>
<link rel="manifest" href="/school-recruitment/manifest.json">
<link rel="icon" href="/school-recruitment/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/school-recruitment/book.min.57f7f660871517a5bfcfb5e2de853d806f7e34d94ebd5f3f3bad62e9ddbae209.css" integrity="sha256-V/f2YIcVF6W/z7Xi3oU9gG9&#43;NNlOvV8/O61i6d264gk=" crossorigin="anonymous">
  <script defer src="/school-recruitment/flexsearch.min.js"></script>
  <script defer src="/school-recruitment/en.search.min.d54c827212935f77565b872675a4a154786a11eb2c7ebae0d88234ab971de3b6.js" integrity="sha256-1UyCchKTX3dWW4cmdaShVHhqEessfrrg2II0q5cd47Y=" crossorigin="anonymous"></script>

  <script defer src="/school-recruitment/sw.min.07899fc95e217f83f76b676678ae96a3d8d0d0b042f9f17c3f23eec2551b7b12.js" integrity="sha256-B4mfyV4hf4P3a2dmeK6Wo9jQ0LBC&#43;fF8PyPuwlUbexI=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />

  <a href="https://github.com/wpwbb510582246/ComputerCookbook-SchoolRecruitment" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;z-index: 100;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/school-recruitment/"><span>Computer Cookbook School Recruitment</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://www.grayson.top" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/graysonwp" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






<hr>


  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-353f7a5578fa41dbc42c73ea30fe2255" class="toggle"  />
    <label for="section-353f7a5578fa41dbc42c73ea30fe2255" class="flex justify-between">
      <a role="button" class="">第一章 算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e0c159ebe8e8b165cd558008fb5f5074" class="toggle"  />
    <label for="section-e0c159ebe8e8b165cd558008fb5f5074" class="flex justify-between">
      <a role="button" class="">1、算法框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="toggle"  />
    <label for="section-a9fe725cb6a0f216530b1ac2b85e3b7a" class="flex justify-between">
      <a role="button" class="">1.1 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" class="">1.1.1 斐波那契数列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.2-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="">1.1.2 背包问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="">1.1.3 贪心算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.4 最长递增子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" class="">1.1.5 编辑距离</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.6-%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/" class="">1.1.6 高楼扔鸡蛋</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.7-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">1.1.7 最长回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.8-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" class="">1.1.8 最大子序和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.9-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/" class="">1.1.9 股票问题系列通解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/" class="">1.1.10 最长重复子数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1.11-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/" class="">1.1.11 最长有效括号</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e36081c41f3a4d8d8355cae83c46c9b8" class="toggle"  />
    <label for="section-e36081c41f3a4d8d8355cae83c46c9b8" class="flex justify-between">
      <a role="button" class="">1.2 二分查找</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6/" class="">1.2.1 二分查找框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.2-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">1.2.2 搜索旋转排序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.2.3-%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="">1.2.3 如何运用二分查找算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ac9691c4865fdec0880b3cb638bc594" class="toggle"  />
    <label for="section-2ac9691c4865fdec0880b3cb638bc594" class="flex justify-between">
      <a role="button" class="">1.3 数据结构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">1.3.1 反转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" class="">1.3.2 数组中的第k个最大元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.3.3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="">1.3.3 二叉树的最近公共祖先</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c6359aa6ff642b64a85093d9888f8ad" class="toggle"  />
    <label for="section-6c6359aa6ff642b64a85093d9888f8ad" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="">1.4 排序算法</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b9f975ded87a304ee48569c44f19492" class="toggle"  />
    <label for="section-9b9f975ded87a304ee48569c44f19492" class="flex justify-between">
      <a role="button" class="">1.5 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="">1.5.1 二叉树遍历</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.2-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/" class="">1.5.2 岛屿问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.3 平衡二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.4-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="">1.5.4 二叉树路径问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.5-%E4%BA%8C%E5%8F%89%E6%A0%91/1.5.5-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">1.5.5 构造二叉树</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4571e95d0021653ce2d27ee4b0838ca0" class="toggle"  />
    <label for="section-4571e95d0021653ce2d27ee4b0838ca0" class="flex justify-between">
      <a role="button" class="">1.6 回溯算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/" class="">1.6.1 回溯算法解题框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/1%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/1.6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.6.2-N%E7%9A%87%E5%90%8E/" class="">1.6.2 N皇后</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8b579ed4452b6a8d2017a24343689b5c" class="toggle"  />
    <label for="section-8b579ed4452b6a8d2017a24343689b5c" class="flex justify-between">
      <a role="button" class="">2、高频面试题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5a653711e83b11abc9ab6143b1a9fd64" class="toggle"  />
    <label for="section-5a653711e83b11abc9ab6143b1a9fd64" class="flex justify-between">
      <a role="button" class="">2.1 数学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.1-%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%B9%82%E7%AE%97%E6%B3%95/" class="">2.1.1 快速模幂算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.2-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/" class="">2.1.2 搜索二维矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.3-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="">2.1.3 螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.1-%E6%95%B0%E5%AD%A6/2.1.4-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" class="">2.1.4 X 的平方根</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5c279474332677699cd0b53888bd51ba" class="toggle"  />
    <label for="section-5c279474332677699cd0b53888bd51ba" class="flex justify-between">
      <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="">2.2 二分查找</a>
    </label>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e057e8659d2f838952397ed15d20f46c" class="toggle"  />
    <label for="section-e057e8659d2f838952397ed15d20f46c" class="flex justify-between">
      <a role="button" class="">2.3 数组</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.1-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="">2.3.1 删除有序数组中的重复项</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.2-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6/" class="">2.3.2 找出数组游戏的赢家</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.4-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.4 如何寻找消失的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.5-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/" class="">2.3.5 如何寻找缺失和重复的元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.6-%E6%9C%80%E5%A4%A7%E6%95%B0/" class="">2.3.6 最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="">2.3.7 二维数组中的查找</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.8 两数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="">2.3.9 三数之和</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/" class="">2.3.10 合并两个有序数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.11-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/" class="">2.3.11 下一个排列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.12-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/" class="">2.3.12 缺失的第一个正数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.13-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="">2.3.13 寻找两个正序数组的中位数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.14-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" class="">2.3.14 多数元素</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.3-%E6%95%B0%E7%BB%84/2.3.15-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" class="">2.3.15 最长连续序列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="toggle"  />
    <label for="section-b0bb9f9be9775f7e7856b63f7c5be80e" class="flex justify-between">
      <a role="button" class="">2.4 字符串</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.1-%E6%9E%84%E9%80%A0-K-%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">2.4.1 构造 K 个回文字符串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.2-%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E5%9B%9E%E4%B8%B2/" class="">2.4.2 如何寻找最 回 串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.3-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/" class="">2.4.3 如何判定括号的合法性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/" class="">2.4.4 字符串转换整数 (Atoi)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.5-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="">2.4.5 长度为3的不同回文子序列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.6-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="">2.4.6 无重复字符的最长子串</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/" class="">2.4.7 字符串相加</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.4-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.4.8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/" class="">2.4.8 翻转字符串里的单词</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c2cc4653d849ecb4e8d0df9162693740" class="toggle"  />
    <label for="section-c2cc4653d849ecb4e8d0df9162693740" class="flex justify-between">
      <a role="button" class="">2.5 链表</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/" class="">2.5.1 环形链表 Ii</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.2-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" class="">2.5.2 如何高效判断回文链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.3-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="">2.5.3 K 个一组翻转链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="">2.5.4 相交链表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.5-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" class="">2.5.5 链表中倒数第k个节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.5-%E9%93%BE%E8%A1%A8/2.5.6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="">2.5.6 合并 K个升序链表</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-95a636b3d00f4ce42d96beeef34d9742" class="toggle"  />
    <label for="section-95a636b3d00f4ce42d96beeef34d9742" class="flex justify-between">
      <a role="button" class="">2.6 二叉树</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.1-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/" class="">2.6.1 在二叉树中分配硬币</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.2-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="">2.6.2 将有序数组转换为二叉搜索树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">2.6.4 重建二叉树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.6-%E4%BA%8C%E5%8F%89%E6%A0%91/2.6.5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" class="">2.6.5 二叉树中的最大路径和</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2dca4a28932da6fd2ab80d6adf86f380" class="toggle"  />
    <label for="section-2dca4a28932da6fd2ab80d6adf86f380" class="flex justify-between">
      <a role="button" class="">2.7 队列</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.7-%E9%98%9F%E5%88%97/2.7.1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" class="">2.7.1 用栈实现队列</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9868fca37e026543bb4220219b385440" class="toggle"  />
    <label for="section-9868fca37e026543bb4220219b385440" class="flex justify-between">
      <a role="button" class="">2.8 动态规划</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/" class="">2.8.1 如何高效解决接雨水问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.8.2-%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/" class="">2.8.2 最少侧跳次数</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2b868ec58580c16b57b76d0e583b5ec9" class="toggle"  />
    <label for="section-2b868ec58580c16b57b76d0e583b5ec9" class="flex justify-between">
      <a role="button" class="">2.9 设计</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/" class="">2.9.1 实现 Trie (前缀树)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/algorithm/2%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/2.9-%E8%AE%BE%E8%AE%A1/2.9.2-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="">2.9.2 Lru 缓存机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0922907dd56f7a4a192db7338c0e7143" class="toggle"  />
    <label for="section-0922907dd56f7a4a192db7338c0e7143" class="flex justify-between">
      <a role="button" class="">第二章 计算机基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e090ea075956ea0a88f3be27eb8b8174" class="toggle"  />
    <label for="section-e090ea075956ea0a88f3be27eb8b8174" class="flex justify-between">
      <a role="button" class="">1、计算机网络</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-043e7911fd2d67fbc52b823c1516a0d8" class="toggle"  />
    <label for="section-043e7911fd2d67fbc52b823c1516a0d8" class="flex justify-between">
      <a role="button" class="">1.1 传输层： Tcp和 UDP</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="">1.1.1 三次握手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="">1.1.2 四次挥手</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="">1.1.3 流量控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="">1.1.5 拥塞控制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.6-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1.6 Tcp和 Udp的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.7-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="">1.1.7 Tcp如何保证传输的可靠性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.1-%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP/1.1.8-TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" class="">1.1.8 Tcp长连接和短连接</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="toggle"  />
    <label for="section-c1e479729a89ea5ddbe8dd67b5f3ed4e" class="flex justify-between">
      <a role="button" class="">1.2 应用层：HTTP和HTTPS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.1-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.1 Http和 HTTP S的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.2-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.2 Get和 Post的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.3-Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.2.3 Session与 Cookie的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.4-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD/" class="">1.2.4 从输入网址到获得页面的过程（越详细越好）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.5-HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/" class="">1.2.5 Http请求有哪些常见的状态码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.6-%E4%BB%80%E4%B9%88%E6%98%AFRIP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="">1.2.6 什么是 Rip，算法是什么</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.7-HTTP1.0HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/" class="">1.2.7 Http1.0、 Http1.1和 Http2.0的主要区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.8-DNS/" class="">1.2.8 DNS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.9-HTTPS%E5%8A%A0%E5%AF%86%E5%92%8C%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/" class="">1.2.9 HTTP S加密和认证过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.10-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" class="">1.2.10 常见网络攻击</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2-%E5%BA%94%E7%94%A8%E5%B1%82HTTP%E5%92%8CHTTPS/1.2.11-REST/" class="">1.2.11 Rest</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3-%E8%AE%A1%E7%AE%97%E5%85%B6%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="">1.3 计算其网络体系结构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="toggle"  />
    <label for="section-9a70073e95afd0aa2b7107f6cb77a3ce" class="flex justify-between">
      <a role="button" class="">1.4 网络层协议</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" class="">1.4.1 Ip地址的分类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.2-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/" class="">1.4.2 划分子网</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.3-%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE/" class="">1.4.3 什么是 Arp协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.4-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/1.4.4-NAT%E5%8D%8F%E8%AE%AE/" class="">1.4.4 Nat协议</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-09f7d8995bc26810475d1c56597a312e" class="toggle"  />
    <label for="section-09f7d8995bc26810475d1c56597a312e" class="flex justify-between">
      <a role="button" class="">2、操作系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2f767bf946d6dc8ddeda6b6435471e5b" class="toggle"  />
    <label for="section-2f767bf946d6dc8ddeda6b6435471e5b" class="flex justify-between">
      <a role="button" class="">2.1 进程和线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.1.1 进程和线程的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="">2.1.2 进程间通信方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="">2.1.3 进程同步问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.4-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/" class="">2.1.4 进程有哪几种状态</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.5-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" class="">2.1.5 进程调度策略</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.6-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" class="">2.1.6 僵尸进程和孤儿进程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="">2.1.7 线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.8-%E5%8D%8F%E7%A8%8B/" class="">2.1.8 协程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.9-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="">2.1.9 异常控制流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.10-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="">2.1.10 Io多路复用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.1.11-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/" class="">2.1.11 用户态和内核态</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.2-%E6%AD%BB%E9%94%81/" class="">2.2 死锁</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b2b1a78994c9898abed1b08fef134abd" class="toggle"  />
    <label for="section-b2b1a78994c9898abed1b08fef134abd" class="flex justify-between">
      <a role="button" class="">2.3 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.1-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5/" class="">2.3.1 分页和分段</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="">2.3.2 虚拟内存</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="">2.3.3 页面置换算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.4-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/" class="">2.3.4 局部性原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.3.5-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="">2.3.5 缓冲区溢出</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/computer-basics/2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/" class="">2.4 磁盘调度</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e28cc33fe5745d14abf4a0147d0624a5" class="toggle" checked />
    <label for="section-e28cc33fe5745d14abf4a0147d0624a5" class="flex justify-between">
      <a role="button" class="">第三章 数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6fd3cab540793410b1ce567d790deadc" class="toggle"  />
    <label for="section-6fd3cab540793410b1ce567d790deadc" class="flex justify-between">
      <a role="button" class="">1、数据库基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7/" class="">1.1 事务的概念和特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.2-%E9%94%81/" class="">1.2 锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.3-%E9%94%81%E5%8D%8F%E8%AE%AE/" class="">1.3 锁协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/" class="">1.4 事务日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.5-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.5 Mvcc实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12290256fbd76ac6014c39648c5827fe" class="toggle"  />
    <label for="section-12290256fbd76ac6014c39648c5827fe" class="flex justify-between">
      <a role="button" class="">1.6 基础知识</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.1-%E4%B8%89%E8%8C%83%E5%BC%8F/" class="">1.6.1 三范式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.2-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" class="">1.6.2 多表连接方式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="">1.6.3 存储过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.4-DELETETRUNCATE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.6.4 Delete、 Truncate和 Drop的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.5-%E8%A7%A6%E5%8F%91%E5%99%A8/" class="">1.6.5 触发器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/1.6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.6.6-%E8%A7%86%E5%9B%BE/" class="">1.6.6 视图</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d1b14978df09adfe15777e58b9b435ec" class="toggle"  />
    <label for="section-d1b14978df09adfe15777e58b9b435ec" class="flex justify-between">
      <a role="button" class="">2、 My SQL</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.1-%E7%B4%A2%E5%BC%95/" class="">2.1 索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.2-B-%E6%A0%91B&#43;%E6%A0%91%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="">2.2 B 树、 B 树索引算法原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.3-%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8/" class="">2.3 索引组织表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.4-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">2.4 Inno Db和 My Isam的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.5-Checkpoint%E6%8A%80%E6%9C%AF/" class="">2.5 Checkpoint技术</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.6-%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86/" class="">2.6 宕机恢复原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="">2.7 数据库优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.8-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="">2.8 分库分表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.9-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="">2.9 一致性哈希算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/2MySQL/2.10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="">2.10 主从复制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-53f351d3e26dfa58c34e937b76a0c4ce" class="toggle" checked />
    <label for="section-53f351d3e26dfa58c34e937b76a0c4ce" class="flex justify-between">
      <a role="button" class="">3、 Redis</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-356f36d039b40fdb10be19d36f2f2793" class="toggle" checked />
    <label for="section-356f36d039b40fdb10be19d36f2f2793" class="flex justify-between">
      <a role="button" class="">3.1 概述</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/" class="">3.1.1 Redis为什么这么快</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.2-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class=" active">3.1.2 Redis数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="">3.1.3 持久化机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.1-%E6%A6%82%E8%BF%B0/3.1.4-%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="">3.1.4 过期机制和内存淘汰策略</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.2-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="">3.2 线程模型</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4731e97839509d5614da88af39acf326" class="toggle"  />
    <label for="section-4731e97839509d5614da88af39acf326" class="flex justify-between">
      <a role="button" class="">3.3 分布式问题</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98/3.3.1-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="">3.3.1 Redis实现分布式锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-555105a060edfd5dfac44ac6d49d31e5" class="toggle"  />
    <label for="section-555105a060edfd5dfac44ac6d49d31e5" class="flex justify-between">
      <a role="button" class="">3.4 缓存异常</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/database/3Redis/3.4-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8/3.4.1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" class="">3.4.1 缓存穿透、缓存击穿、缓存雪崩</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f0d841e400bf38796a65a65ef72b420e" class="toggle"  />
    <label for="section-f0d841e400bf38796a65a65ef72b420e" class="flex justify-between">
      <a role="button" class="">第四章 设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/1%E6%A6%82%E8%BF%B0/" class="">1、概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-e796a2fc1bf6b4e9454f5a191dd15040" class="toggle"  />
    <label for="section-e796a2fc1bf6b4e9454f5a191dd15040" class="flex justify-between">
      <a role="button" class="">2、创建型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="">2.1 单例模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/2%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="">2.2 工厂模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="toggle"  />
    <label for="section-3b4fedfe13cb3a0b79e49b4087294cb6" class="flex justify-between">
      <a role="button" class="">3、结构型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="">3.1 代理模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/3%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="">3.2 装饰器模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0f94fb8c7e53c880650621fdcc596283" class="toggle"  />
    <label for="section-0f94fb8c7e53c880650621fdcc596283" class="flex justify-between">
      <a role="button" class="">4、行为型模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/design-pattern/4%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="">4.1 策略模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-eca69da21de5b0cd25d8421dec09a327" class="toggle"  />
    <label for="section-eca69da21de5b0cd25d8421dec09a327" class="flex justify-between">
      <a role="button" class="">第五章 Java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a64d861c08691e8f06f1178d4d28cf04" class="toggle"  />
    <label for="section-a64d861c08691e8f06f1178d4d28cf04" class="flex justify-between">
      <a role="button" class="">1、 Java基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.1-StringStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">1.1 String、 String Buffer和 String Builder的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.2-HashMap%E5%92%8CConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.2 Hash Map和 Concurrent Hash Map实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.3-ArrayList%E5%92%8CLinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">1.3 Array List和 Linked List实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/1Java%E5%9F%BA%E7%A1%80/1.4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="">1.4 深拷贝与浅拷贝</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="toggle"  />
    <label for="section-21d6c85d1bc3cd657a462ac4b09f9d02" class="flex justify-between">
      <a role="button" class="">2、 Java多线程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" class="">2.1 并发编程的三大特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" class="">2.2 指令重排</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.3-Volatile%E5%8E%9F%E7%90%86/" class="">2.3 Volatile原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.4-CAS%E5%8E%9F%E7%90%86/" class="">2.4 Cas原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.5-Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/" class="">2.5 Java的4种引用级别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.6-Java%E4%B8%AD%E7%9A%84%E9%94%81/" class="">2.6 Java中的锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.7-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.7 Synchronized实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="">2.8 线程池实现原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.9-AQS/" class="">2.9 Aqs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65e183c484720f91ba3d1676e1ed5a16" class="toggle"  />
    <label for="section-65e183c484720f91ba3d1676e1ed5a16" class="flex justify-between">
      <a role="button" class="">3、 Jvm</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" class="">3.1 运行时数据区域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95/" class="">3.2 判断对象是否存活的方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="">3.3 垃圾收集算法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.4-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="">3.4 类的生命周期和加载过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/" class="">3.5 类加载时机</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="">3.6 类加载器的种类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E7%89%B9%E7%82%B9/" class="">3.7 类加载机制的特点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.8-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="">3.8 Jvm内存结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.9-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.9 常见的垃圾收集算法有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.10-%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8/" class="">3.10 指针碰撞和空闲列表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.11-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.11 常见的垃圾收集器有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.12-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" class="">3.12 内存溢出与内存泄漏的区别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.13-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/" class="">3.13 常用的 Jvm启动参数有哪些</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/3JVM/3.14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="">3.14 反射机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-78e3fdb9e302e0ddb1abf0723557c671" class="toggle"  />
    <label for="section-78e3fdb9e302e0ddb1abf0723557c671" class="flex justify-between">
      <a role="button" class="">4、 Nio</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/java/4NIO/4.1-%E6%A6%82%E8%BF%B0/" class="">4.1 概述</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="toggle"  />
    <label for="section-0dcecbd4b31fcc19e26278b6dbaa0d33" class="flex justify-between">
      <a role="button" class="">第六章 Spring全家桶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-afe35ec73fb23fd24d05388dd4f6d178" class="toggle"  />
    <label for="section-afe35ec73fb23fd24d05388dd4f6d178" class="flex justify-between">
      <a role="button" class="">1、 Spring</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.1-%E6%A6%82%E8%BF%B0/" class="">1.1 概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.2-Spring-IOC/" class="">1.2 Spring Ioc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/1Spring/1.3-Spring-AOP/" class="">1.3 Spring Aop</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b63cda05fe80f821d31813480ebd8acb" class="toggle"  />
    <label for="section-b63cda05fe80f821d31813480ebd8acb" class="flex justify-between">
      <a role="button" class="">2、 Spring Boot</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://books.grayson.top/school-recruitment/docs/spring-family/2SpringBoot/2.1-SpringSpringBootSpringCloud%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/" class="">2.1 Spring、 Spring Boot、 Spring Cloud的联系与区别</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/school-recruitment/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>3.1.2 Redis数据类型</strong>

  <label for="toc-control">
    
    <img src="/school-recruitment/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"> </script>
  <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })</script>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-前言">1 前言</a></li>
        <li><a href="#2-数据类型">2 数据类型</a>
          <ul>
            <li><a href="#21-字符串">2.1 字符串</a>
              <ul>
                <li><a href="#211-存储数据">2.1.1 存储数据</a></li>
                <li><a href="#212-使用场景">2.1.2 使用场景</a></li>
                <li><a href="#213-数据结构">2.1.3 数据结构</a></li>
                <li><a href="#214-sds">2.1.4 SDS</a>
                  <ul>
                    <li><a href="#2141-前言">2.1.4.1 前言</a></li>
                    <li><a href="#2142-定义">2.1.4.2 定义</a></li>
                    <li><a href="#2143-sds-与-c-字符串的区别">2.1.4.3 SDS 与 C 字符串的区别</a>
                      <ul>
                        <li><a href="#21431-常数复杂度获取字符串长度">2.1.4.3.1 常数复杂度获取字符串长度</a></li>
                        <li><a href="#21432-杜绝缓冲区溢出">2.1.4.3.2 杜绝缓冲区溢出</a></li>
                        <li><a href="#21433-减少修改字符串时带来的内存重分配次数">2.1.4.3.3 减少修改字符串时带来的内存重分配次数</a></li>
                        <li><a href="#21434-二进制安全">2.1.4.3.4 二进制安全</a></li>
                        <li><a href="#21345-兼容部分-c-字符串函数">2.1.3.4.5 兼容部分 C 字符串函数</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-列表">2.2 列表</a>
              <ul>
                <li><a href="#221-存储数据">2.2.1 存储数据</a></li>
                <li><a href="#222-使用场景">2.2.2 使用场景</a></li>
                <li><a href="#223-数据结构">2.2.3 数据结构</a></li>
                <li><a href="#224-链表">2.2.4 链表</a>
                  <ul>
                    <li><a href="#2241-前言">2.2.4.1 前言</a></li>
                    <li><a href="#2242-实现">2.2.4.2 实现</a>
                      <ul>
                        <li><a href="#22421-链表节点">2.2.4.2.1 链表节点</a></li>
                        <li><a href="#22422-链表">2.2.4.2.2 链表</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><a href="#225-压缩列表">2.2.5 压缩列表</a>
                  <ul>
                    <li><a href="#2251-前言">2.2.5.1 前言</a></li>
                    <li><a href="#2252-实现">2.2.5.2 实现</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#23-哈希">2.3 哈希</a>
              <ul>
                <li><a href="#231-存储数据">2.3.1 存储数据</a></li>
                <li><a href="#232-使用场景">2.3.2 使用场景</a></li>
                <li><a href="#233-数据结构">2.3.3 数据结构</a></li>
                <li><a href="#234-字典">2.3.4 字典</a>
                  <ul>
                    <li><a href="#2341-前言">2.3.4.1 前言</a></li>
                    <li><a href="#2342-实现">2.3.4.2 实现</a>
                      <ul>
                        <li><a href="#23421-哈希表">2.3.4.2.1 哈希表</a></li>
                        <li><a href="#23422-哈希表节点">2.3.4.2.2 哈希表节点</a></li>
                        <li><a href="#23423-字典">2.3.4.2.3 字典</a></li>
                        <li><a href="#23424-哈希算法">2.3.4.2.4 哈希算法</a></li>
                        <li><a href="#23425-解决键值冲突">2.3.4.2.5 解决键值冲突</a></li>
                        <li><a href="#23426-rehash">2.3.4.2.6 rehash</a></li>
                        <li><a href="#23427-渐进式-rehash">2.3.4.2.7 渐进式 rehash</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#24-集合">2.4 集合</a>
              <ul>
                <li><a href="#241-存储数据">2.4.1 存储数据</a></li>
                <li><a href="#242-使用场景">2.4.2 使用场景</a></li>
                <li><a href="#243-数据结构">2.4.3 数据结构</a></li>
              </ul>
            </li>
            <li><a href="#25-有序集合">2.5 有序集合</a>
              <ul>
                <li><a href="#251-存储数据">2.5.1 存储数据</a></li>
                <li><a href="#252-使用场景">2.5.2 使用场景</a></li>
                <li><a href="#253-数据结构">2.5.3 数据结构</a></li>
                <li><a href="#254-跳表">2.5.4 跳表</a>
                  <ul>
                    <li><a href="#2541-前言">2.5.4.1 前言</a></li>
                    <li><a href="#2542-实现">2.5.4.2 实现</a>
                      <ul>
                        <li><a href="#25421-跳表节点">2.5.4.2.1 跳表节点</a></li>
                        <li><a href="#25422-跳表">2.5.4.2.2 跳表</a></li>
                      </ul>
                    </li>
                    <li><a href="#2543-跳表与平衡树哈希表的比较">2.5.4.3 跳表与平衡树、哈希表的比较</a></li>
                    <li><a href="#2544-redis-为什么使用跳表而不用平衡树作为集合的实现">2.5.4.4 Redis 为什么使用跳表而不用平衡树作为集合的实现</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><blockquote>
<p>如无特殊说明，本文内容针对的 Redis 版本为 <code>3.0.0</code>，源码下载地址为
  <a href="https://github.com/redis/redis/archive/refs/tags/3.0.0.zip">redis-3.0.0</a>。</p>
</blockquote>
<h2 id="1-前言">
  1 前言
  <a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#</a>
</h2>
<ol>
<li>
<p>Redis 的 <code>key</code> 是顶层模型，他的 <code>value</code> 是扁平化的，所有的 <code>value</code> 都是一个 <code>object</code>，它的结构如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">redisObject</span> {
    <span style="color:#66d9ef">unsigned</span> [type] <span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> [encoding] <span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> [lru] REDIS_LRU_BITS;
    <span style="color:#66d9ef">int</span> refcount;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
} robj;
</code></pre></div></li>
<li>
<p>上面的几个字段的意义如下：</p>
<ol>
<li><code>type</code>：<strong>数据类型</strong>，就是我们熟悉的<code>string</code>、<code>hash</code>、<code>list</code> 等。</li>
<li><code>encoding</code>：<strong>内部编码</strong>，其实就是<strong>数据结构</strong>，指的是<strong>当前这个 <code>value</code> 底层是用的什么数据结构</strong>，因为同一个数据类型底层也有多种数据结构的实现，所以这里需要指定数据结构。</li>
<li><code>REDIS_LRU_BITS</code>：<strong>当前对象可以保留的时长</strong>。</li>
<li><code>refcount</code>：<strong>对象引用计数</strong>，<strong>用于 GC</strong>。</li>
<li><code>ptr</code>：<strong>指针</strong>，<strong>指向以 <code>encoding</code> 的方式实现这个对象的实际地址</strong>。</li>
</ol>
</li>
<li>
<p>整个 Redis 的数据结构组织如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_0955310.35536856972697195.png" alt="数据类型及其数据结构" /></p>
</li>
</ol>
<h2 id="2-数据类型">
  2 数据类型
  <a class="anchor" href="#2-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>Redis 中主要有 5 种数据类型，分别是<strong>字符串</strong>（<code>String</code>）、<strong>列表</strong>（<code>List</code>）、<strong>集合</strong>（<code>Set</code>）、<strong>有序集合</strong>（ZSet）、<strong>哈希</strong>（<code>Hash</code>）。</p>
<h3 id="21-字符串">
  2.1 字符串
  <a class="anchor" href="#21-%e5%ad%97%e7%ac%a6%e4%b8%b2">#</a>
</h3>
<h4 id="211-存储数据">
  2.1.1 存储数据
  <a class="anchor" href="#211-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae">#</a>
</h4>
<ol>
<li>可以用于存储<strong>字符串</strong>、<strong>整数</strong>、<strong>浮点数</strong>、<strong>JSON</strong>、<strong>XML</strong>、<strong>二进制</strong>等，<strong>最大不能超过 512M</strong>，是<strong>可变的动态字符串</strong>。</li>
</ol>
<h4 id="212-使用场景">
  2.1.2 使用场景
  <a class="anchor" href="#212-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ol>
<li><strong>计数器</strong>：可以利用 Redis 的<code>incr</code>、<code>decr</code> 等命令实现计数。</li>
<li><strong>共享 Session</strong>：Redis 的<code>key</code> 可以方便地设置过期时间，用于实现<code>session key</code> 的自动过期，验证时先根据<code>uid</code> 路由到对应的 Redis，如取不到<code>session key</code>，说明<code>session key</code> 已过期，需要重新登录，如取到<code>session key</code>，则校验通过，升级此<code>session key</code> 的过期时间即可。</li>
<li><strong>限流限速</strong>。</li>
<li><strong>实现分布式锁</strong>。</li>
</ol>
<h4 id="213-数据结构">
  2.1.3 数据结构
  <a class="anchor" href="#213-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li>在 Redis 内部，<code>String</code> 类型有两种底层存储结构，Redis 会根据存储的数据和用户的操作指令自动选择合适的结构：
<ol>
<li><code>int</code>：存放<strong>整数类型</strong>。</li>
<li><code>SDS</code>：Simple Dynamic String，简单动态字符串，存放<strong>浮点</strong>、<strong>字符串</strong>、<strong>字节类型</strong>。</li>
</ol>
</li>
</ol>
<h4 id="214-sds">
  2.1.4 SDS
  <a class="anchor" href="#214-sds">#</a>
</h4>
<h5 id="2141-前言">
  2.1.4.1 前言
  <a class="anchor" href="#2141-%e5%89%8d%e8%a8%80">#</a>
</h5>
<ol>
<li>
<p>Redis<strong>没有直接使用 C 语言传统的字符串表示</strong>（以空字符结尾的字符数组，以下简称 C 字符串），而是<strong>自己构建了一种名为简单动态字符串</strong>（Simple Dynamic String, SDS）<strong>的抽象类型</strong>，并<strong>将 SDS 作为 Redis 的默认字符串表示</strong>。</p>
</li>
<li>
<p>在 Redis 里，<strong>C 字符串只会</strong>作为字符串字面量<strong>用在一些无需对字符串进行修改的地方</strong>，比如<strong>打印日志</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">redisLog<span style="color:#f92672">(</span>REDIS_WARNING, <span style="color:#e6db74">&#34;Redis is now ready to exit, bye bye...&#34;</span><span style="color:#f92672">)</span>;
</code></pre></div></li>
<li>
<p>当 Redis 需要的不仅仅是一个字符串字面量，而是一个<strong>可以被修改的字符串值</strong>时，Redis 就会<strong>使用 SDS 来表示字符串值</strong>，比如<strong>在 Redis 的数据库里面</strong>，<strong>包含字符串值的键值对在底层都是由 SDS 实现的</strong>，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">redis&gt; SET msg <span style="color:#e6db74">&#34;hello world&#34;</span>
OK
</code></pre></div><p>那么 Redis 将在数据库中创建一个新的键值对，其中：</p>
<ol>
<li>键值对的<strong>键是一个字符串对象</strong>，对象的<strong>底层实现是一个保存着字符串 <code>msg</code> 的 SDS</strong>。</li>
<li>键值对的<strong>值也是一个字符串对象</strong>，对象的<strong>底层实现是一个保存着字符串 <code>hello world</code> 的 SDS</strong>。</li>
</ol>
</li>
<li>
<p>除了用来保存数据库中的字符串值之外，SDS 还被用作<strong>缓冲区</strong>，其中<strong>AOF 模块中的 AOF 缓冲区</strong>，以及<strong>客户端状态中的输入缓冲区</strong>，都是 SDS 实现的。</p>
</li>
</ol>
<h5 id="2142-定义">
  2.1.4.2 定义
  <a class="anchor" href="#2142-%e5%ae%9a%e4%b9%89">#</a>
</h5>
<ol>
<li>
<p>SDS 的定义在源码中的 <code>src/sds.h/sdshdr</code> 中，其结构为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sdshdr</span> {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len;   <span style="color:#75715e">/*记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度*/</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> free;  <span style="color:#75715e">/*记录 buf 数组中未使用字节的数量*/</span>
    <span style="color:#66d9ef">char</span> buf[]; <span style="color:#75715e">/*字符数组，用于保存字符串*/</span>
};
</code></pre></div></li>
<li>
<p>结合下面的实例对上面定义中每个参数的具体含义说明如下：</p>
<p>
  <img src="../../../media/202107/2021-07-13_110621.png" alt="" /></p>
<ol>
<li><code>len</code>：记录<strong>buf 数组中已使用字节的数量</strong>，<strong>等于 SDS 所保存字符串的长度</strong>，实例中<code>len</code> 的值为 5，表示这个 SDS 保存了一个 5 字节长的字符串。</li>
<li><code>free</code>：记录<strong>buf 数组中未使用字节的数量</strong>，实例中<code>free</code> 的值为 0，表示这个 SDS 没有分配任何未使用的空间。</li>
<li><code>buf</code>：<strong>字符数组</strong>，用于<strong>保存字符串</strong>，实例中数组的前 5 个字节分别保存了<code>R</code>、<code>e</code>、<code>d</code>、<code>i</code>、<code>s</code>，最后一个字节保存了空字符<code>\0</code>。</li>
</ol>
</li>
<li>
<p>SDS<strong>遵循 C 字符串以空字符结尾的惯例</strong>，<strong>保存空字符的 1 字节空间</strong>，<strong>不计算在 SDS 的 <code>len</code> 属性里面</strong>，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是<strong>由 SDS 函数自动完成</strong>，所以这个<strong>空字符对于 SDS 的使用者来说是完全透明的</strong>，遵循空字符结尾这一惯例的好处是<strong>SDS 可以直接重用一部分 C 字符串函数库里面的函数</strong>。</p>
</li>
</ol>
<h5 id="2143-sds-与-c-字符串的区别">
  2.1.4.3 SDS 与 C 字符串的区别
  <a class="anchor" href="#2143-sds-%e4%b8%8e-c-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h5>
<p>根据传统，C 语言使用长度为 $N+1$ 的字符数组来表示长度为 $N$ 的字符串，并且字符数组的最后一个元素总是字符串 <code>\0</code>，这种简单的字符串表示方式，并<strong>不能满足 Redis 对字符串在安全性</strong>、<strong>效率以及功能方面的要求</strong>，下面将详细对比 C 字符串和 SDS 之间的区别，并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<h6 id="21431-常数复杂度获取字符串长度">
  2.1.4.3.1 常数复杂度获取字符串长度
  <a class="anchor" href="#21431-%e5%b8%b8%e6%95%b0%e5%a4%8d%e6%9d%82%e5%ba%a6%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6">#</a>
</h6>
<ol>
<li>因为<strong>C 字符串并不记录自身的长度信息</strong>，所以<strong>为了获取一个 C 字符串的长度</strong>，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的<strong>复杂度为 $O(N)$</strong>。</li>
<li>和 C 字符串不同，因为<strong>SDS 在 <code>len</code> 属性中记录了 SDS 本身的长度</strong>，所以<strong>获取一个 SDS 长度的复杂度仅为 $O(1)$</strong>。</li>
<li><strong>设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的</strong>，使用 SDS 时<strong>无须进行任何手动修改长度的工作</strong>。</li>
<li>通过使用 SDS 而不是 C 字符串，<strong>Redis 将获取字符串长度所需的复杂度从 $O(N)$ 降低到了 $O(1)$</strong>，这<strong>确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈</strong>。</li>
</ol>
<h6 id="21432-杜绝缓冲区溢出">
  2.1.4.3.2 杜绝缓冲区溢出
  <a class="anchor" href="#21432-%e6%9d%9c%e7%bb%9d%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba">#</a>
</h6>
<ol>
<li>
<p>除了<strong>获取字符串长度的复杂度高</strong>外，C 字符串不记录自身长度带来的另外一个问题是<strong>容易造成缓冲区溢出</strong>，例如 <code>&lt;string.h&gt;/strcat</code> 函数可以将 <code>src</code> 字符串中的内容拼接到 <code>dest</code> 字符串的末尾：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">strcat</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>src);
</code></pre></div></li>
<li>
<p>因为 C 字符串不记录自身的长度，所以 <code>strcat</code><strong>假定用户在执行这个函数时</strong>，<strong>已经为 <code>dest</code> 分配了足够多的内存</strong>，可以容纳 <code>src</code> 字符串中的所有内容，而<strong>一旦这个假定不成立</strong>时，<strong>就会产生缓冲区溢出</strong>。</p>
</li>
<li>
<p>与 C 字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：</p>
<ol>
<li>当 SDS API 需要对 SDS 进行修改时，API 会<strong>先检查 SDS 的空间是否满足修改所需的要求</strong>，<strong>如果不满足的话</strong>，API<strong>会自动将 SDS 的空间扩展至执行修改所需的大小</strong>，<strong>然后才执行实际的修改操作</strong>，所以<strong>使用 SDS 既不需要手动修改 SDS 的空间大小</strong>，<strong>也不会出现缓冲区溢出问题</strong>。</li>
</ol>
</li>
</ol>
<h6 id="21433-减少修改字符串时带来的内存重分配次数">
  2.1.4.3.3 减少修改字符串时带来的内存重分配次数
  <a class="anchor" href="#21433-%e5%87%8f%e5%b0%91%e4%bf%ae%e6%94%b9%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%97%b6%e5%b8%a6%e6%9d%a5%e7%9a%84%e5%86%85%e5%ad%98%e9%87%8d%e5%88%86%e9%85%8d%e6%ac%a1%e6%95%b0">#</a>
</h6>
<ol>
<li>因为 C 字符串并不记录自身的长度，因此<strong>每次增长或者缩短一个 C 字符串</strong>，<strong>程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作</strong>。</li>
<li>因为<strong>内存重分配设计复杂的算法</strong>，并且<strong>可能需要执行系统调用</strong>，所以他<strong>通常是一个比较耗时的操作</strong>。</li>
<li>在一般的程序中，如果每次修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的，但是 Redis 作为数据库，<strong>经常被用于速度要求严苛</strong>、<strong>数据被频繁修改</strong>的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是<strong>执行内存重分配的时间就会占去修改字符串所用时间的一大部分</strong>，如果这种修改频繁发生的话，可能还<strong>会对性能造成影响</strong>。</li>
<li>为了避免 C 字符串的这种缺陷，SDS 通过未使用空间实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略：
<ol>
<li><strong>空间预分配</strong>：
<ol>
<li>空间预分配<strong>用于优化 SDS 的字符串增长操作</strong>，<strong>当 SDS 的 API 对一个 SDS 进行修改</strong>，并且<strong>需要对 SDS 进行空间扩展的时候</strong>，程序<strong>不仅会为 SDS 分配修改所必要的空间</strong>，<strong>还会为 SDS 分配额外的未使用空间</strong>，分配的未使用空间数量由以下公式决定：
<ol>
<li>如果<strong>对 SDS 进行修改之后</strong>，<strong>SDS 的长度</strong>（也即是<code>len</code> 属性的值）<strong>小于 1MB</strong>，那么程序<strong>分配和 <code>len</code> 属性同样大小的未使用空间</strong>，这时 SDS 的<code>len</code><strong>属性的值将和 <code>free</code> 属性的值相同</strong>，例如，如果进行修改之后，SDS 的<code>len</code> 将变成 13 字节，那么程序也会分配 13 字节的未使用空间，SDS 的<code>buf</code> 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的 1 字节用于保存空字符）。</li>
<li>如果<strong>对 SDS 进行修改之后</strong>，<strong>SDS 的长度大于 1MB</strong>，那么程序<strong>会分配 1MB 的未使用空间</strong>，例如，如果进行修改之后，SDS 的<code>len</code> 将变成 30MB，那么程序会分配 1MB 的未使用空间，SDS 的<code>buf</code> 数组的实际长度将为 30MB + 1MB + 1byte。</li>
</ol>
</li>
<li>在<strong>扩展 SDS 之前</strong>，SDS API<strong>会先检查未使用空间是否足够</strong>，<strong>如果足够的话</strong>，API 就<strong>会直接使用未使用空间</strong>，而<strong>无需执行内存重分配</strong>。</li>
<li>通过空间预分配策略，Redis 可以<strong>减少连续执行字符串增长操作所需的内存重分配次数</strong>。</li>
</ol>
</li>
<li><strong>惰性空间释放</strong>：
<ol>
<li>惰性空间释放用于<strong>优化 SDS 的字符串缩短操作</strong>，<strong>当 SDS 的 API 需要缩短 SDS 保存的字符串时</strong>，程序并<strong>不立即使用内存重分配来回收缩短后多出来的字节</strong>，而是<strong>使用 <code>free</code> 属性将这些字节的数量记录起来</strong>，并<strong>等待将来使用</strong>。</li>
<li>通过惰性空间释放策略，SDS<strong>避免了缩短字符串时所需的内存重分配操作</strong>，并<strong>为将来可能有的增长操作提供了优化</strong>。</li>
<li>同时，SDS 也提供了相应的 API，让我们可以<strong>在有需要时</strong>，<strong>真正地释放 SDS 的未使用空间</strong>，所以<strong>不用担心惰性空间释放策略会造成内存浪费</strong>。</li>
<li>例如：
<ol>
<li>
<p><code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数，<strong>移除 SDS 中所有在 C 字符串中出现过的字符</strong>。</p>
</li>
<li>
<p>假如有一个 SDS 值 <code>s</code> 为 <code>XYXaYYbcXYX</code>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_151706.png" alt="" /></p>
</li>
<li>
<p>当执行完 <code>sdstrim(s, &quot;XY&quot;)</code>（移除 SDS 字符串中的所有 <code>X</code> 和 <code>Y</code>）命令后，SDS 被修改为 <code>abc</code>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_152155.png" alt="" /></p>
</li>
<li>
<p>此时 SDS 并没有释放多出来的 8 字节空间，而是将这 8 字节空间作为未使用空间保留在了 SDS 里面，如果将来要对 SDS 进行增长操作的话，这些未使用空间就可能会派上用场。</p>
</li>
<li>
<p>例如，现在对 <code>s</code> 执行 <code>sdscat(s, &quot; Redis&quot;)</code>，执行完成之后，<code>s</code> 被修改为 <code>abc Redis</code>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_152539.png" alt="" /></p>
</li>
<li>
<p>完成这次 <code>sdscat</code> 操作将不需要执行内存重分配，因为 SDS 里面预留的 8 字节空间已经足以拼接 6 个字节长的 <code> Redis</code>。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h6 id="21434-二进制安全">
  2.1.4.3.4 二进制安全
  <a class="anchor" href="#21434-%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ae%89%e5%85%a8">#</a>
</h6>
<ol>
<li>C 字符串中的字符必须<strong>符合某种编码</strong>（比如 ASCII），并且<strong>除了字符串末尾之外</strong>，<strong>字符串里面不能包含空字符</strong>，<strong>否则</strong>最先被程序读入的空字符将<strong>被误认为是字符串结尾</strong>，这些限制使得<strong>C 字符串只能保存文本数据</strong>，而<strong>不能保存像图片</strong>、<strong>音频</strong>、<strong>视频</strong>、<strong>压缩文件这样的二进制数据</strong>。</li>
<li>为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是<strong>二进制安全</strong>的，所有 SDS API 都<strong>会以处理二进制的方式来处理 SDS 存放在 <code>buf</code> 数组里的数据</strong>，程序<strong>不会对其中的数据做任何限制</strong>、<strong>过滤</strong>、<strong>假设</strong>，<strong>数据在写入时是什么样的</strong>，他<strong>被读取时就是什么样的</strong>，这也是我们将 SDS 的<code>buf</code> 属性称为<strong>字节数组</strong>的原因，因为<strong>Redis 不是用这个数组来保存字符</strong>，<strong>而是用来保存一系列二进制数据</strong>。</li>
</ol>
<h6 id="21345-兼容部分-c-字符串函数">
  2.1.3.4.5 兼容部分 C 字符串函数
  <a class="anchor" href="#21345-%e5%85%bc%e5%ae%b9%e9%83%a8%e5%88%86-c-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0">#</a>
</h6>
<ol>
<li>虽然 SDS 的 API 都是二进制安全的，但他们一样<strong>遵循 C 字符串以空字符结尾的惯例</strong>，这些 API 总会<strong>将 SDS 保存的数据的末尾设置为空字符</strong>，并且总会<strong>在为 <code>buf</code> 数组分配空间时多分配一个字节来容纳这个空字符</strong>，这是为了<strong>让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code> 库定义的函数</strong>。</li>
</ol>
<h3 id="22-列表">
  2.2 列表
  <a class="anchor" href="#22-%e5%88%97%e8%a1%a8">#</a>
</h3>
<h4 id="221-存储数据">
  2.2.1 存储数据
  <a class="anchor" href="#221-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae">#</a>
</h4>
<ol>
<li>列表可以<strong>有序地存储多个字符串</strong>，并且<strong>列表里的元素是可以重复的</strong>，可以<strong>对列表的两端进行插入或者弹出元素操作</strong>。</li>
</ol>
<h4 id="222-使用场景">
  2.2.2 使用场景
  <a class="anchor" href="#222-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ol>
<li><strong>消息队列</strong>。</li>
</ol>
<h4 id="223-数据结构">
  2.2.3 数据结构
  <a class="anchor" href="#223-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li>在 Redis 中，<code>List</code> 底层有两种数据结构，分别为<strong>链表</strong>（LinkedList）和<strong>压缩列表</strong>（ZipList）：
<ol>
<li>当<code>List</code><strong>元素个数少</strong>且<strong>元素内容长度不大</strong>时，使用<code>ZipList</code><strong>实现</strong>。</li>
<li>否则，使用<code>LinkedList</code><strong>实现</strong>。</li>
</ol>
</li>
</ol>
<h4 id="224-链表">
  2.2.4 链表
  <a class="anchor" href="#224-%e9%93%be%e8%a1%a8">#</a>
</h4>
<h5 id="2241-前言">
  2.2.4.1 前言
  <a class="anchor" href="#2241-%e5%89%8d%e8%a8%80">#</a>
</h5>
<ol>
<li>链表提供了<strong>高效的节点重排能力</strong>，以及<strong>顺序性的节点访问方式</strong>，并且<strong>可以通过增删节点来灵活地调整链表的长度</strong>。</li>
<li>作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为 Redis 使用的 C 语言并没有内置这种数据结构，所以<strong>Redis 构建了自己的链表实现</strong>。</li>
<li>链表在 Redis 中的应用非常广泛：
<ol>
<li>列表键的底层实现之一就是链表，当一个链表键<strong>包含了数量比较多的元素</strong>，或者列表中<strong>包含的元素都是比较长的字符串时</strong>，Redis 就会<strong>使用链表作为列表键的底层实现</strong>。</li>
<li>同时，<strong>发布与订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>等功能也用到了链表。</li>
<li>Redis 服务器本身该使用链表<strong>保存多个客户端的状态信息</strong>，以及使用链表来<strong>构建客户端输出缓冲区</strong>。</li>
</ol>
</li>
</ol>
<h5 id="2242-实现">
  2.2.4.2 实现
  <a class="anchor" href="#2242-%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<h6 id="22421-链表节点">
  2.2.4.2.1 链表节点
  <a class="anchor" href="#22421-%e9%93%be%e8%a1%a8%e8%8a%82%e7%82%b9">#</a>
</h6>
<ol>
<li>
<p>每个链表节点使用一个 <code>src/adlist.h/listNode</code> 结构来表示，具体如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">listNode</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">listNode</span> <span style="color:#f92672">*</span>prev;  <span style="color:#75715e">/*前置节点*/</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">listNode</span> <span style="color:#f92672">*</span>next;  <span style="color:#75715e">/*后置节点*/</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value;    <span style="color:#75715e">/*节点的值*/</span>
} listNode;
</code></pre></div></li>
<li>
<p>多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成<strong>双链表</strong>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_163156.png" alt="" /></p>
</li>
</ol>
<h6 id="22422-链表">
  2.2.4.2.2 链表
  <a class="anchor" href="#22422-%e9%93%be%e8%a1%a8">#</a>
</h6>
<ol>
<li>
<p>虽然使用多个 <code>listNode</code> 结构就可以组成链表，但使用 <code>src/adlist.h/list</code> 来持有链表的话，<strong>操作起来会更方便</strong>，具体结构如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">list</span> {
    listNode <span style="color:#f92672">*</span>head; <span style="color:#75715e">/*表头结点*/</span>
    listNode <span style="color:#f92672">*</span>tail; <span style="color:#75715e">/*表尾节点*/</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>dup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);    <span style="color:#75715e">/*节点值复制函数*/</span>
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>free)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);    <span style="color:#75715e">/*节点值释放函数*/</span>
    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key); <span style="color:#75715e">/*节点值对比函数*/</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len;  <span style="color:#75715e">/*链表所包含的节点数量*/</span>
} list;
</code></pre></div></li>
<li>
<p><code>list</code> 结构为链表提供了表头指针 <code>head</code>、表尾指针 <code>tail</code>、以及链表长度计数器 <code>len</code>，还提供了 <code>dup</code>、<code>free</code>、和 <code>match</code> 成员用于实现<strong>多态链表</strong>所需的类型特定函数，具体如下：</p>
<ol>
<li><code>dup</code>：<strong>节点值复制函数</strong>。</li>
<li><code>free</code>：<strong>节点值释放函数</strong>。</li>
<li><code>match</code>：<strong>节点值对比函数</strong>。</li>
</ol>
</li>
<li>
<p><code>list</code> 可以<strong>和 <code>listNode</code> 结合组成链表</strong>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-13_165739.png" alt="" /></p>
</li>
<li>
<p>Redis 的链表具有如下特性：</p>
<ol>
<li><strong>双端</strong>：链表节点<strong>都带有 <code>prev</code> 和 <code>next</code> 指针</strong>，<strong>获取某个前置节点和后置节点的复杂度都是 $O(1)$</strong>。</li>
<li><strong>无环</strong>：<strong>表头结点的 <code>prev</code> 指针和表尾节点的 <code>next</code> 指针都指向 <code>NULL</code></strong>，对链表的访问<strong>以 <code>NULL</code> 为终点</strong>。</li>
<li><strong>带表头指针和表尾指针</strong>：通过<code>list</code> 的<code>head</code> 指针和<code>tail</code> 指针，程序<strong>获取链表的头结点和尾节点的复杂度为 $O(1)$</strong>。</li>
<li><strong>带链表长度计算器</strong>：程序使用<code>list</code> 结构的<code>len</code> 属性来对<code>list</code> 持有的链表节点进行计数，程序<strong>获取链表中节点数量的复杂度为 $O(1)$</strong>。</li>
<li><strong>多态</strong>：链表节点<strong>使用 <code>void*</code> 指针来保存节点值</strong>，并且可以<strong>通过 <code>list</code> 结构的 <code>dup</code></strong>、<code>free</code>、<code>match</code><strong>三个属性为节点值设置类型特定函数</strong>，所以链表可以<strong>用于保存不同类型的值</strong>。</li>
</ol>
</li>
</ol>
<h4 id="225-压缩列表">
  2.2.5 压缩列表
  <a class="anchor" href="#225-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8">#</a>
</h4>
<h5 id="2251-前言">
  2.2.5.1 前言
  <a class="anchor" href="#2251-%e5%89%8d%e8%a8%80">#</a>
</h5>
<ol>
<li>压缩列表<strong>是列表键和哈希键的底层实现之一</strong>。</li>
<li>当一个列表键<strong>只包含少量列表项</strong>，并且<strong>每个列表项要么就是小整数值</strong>，<strong>要么就是长度比较短的字符串</strong>，那么 Redis 就会<strong>使用压缩列表来做列表键的底层实现</strong>。</li>
<li>当一个哈希键<strong>只包含少量键值对</strong>，并且<strong>每个键值对的键和值要么就是小整数值</strong>，<strong>要么就是长度比较短的字符串</strong>，那么 Redis 就会<strong>使用压缩列表来做哈希键的底层实现</strong>。</li>
</ol>
<h5 id="2252-实现">
  2.2.5.2 实现
  <a class="anchor" href="#2252-%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<ol>
<li>
<p>压缩列表是 Redis<strong>为了节约内存而开发的</strong>，是<strong>由一系列特殊编码的连续内存块组成的顺序型数据结构</strong>。</p>
</li>
<li>
<p><strong>一个压缩列表可以包含任意多个节点</strong>，<strong>每个节点可以保存一个字节数组或者一个整数值</strong>。</p>
</li>
<li>
<p>压缩列表的结构如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-14_101549.png" alt="" /></p>
<ol>
<li><code>zlbytes</code>：<code>uint32_t</code> 类型，大小为 4 字节，主要用于<strong>记录整个压缩列表占用的内存字节数</strong>，在<strong>对压缩列表进行内存重分配</strong>或者<strong>计算 <code>zlend</code> 的位置时使用</strong>。</li>
<li><code>zltail</code>：<code>uint32_t</code> 类型，大小为 4 字节，主要用于<strong>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</strong>，通过这个偏移量，程序<strong>无须遍历整个压缩列表就可以确定表尾节点的地址</strong>。</li>
<li><code>zllen</code>：<code>uint16_t</code> 类型，大小为 2 字节，主要用于<strong>记录压缩列表包含的节点数量</strong>，<strong>当这个属性值小于 <code>UINT_MAX</code></strong>（65535）<strong>时</strong>，<strong>这个属性的值就是压缩列表包含节点的数量</strong>，<strong>当这个值等于 <code>UINT16_MAX</code> 时</strong>，<strong>节点的真实数量需要遍历整个列表才能计算得出</strong>。</li>
<li><code>entryX</code>：<strong>列表节点</strong>，长度不定，指<strong>压缩列表包含的各个节点</strong>，<strong>节点的长度由节点保存的内容决定</strong>。</li>
<li><code>zlend</code>：<code>uint_8t</code>，大小为 1 字节，使用特殊值<code>0xFF</code>（十进制 255），用于<strong>标记压缩列表的末端</strong>。</li>
</ol>
</li>
<li>
<p>压缩列表的示例如下：</p>
<p>
  <img src="../../../media/202107/2021-07-14_110450.png" alt="" /></p>
<ol>
<li>列表<code>zlbytes</code> 的值为<code>0x50</code>（十进制 80），表示压缩列表的总长为 80 字节。</li>
<li>列表<code>zltail</code> 的值为<code>0x3c</code>（十进制 60），表示如果我们有一个指向压缩列表起始地址的指针<code>p</code>，那么只要用指针<code>p</code> 加上偏移量 60，就可以计算出表尾节点<code>entry3</code> 的地址。</li>
<li>列表<code>zllen</code> 属性的值为<code>0x3</code>（十进制 3），表示压缩列表包含三个节点。</li>
</ol>
</li>
</ol>
<h3 id="23-哈希">
  2.3 哈希
  <a class="anchor" href="#23-%e5%93%88%e5%b8%8c">#</a>
</h3>
<h4 id="231-存储数据">
  2.3.1 存储数据
  <a class="anchor" href="#231-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae">#</a>
</h4>
<ol>
<li><code>Hash</code> 存的是<strong>字符串和字符串值之间的映射</strong>。</li>
<li><code>Hash</code> 将对象的各个属性存入<code>Map</code> 里，可以<strong>只读取或更新对象的某些属性</strong>。</li>
</ol>
<h4 id="232-使用场景">
  2.3.2 使用场景
  <a class="anchor" href="#232-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ol>
<li><strong>存放结构化数据</strong>，比如<strong>用户信息</strong>，<code>key</code> 是用户<code>ID</code>，<code>value</code> 是一个<code>Map</code>，这个<code>Map</code> 的<code>key</code> 是成员的属性名，<code>value</code> 是属性值，这样对数据的修改和存取都可以直接通过其内部的<code>key</code> 来实现，既<strong>不需要重复存储数据</strong>，也<strong>不会带来序列化和并发修改控制的问题</strong>。</li>
<li><strong>建索引</strong>，比如<code>User</code> 对象，除了<code>id</code> 有时还要按<code>name</code> 来查询，可以建一个<code>key</code> 为<code>user:name:id</code> 的<code>Hash</code>，在插入<code>User</code> 对象（<code>set user:101{&quot;id&quot;:101,&quot;name&quot;:&quot;calvin&quot;}</code>）时，顺便往这个<code>Hash</code> 插入一条<code>hset user:name:id calvin 101</code>，这时<code>calvin</code> 作为<code>Hash</code> 里的一个<code>key</code>，值为 101，按<code>name</code> 查询的时候，用<code>hgetuser:name:id calvin</code> 就能从名为<code>calvin</code> 的<code>key</code> 里取出<code>id</code>。</li>
</ol>
<h4 id="233-数据结构">
  2.3.3 数据结构
  <a class="anchor" href="#233-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li><code>Hash</code> 底层有两种实现，分别是<strong>压缩列表</strong>和<strong>字典</strong>：
<ol>
<li>当一个哈希键<strong>只包含少量键值对</strong>，并且<strong>每个键值对的键和值要么就是小整数值</strong>，<strong>要么就是长度比较短的字符串</strong>，那么 Redis 就会<strong>使用压缩列表来做哈希键的底层实现</strong>。</li>
<li>但一个哈希键<strong>包含的键值对比较多</strong>，或者<strong>键值对中的元素都是比较长的字符串时</strong>，Redis 就会<strong>使用字典作为哈希键的底层实现</strong>。</li>
</ol>
</li>
<li>压缩链表的内容上面已经叙述过，具体可参考
  <a href="/school-recruitment/#2-2-5-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8">2.2.5 压缩列表</a>，下面将主要叙述字典相关的内容。</li>
</ol>
<h4 id="234-字典">
  2.3.4 字典
  <a class="anchor" href="#234-%e5%ad%97%e5%85%b8">#</a>
</h4>
<h5 id="2341-前言">
  2.3.4.1 前言
  <a class="anchor" href="#2341-%e5%89%8d%e8%a8%80">#</a>
</h5>
<ol>
<li>字典是一种用于<strong>保存键值对的抽象数据结构</strong>。</li>
<li>字典经常作为一种数据结构内置在很多高级编程语言里面，但 Redis 所使用的的 C 语言并没有内置这种数据结构，因此 Redis<strong>构建了自己的字典实现</strong>。</li>
<li>字典在 Redis 中的应用非常广泛：
<ol>
<li><strong>Redis 的数据库就是使用字典来作为底层实现的</strong>，<strong>对数据库的增</strong>、<strong>删</strong>、<strong>改</strong>、<strong>查操作都是构建在对字典的操作之上的</strong>：
<ol>
<li>
<p>例如，当我们执行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">redis&gt; SET msg <span style="color:#e6db74">&#34;hello world&#34;</span>
OK
</code></pre></div></li>
<li>
<p>此时，就会在数据库中创建一个键为 <code>msg</code>，值为 <code>hello world</code> 的键值对，这个键值对就是保存在代表数据库的字典里面的。</p>
</li>
</ol>
</li>
<li>字典也<strong>是哈希键的底层实现之一</strong>，当一个<strong>哈希键包含的键值对比较多</strong>，或者<strong>键值对中的元素都是比较长的字符串时</strong>，Redis 就会<strong>使用字典作为哈希键的底层实现</strong>：
<ol>
<li>
<p>例如，<code>wensite</code> 是一个包含 10086 个键值对的哈希键，这个哈希键的键都是一些数据库的名字，而键的值就是数据库的主页网址：</p>
<pre><code>redis&gt; HLEN website
(integer) 10086

redis&gt; HGETALL website
1)&quot;Redis&quot;
2)&quot;Redis.io&quot;
3)&quot;MariaDB&quot;
4)&quot;MariaDB.org&quot;
5)&quot;MongoDB&quot;
6)&quot;MongoDB.org&quot;
# ...
</code></pre></li>
<li>
<p><code>website</code> 的底层实现就是一个字典，字典中包含了 10086 个键值对，例如：</p>
<ol>
<li>键值对的键为<code>Redis</code>，值为<code>Redis.io</code>。</li>
<li>键值对的键为<code>MariaDB</code>，值为<code>MariaDB.org</code>。</li>
<li>键值对的键为<code>MongoDB</code>，值为<code>MongoDB.org</code>。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="2342-实现">
  2.3.4.2 实现
  <a class="anchor" href="#2342-%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<blockquote>
<p>Redis 的字典<strong>使用哈希表作为底层实现</strong>，<strong>一个哈希表里面可以有多个哈希表节点</strong>，而<strong>每个哈希表节点就保存了字典中的一个键值对</strong>。</p>
</blockquote>
<h6 id="23421-哈希表">
  2.3.4.2.1 哈希表
  <a class="anchor" href="#23421-%e5%93%88%e5%b8%8c%e8%a1%a8">#</a>
</h6>
<ol>
<li>
<p>Redis 字典所使用的的哈希表由 <code>src/dict.h/dictht</code> 定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dictht</span> {
    dictEntry <span style="color:#f92672">**</span>table;  <span style="color:#75715e">/*哈希表数组*/</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size; <span style="color:#75715e">/*哈希表大小*/</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask; <span style="color:#75715e">/*哈希表大小掩码，用于计算索引值，总是等于 size - 1*/</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used; <span style="color:#75715e">/*该哈希表已有节点的数量*/</span>
} dictht;
</code></pre></div><ol>
<li><code>table</code>：表示<strong>哈希表数组</strong>，数组中的<strong>每个元素都是一个指向 <code>src/dict.h/dictEntry</code> 结构的指针</strong>，<strong>每个 <code>dictEntry</code> 结构保存着一个键值对</strong>。</li>
<li><code>size</code>：表示<strong>哈希表的大小</strong>，也即是<strong>哈希表数组的大小</strong>。</li>
<li><code>used</code>：表示<strong>哈希表已有节点的数量</strong>。</li>
<li><code>sizemask</code>：表示<strong>哈希表大小掩码</strong>，<strong>总是等于 <code>size - 1</code></strong>，这个属性<strong>和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面</strong>。</li>
</ol>
</li>
<li>
<p>哈希表的示例如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-14_142200.png" alt="" /></p>
</li>
</ol>
<h6 id="23422-哈希表节点">
  2.3.4.2.2 哈希表节点
  <a class="anchor" href="#23422-%e5%93%88%e5%b8%8c%e8%a1%a8%e8%8a%82%e7%82%b9">#</a>
</h6>
<ol>
<li>
<p>哈希表节点<strong>使用 <code>dictEntry</code> 结构表示</strong>，<strong>每个 <code>dictEntry</code> 结构都保存着一个键值对</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dictEntry</span> {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;  <span style="color:#75715e">/*键*/</span>
    <span style="color:#66d9ef">union</span> { <span style="color:#75715e">/*值*/</span>
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dictEntry</span> <span style="color:#f92672">*</span>next; <span style="color:#75715e">/*指向下个哈希表节点，形成链表*/</span>
} dictEntry;
</code></pre></div><ol>
<li><code>key</code>：表示键值对中的<strong>键</strong>。</li>
<li><code>v</code>：表示键值对中的<strong>值</strong>，其中<strong>键值对的值可以是一个指针</strong>、<code>uint64_t</code><strong>的整数</strong>、<code>int64_t</code><strong>的整数</strong>、<strong>双精度类型的浮点数</strong>。</li>
<li><code>next</code>：表示<strong>指向下个哈希节点的指针</strong>，<strong>这个指针可以将多个哈希值相同的键值对连接在一起</strong>，以此来<strong>解决键冲突的问题</strong>：
<ol>
<li>
<p>如下图所示就是将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起：</p>
<p>
  <img src="../../../media/202107/2021-07-14_143147.png" alt="" /></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h6 id="23423-字典">
  2.3.4.2.3 字典
  <a class="anchor" href="#23423-%e5%ad%97%e5%85%b8">#</a>
</h6>
<ol>
<li>
<p>Redis 中的字典<strong>由 <code>src/dict.h/dict</code> 结构表示</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dict</span> {
    dictType <span style="color:#f92672">*</span>type; <span style="color:#75715e">/*类型特定函数*/</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata; <span style="color:#75715e">/*私有数据*/</span>
    dictht ht[<span style="color:#ae81ff">2</span>];   <span style="color:#75715e">/*哈希表*/</span>
    <span style="color:#66d9ef">long</span> rehashidx; <span style="color:#75715e">/* rehash 索引，当 rehash 不再进行时，值为 1 rehashing not in progress if rehashidx == -1 */</span>
    <span style="color:#66d9ef">int</span> iterators; <span style="color:#75715e">/* 当前正在运行的迭代器数量 number of iterators currently running */</span>
} dict;
</code></pre></div><ol>
<li>
<p><code>type</code>：<strong>指向 <code>dictType</code> 结构的指针</strong>，<strong>每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数</strong>，Redis 会<strong>为用途不同的字典设置不同的类型特定函数</strong>。</p>
</li>
<li>
<p><code>privdata</code>：<strong>保存了需要传给那些类型特定函数的可选参数</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dictType</span> {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>hashFunction)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);  <span style="color:#75715e">/*计算哈希值的函数*/</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>keyDup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);   <span style="color:#75715e">/*复制键的函数*/</span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>valDup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);   <span style="color:#75715e">/*复制值的函数*/</span>
    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>keyCompare)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);  <span style="color:#75715e">/*对比键的函数*/</span>
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>keyDestructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);   <span style="color:#75715e">/*销毁键的函数*/</span>
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>valDestructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);   <span style="color:#75715e">/*销毁值的函数*/</span>
} dictType;
</code></pre></div><blockquote>
<p><code>type</code> 属性和 <code>privdata</code> 属性是<strong>针对不同类型的键值对</strong>，<strong>为创建多态字典而设置的</strong>。</p>
</blockquote>
</li>
<li>
<p><code>ht</code>：是一个<strong>包含两个项的数组</strong>，<strong>数组中的每个项都是一个 <code>dictht</code> 哈希表</strong>，一般情况下，<strong>字典只使用 <code>ht[0]</code> 哈希表</strong>，<code>ht[1]</code><strong>哈希表只会在对 <code>ht[0]</code> 进行 <code>rehash</code> 时使用</strong>。</p>
</li>
<li>
<p><code>rehashidx</code>：<strong>记录了 <code>rehash</code> 目前的进度</strong>，<strong>如果目前没有在进行 <code>hash</code></strong>，<strong>那么他的值为-1</strong>。</p>
</li>
</ol>
</li>
<li>
<p>下图展示了一个普通状态下（没有进行 <code>rehash</code>）的字典：</p>
<p>
  <img src="../../../media/202107/2021-07-14_144923.png" alt="" /></p>
</li>
</ol>
<h6 id="23424-哈希算法">
  2.3.4.2.4 哈希算法
  <a class="anchor" href="#23424-%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95">#</a>
</h6>
<ol>
<li>
<p>当要<strong>将一个新的键值对添加到字典里面</strong>时，程序需要<strong>先根据键值对的键值计算出哈希值和索引值</strong>，<strong>然后再根据索引值</strong>，<strong>将包含新键值对的哈希表节点放到哈希数组指定的索引上面</strong>。</p>
</li>
<li>
<p>哈希值和索引值的计算方法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 使用字典设置的哈希函数，计算键 key 的哈希值
</span><span style="color:#75715e"></span>hash <span style="color:#f92672">=</span> dict<span style="color:#f92672">-&gt;</span>type<span style="color:#f92672">-&gt;</span>hashFunction(key);

<span style="color:#75715e">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值
</span><span style="color:#75715e">// 根据情况不同，ht[x] 可以是 ht[0] 或是 ht[1]
</span><span style="color:#75715e"></span>index <span style="color:#f92672">=</span> hash <span style="color:#f92672">&amp;</span> dict<span style="color:#f92672">-&gt;</span>ht[x].sizemask;
</code></pre></div></li>
<li>
<p>当<strong>字典被用作数据库的底层实现</strong>，<strong>或者哈希键的底层实现</strong>，Redis<strong>使用 <code>MurmurHash2</code> 算法来计算键值的哈希值</strong>，该算法的优点是<strong>即使输入的键是有规律的</strong>，<strong>算法仍能给出一个很好的随机分布性</strong>，并且<strong>算法的计算速度也非常快</strong>。</p>
</li>
</ol>
<h6 id="23425-解决键值冲突">
  2.3.4.2.5 解决键值冲突
  <a class="anchor" href="#23425-%e8%a7%a3%e5%86%b3%e9%94%ae%e5%80%bc%e5%86%b2%e7%aa%81">#</a>
</h6>
<ol>
<li>
<p>Redis 的哈希表<strong>使用链地址法来解决键值冲突问题</strong>，<strong>每个哈希表节点都有一个 <code>next</code> 指针</strong>，<strong>多个哈希表节点可以构成一个单向链表</strong>，<strong>被分配到同一个索引上的多个节点可以用这个单向链表连接起来</strong>，<strong>这就解决了键值冲突问题</strong>。</p>
</li>
<li>
<p>因为 <code>dictEntry</code><strong>节点组成的链表没有指向链表表尾的指针</strong>，所以<strong>为了速度考虑</strong>，程序总是<strong>将新节点添加到链表的表头位置</strong>，<strong>排在其它已有节点的前面</strong>。</p>
<blockquote>
<p>常见的解决键值冲突的方法主要有以下几种：</p>
<ol>
<li><strong>开放定址法</strong>：
<ol>
<li>
<p>也叫<strong>再散列法</strong>，<strong>当关键字 $key$ 的哈希地址 $p = H(key)$ 出现冲突时</strong>，<strong>以 $p$ 为基础</strong>，<strong>产生另一个哈希地址 $p_1$</strong>，<strong>如果 $p_1$ 仍然冲突</strong>，<strong>再以 $p_1$ 为基础产生另一个哈希地址 $p_2$</strong>，&hellip;，<strong>直到找出一个不冲突的哈希地址 $p_i$</strong>，<strong>将相应程序存入其中</strong>。</p>
</li>
<li>
<p>通常都是用以下公式计算：</p>
<p>$$
H(i) = (H(key) + d_i) % m \space i = 1, 2,&hellip;, n
$$</p>
<ol>
<li>其中 $H(key)$ <strong>为哈希函数</strong>，$m$ <strong>为表长</strong>，$d_i$ <strong>为增量序列</strong>，<strong>增量序列的取值方式不同</strong>，<strong>相应的再散列方式也不同</strong>，主要有三种：
<ol>
<li><strong>线性探测再散列</strong>：<strong>冲突发生时</strong>，<strong>顺序查看表中下一单元</strong>，<strong>直到找出一个空单元或查遍全表</strong>。</li>
<li><strong>二次探测再散列</strong>：<strong>冲突发生时</strong>，<strong>在表的右边进行跳跃式探测</strong>，<strong>直到找到空单元</strong>。</li>
<li><strong>伪随机探测再散列</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>链地址法</strong>：
<ol>
<li>这种方法的基本思想是<strong>将所有哈希地址为 $i$ 的元素构成一个称为同义词链的单链表</strong>，<strong>并将单链表的头指针存在哈希表的第 $i$ 个单元中</strong>，因而<strong>查找</strong>、<strong>插入和删除主要在同义词链中进行</strong>。</li>
<li><strong>链地址法适用于经常进行插入和删除的情况</strong>，例如<code>HashMap</code> 就是利用这种方法解决 Hash 冲突的。</li>
</ol>
</li>
<li><strong>再哈希法</strong>：
<ol>
<li><strong>多写几个哈希函数</strong>，<strong>算出来一个 <code>hashcode</code> 重复的就用另一个哈希函数算</strong>，<strong>直到算出来不一样</strong>。</li>
</ol>
</li>
<li><strong>建立一个公共溢出区域</strong>，就是<strong>把冲突的都放在另一个地方</strong>，<strong>不在表里面</strong>。</li>
</ol>
</blockquote>
</li>
</ol>
<h6 id="23426-rehash">
  2.3.4.2.6 rehash
  <a class="anchor" href="#23426-rehash">#</a>
</h6>
<blockquote>
<p><strong>负载因子</strong> = 哈希表<strong>已经保存节点数量</strong> / <strong>哈希表大小</strong></p>
</blockquote>
<ol>
<li>
<p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了<strong>让哈希表的负载因子维持在一个合理的范围之内</strong>，<strong>当哈希表保存的键值对数量太多或者太少时</strong>，程序<strong>需要对哈希表的大小进行相应的扩展或收缩</strong>。</p>
</li>
<li>
<p>扩展或收缩哈希表的工作可以通过 <code>rehash</code>（重新散列）操作来完成，具体步骤如下：</p>
<ol>
<li><strong>为字典 <code>ht[1]</code> 哈希表分配空间</strong>，这个哈希表空间的<strong>大小取决于要执行的操作</strong>，<strong>以及 <code>ht[0]</code> 当前包含的键值对的数量</strong>（也即是<code>ht[0].used</code> 属性的值）：
<ol>
<li>如果执行的是<strong>扩展</strong>操作，那么<code>ht[1]</code> 的大小为<strong>第一个大于等于 <code>ht[0].used * 2</code> 的 $ 2^n $</strong>。</li>
<li>如果执行的是<strong>收缩</strong>操作，那么<code>ht[1]</code> 的大小为<strong>第一个大于等于 <code>ht[0].used</code> 的 $ 2^n $</strong>。</li>
</ol>
</li>
<li><strong>将保存在 <code>ht[0]</code> 中的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 上面</strong>，<code>rehash</code> 指的是<strong>重新计算键的哈希值和索引值</strong>，然后<strong>将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上</strong>。</li>
<li><strong>当 <code>ht[0]</code> 包含的所有键值对迁移到 <code>ht[1]</code> 之后</strong>（<code>ht[0]</code> 变为空表），<strong>释放 <code>ht[0]</code></strong>，<strong>将 <code>ht[1]</code> 设置为 <code>ht[0]</code></strong>，并<strong>在 <code>ht[1]</code> 新建一个空白哈希表</strong>，<strong>为下一次 <code>rehash</code> 做准备</strong>。</li>
</ol>
</li>
<li>
<p>具体的 <code>rehash</code> 例子如下：</p>
<p>
  <img src="../../../media/202107/2021-07-14_155443.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_155513.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_155603.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_155627.png" alt="" /></p>
</li>
</ol>
<h6 id="23427-渐进式-rehash">
  2.3.4.2.7 渐进式 rehash
  <a class="anchor" href="#23427-%e6%b8%90%e8%bf%9b%e5%bc%8f-rehash">#</a>
</h6>
<ol>
<li>
<p>扩展和收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 里面，但是，这个 <code>rehash</code><strong>动作不是一次性</strong>、<strong>集中式地完成的</strong>，<strong>而是分多次</strong>、<strong>渐进式地完成的</strong>。</p>
</li>
<li>
<p>因为 Redis 是<strong>单进程</strong>的，如果哈希表中保存的键值对数量过多的话，当一次性将所有键值对全部 <code>rehash</code> 到 <code>ht[1]</code> 的话，<strong>庞大的计算量可能会导致服务器在一段时间内停止服务</strong>。</p>
</li>
<li>
<p>哈希表渐进式 <code>rehash</code> 的详细步骤如下：</p>
<ol>
<li><strong>为 <code>ht[1]</code> 分配空间</strong>，让字典<strong>同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表</strong>。</li>
<li>在<strong>字典中维持一个索引计数器变量</strong>，并<strong>将他的值设置为 0</strong>，<strong>表示 <code>rehash</code> 工作正式开始</strong>。</li>
<li>在<code>rehash</code><strong>进行期间</strong>，<strong>每次对字典执行添加</strong>、<strong>删除</strong>、<strong>查找</strong>或者<strong>更新操作时</strong>，程序<strong>除了执行指定的操作外</strong>，<strong>还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 <code>rehash</code> 到 <code>ht[1]</code></strong>，当<code>rehash</code><strong>工作完成之后</strong>，程序<strong>将 <code>rehashidx</code> 增 1</strong>。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code><strong>的所有键值对都会被 <code>rehash</code> 至 <code>ht[1]</code></strong>，这时程序<strong>将 <code>rehashidx</code> 属性的值设为-1</strong>，表示<code>rehash</code><strong>操作已完成</strong>。</li>
</ol>
</li>
<li>
<p>渐进式 <code>rehash</code> 的好处在于<strong>他采取分而治之的方式</strong>，<strong>将 <code>rehash</code> 键值对所需的计算工作均摊到对字典的每个添加</strong>、<strong>删除</strong>、<strong>查找</strong>和<strong>更新操作上</strong>，从而<strong>避免了集中式 <code>rehash</code> 而带来的庞大的计算量</strong>。</p>
</li>
<li>
<p>渐进式 <code>rehash</code> 执行期间的哈希表操作：</p>
<ol>
<li>字典的<strong>添加</strong>、<strong>删除</strong>、<strong>查找或者更新操作会在两个哈希表上进行</strong>：
<ol>
<li><strong>在字典里面查找一个键</strong>的话，程序<strong>会先在 <code>ht[0]</code> 里面进行查找</strong>，<strong>如果没找到的话</strong>，<strong>就会继续到 <code>ht[1]</code> 里面进行查找</strong>。</li>
</ol>
</li>
<li><strong>新添加到字典里面的键值对一律会被保存到 <code>ht[1]</code> 里面</strong>，而<code>ht[0]</code><strong>则不进行任何添加操作</strong>，这一措施<strong>保证了 <code>ht[0]</code> 包含的键值对数量会只减不增</strong>，并<strong>随着 <code>rehash</code> 操作的执行而最终变成空表</strong>。</li>
</ol>
</li>
<li>
<p>具体的渐进式 <code>rehash</code> 例子如下：</p>
<p>
  <img src="../../../media/202107/2021-07-14_162213.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_162302.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_162650.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_162757.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_162843.png" alt="" /></p>
<p>
  <img src="../../../media/202107/2021-07-14_162933.png" alt="" /></p>
</li>
</ol>
<h3 id="24-集合">
  2.4 集合
  <a class="anchor" href="#24-%e9%9b%86%e5%90%88">#</a>
</h3>
<h4 id="241-存储数据">
  2.4.1 存储数据
  <a class="anchor" href="#241-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae">#</a>
</h4>
<ol>
<li>是一种<strong>无序的集合</strong>，<strong>集合中的元素没有先后顺序</strong>。</li>
</ol>
<h4 id="242-使用场景">
  2.4.2 使用场景
  <a class="anchor" href="#242-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ol>
<li>某些<strong>需要去重的列表</strong>，并且<code>Set</code> 里面<strong>提供了判断某个成员是否在 <code>Set</code> 集合内的重要接口</strong>，这个也是<code>List</code> 所不能提供的。</li>
<li>存储一些<strong>集合性的数据</strong>，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在另一个集合中，因为 Redis 为集合提供了求交集、并集、差集等操作，可以非常方便的实现<strong>共同关注</strong>、<strong>共同喜好</strong>、<strong>二度好友</strong>等功能。</li>
</ol>
<h4 id="243-数据结构">
  2.4.3 数据结构
  <a class="anchor" href="#243-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li><code>Set</code> 底层有两种实现，分别是<strong>整数集合</strong>和<strong>字典</strong>：
<ol>
<li>当一个集合<strong>只包含整数值元素</strong>，并且这个集合的<strong>元素数量不多</strong>时，Redis 就会<strong>使用整数集合作为集合键的底层实现</strong>。</li>
<li>当一个集合<strong>不止包含整数值元素</strong>，<strong>还包含其它类型元素</strong>时，或者这个集合的<strong>元素数量很大</strong>时，Redis 就会<strong>使用字典作为集合键的底层实现</strong>。</li>
</ol>
</li>
<li>字典的内容上面已经叙述过，具体可参考
  <a href="/school-recruitment/#2-3-4-%e5%ad%97%e5%85%b8">2.3.4 字典</a>。</li>
</ol>
<h3 id="25-有序集合">
  2.5 有序集合
  <a class="anchor" href="#25-%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88">#</a>
</h3>
<h4 id="251-存储数据">
  2.5.1 存储数据
  <a class="anchor" href="#251-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae">#</a>
</h4>
<ol>
<li><strong>元素放入集合时还要提供该元素的分数</strong>，可<strong>根据分数自动排序</strong>。</li>
</ol>
<h4 id="252-使用场景">
  2.5.2 使用场景
  <a class="anchor" href="#252-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h4>
<ol>
<li>存放一个<strong>有序且不重复的集合列表</strong>，比如<code>Twitter</code> 的<code>public timeline</code> 可以以发表时间作为<code>score</code> 来存储，这样获取时就是自动按时间排好序的。</li>
<li>可以做<strong>带权重的队列</strong>，比如普通消息的<code>score</code> 为 1，重要消息的<code>score</code> 为 2，然后工作线程可以按<code>score</code> 的倒序来获取工作任务，让重要的任务优先执行。</li>
<li><strong>排行榜</strong>。</li>
</ol>
<h4 id="253-数据结构">
  2.5.3 数据结构
  <a class="anchor" href="#253-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h4>
<ol>
<li><code>ZSet</code> 底层有两种实现，分别是<strong>压缩列表</strong>和<strong>跳表</strong>：
  <img src="../../../media/202107/2021-07-14_172414.png" alt="" />
<ol>
<li>当一个有序集合包含的<strong>元素数量不多</strong>，并且有序集合中<strong>元素的成员的长度不大</strong>时，Redis 就会<strong>使用压缩列表作为有序集合键的底层实现</strong>：
<ol>
<li><strong>每个集合元素都使用两个紧挨在一起的压缩列表结点来保存</strong>，<strong>第一个节点保存元素的成员</strong>（<code>member</code>），<strong>第二个元素保存元素的分值</strong>（<code>score</code>）。</li>
<li>压缩列表内的集合<strong>按分值从小到大进行排序</strong>，<strong>分值较小的元素被放置在靠近表头的方向</strong>，<strong>分值较大的元素放置在靠近表尾的方向</strong>。</li>
<li>例如：
<ol>
<li>
<p>执行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry
</code></pre></div></li>
<li>
<p>元素在压缩列表中的保存方式如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-14_172517.png" alt="" /></p>
</li>
</ol>
</li>
</ol>
</li>
<li>当一个有序集合中元素<strong>数量比较多</strong>，或者有序集合中<strong>元素的成员是比较长的字符串</strong>时，Redis 就会<strong>使用跳跃链表作为有序集合键的底层实现</strong>。</li>
</ol>
</li>
<li>压缩列表的内容上面已经叙述过，具体可参考
  <a href="/school-recruitment/#2-2-5-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8">2.2.5 压缩列表</a>，下面将主要叙述跳表相关的内容。</li>
</ol>
<h4 id="254-跳表">
  2.5.4 跳表
  <a class="anchor" href="#254-%e8%b7%b3%e8%a1%a8">#</a>
</h4>
<h5 id="2541-前言">
  2.5.4.1 前言
  <a class="anchor" href="#2541-%e5%89%8d%e8%a8%80">#</a>
</h5>
<ol>
<li>跳表是<strong>一种有序数据结构</strong>，<strong>他通过在每个节点中维持多个指向其他节点的指针</strong>，<strong>从而达到快速访问节点的目的</strong>。</li>
<li>跳表支持<strong>平均 $O(logN)$</strong>、<strong>最坏 $O(N)$ 复杂度的节点查找</strong>，<strong>还可以通过顺序性操作来批处理节点</strong>。</li>
<li>Redis<strong>使用跳表作为有序集合键的底层实现之一</strong>，如果<strong>一个有序集合包含的元素数量比较多</strong>，<strong>又或者有序集合中元素的成员是比较长的字符串</strong>时，Redis 就<strong>会使用跳表来作为有序集合键的底层实现</strong>。</li>
</ol>
<h5 id="2542-实现">
  2.5.4.2 实现
  <a class="anchor" href="#2542-%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<ol>
<li>
<p>Redis 的跳表<strong>由 <code>src/redis.h/zskiplistNode</code> 和 <code>src/redis.h/zskiplist</code> 两个结构定义</strong>，其中 <code>zskiplistNode</code><strong>结构用于表示跳表节点</strong>，而 <code>zskiplist</code><strong>结构则用于保存跳表节点的相关信息</strong>，比如<strong>节点的数量</strong>、<strong>指向表头结点和表尾节点的指针</strong>等。</p>
</li>
<li>
<p>跳表的结构如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-26_112537.png" alt="" /></p>
<ol>
<li>
<p>位于图片最左边的是 <code>zskiplist</code> 结构，该结构包含以下属性：</p>
<ol>
<li><code>header</code>：<strong>指向跳表的表头结点</strong>。</li>
<li><code>tail</code>：<strong>指向跳表的表尾节点</strong>。</li>
<li><code>level</code>：<strong>记录目前跳表内</strong>，<strong>层数最大的那个节点的层数</strong>（表头结点的层数不计算在内）。</li>
<li><code>length</code>：<strong>记录跳表的长度</strong>，也即是，<strong>跳表目前包含节点的数量</strong>（表头结点不计算在内）。</li>
</ol>
</li>
<li>
<p>位于 <code>zskiplist</code> 结构右方的是四个 <code>zskiplistNode</code> 结构，该结构包含以下属性：</p>
<ol>
<li><code>level</code>：<strong>节点中用 $L1$</strong>、$L2$、$L3$<strong>等字样标记节点的各个层</strong>，$L1$<strong>代表第一层</strong>，$L2$<strong>代表第二层</strong>，<strong>以此类推</strong>，<strong>每个层都带有两个属性</strong>，分别是<strong>前进指针和跨度</strong>，<strong>前进指针用于访问位于表尾方向的其他节点</strong>，而<strong>跨度则记录了前进指针所指向节点和当前节点的距离</strong>，在上面的图片中，<strong>连线上带有数字的箭头就代表前进指针</strong>，而<strong>那个数字就是跨度</strong>，<strong>当程序从表头向表尾进行遍历时</strong>，<strong>访问会沿着层的前进指针进行</strong>。</li>
<li><code>backward</code>：<strong>节点中用 <code>BW</code> 字样标记节点的后退指针</strong>，<strong>他指向位于当前节点的前一个节点</strong>，<strong>后退指针在程序从表尾向表头遍历时使用</strong>。</li>
<li><code>score</code>：<strong>各个节点中的 1.0</strong>、<strong>2.0 和 3.0 是节点所保存的分值</strong>，<strong>在跳表中</strong>，<strong>节点按各自保存的分值从小到大排列</strong>。</li>
<li><code>obj</code>：<strong>各个节点中的 $o1$</strong>、$o2$、$o3$<strong>是节点所保存的成员对象</strong>。</li>
</ol>
<blockquote>
<p>需要注意的是<strong>表头结点和其他节点的构造是一样的</strong>，<strong>也有后退指针</strong>、<strong>分值和成员对象</strong>，<strong>不过表头结点的这些属性都不会被用到</strong>，<strong>所以图中省略了这些部分</strong>，<strong>只显示了表头结点的各个层</strong>。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h6 id="25421-跳表节点">
  2.5.4.2.1 跳表节点
  <a class="anchor" href="#25421-%e8%b7%b3%e8%a1%a8%e8%8a%82%e7%82%b9">#</a>
</h6>
<ol>
<li>
<p>跳表节点的实现由 <code>src/redis.h/zskiplistNode</code> 结构定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">zskiplistNode</span> {
    robj <span style="color:#f92672">*</span>obj;  <span style="color:#75715e">/*成员对象*/</span>
    <span style="color:#66d9ef">double</span> score;   <span style="color:#75715e">/*分值*/</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">zskiplistNode</span> <span style="color:#f92672">*</span>backward; <span style="color:#75715e">/*后退指针*/</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">zskiplistLevel</span> { <span style="color:#75715e">/*层*/</span>
        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">zskiplistNode</span> <span style="color:#f92672">*</span>forward;  <span style="color:#75715e">/*前进指针*/</span>
        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> span;  <span style="color:#75715e">/*跨度*/</span>
    } level[];
} zskiplistNode;
</code></pre></div></li>
<li>
<p><strong>层</strong>：</p>
<ol>
<li>
<p>跳表节点的 <code>level</code><strong>数组可以包含多个元素</strong>，<strong>每一个元素都包含一个指向其他节点的指针</strong>，<strong>程序可以通过这些层来加快访问其他节点的速度</strong>，一般来说，<strong>层的数量越多</strong>，<strong>访问其他节点的速度就越快</strong>。</p>
</li>
<li>
<p><strong>每次创建一个新跳表节点的时候</strong>，<strong>程序都根据幂次定律</strong>（越大的数出现的概率越小）<strong>随机生成一个介于 1 和 32 之间的值作为 <code>level</code> 数组的大小</strong>，<strong>这个大小就是层的高度</strong>。</p>
</li>
<li>
<p>下图分别展示了三个高度为 1 层、3 层和 5 层的节点：</p>
<p>
  <img src="../../../media/202107/2021-07-26_144034.png" alt="" /></p>
</li>
</ol>
</li>
<li>
<p><strong>前进指针</strong>：</p>
<ol>
<li><strong>每个层都有一个指向表尾方向的前进指针</strong>，<strong>用于从表头向表尾方向访问节点</strong>，下图用虚线表示出了程序从表头向表尾方向，遍历跳表中所有节点的路径：
  <img src="../../../media/202107/2021-07-26_144407.png" alt="" />
<ol>
<li><strong>迭代程序首先访问跳表的第一个节点</strong>（表头），<strong>然后从第四层的前进指针移动到表中的第二个节点</strong>。</li>
<li><strong>在第二个节点时</strong>，<strong>程序沿着第二层的前进指针移动到表中的第三个节点</strong>。</li>
<li><strong>在第三个节点时</strong>，<strong>程序同样沿着第二层的前进指针移动到表中的第四个节点</strong>。</li>
<li><strong>当程序再次沿着第四个节点的前进指针移动时</strong>，<strong>他碰到了一个 <code>NULL</code></strong>，<strong>程序知道这时已经到达了跳表的表尾</strong>，<strong>于是结束了这次遍历</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>跨度</strong>：</p>
<ol>
<li><strong>层的跨度用于记录两个节点之间的距离</strong>：
<ol>
<li><strong>两个节点之间的跨度越大</strong>，<strong>他们相距得就越远</strong>。</li>
<li><strong>指向 <code>NULL</code> 的所有前进指针的跨度都为 0</strong>，<strong>因为他们没有连向任何节点</strong>。</li>
</ol>
</li>
<li><strong>跨度主要用来计算排位</strong>（Rank）<strong>的</strong>，<strong>在查找某个节点的过程中</strong>，<strong>将沿途访问过的所有层的跨度累计起来</strong>，<strong>得到的结果就是目标节点在跳跃表中的排位</strong>，例如：
<ol>
<li>
<p>下图用虚线标记了在跳跃表中查找分值为 3.0、成员对象为 $o3$ 的节点时沿途经历的层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3。</p>
<p>
  <img src="../../../media/202107/2021-07-26_145948.png" alt="" /></p>
</li>
<li>
<p>下图用虚线标记了在跳跃表中查找分值为 2.0、成员对象为 $o2$ 的节点时沿途经历的层，在查找节点的过程中，程序经过了两个跨度为 1 的节点，因此可以计算出，目标节点在跳跃表中的排位为 2。</p>
<p>
  <img src="../../../media/202107/2021-07-26_150258.png" alt="" /></p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>后退指针</strong>：</p>
<ol>
<li>
<p><strong>节点的后退指针用于从表尾向表头方向访问节点</strong>，<strong>与可以一次跳过多个节点的前进指针不同</strong>，<strong>因为每个节点只有一个后退指针</strong>，<strong>所以每次只能后退至前一个节点</strong>。</p>
</li>
<li>
<p>下图用虚线展示了如何<strong>从表尾向表头遍历跳表中的所有节点</strong>，<strong>程序首先通过跳表的 <code>tail</code> 指针访问表尾节点</strong>，<strong>然后通过后退指针访问倒数第二个节点</strong>，<strong>之后再沿着后退指针访问倒数第三个节点</strong>，<strong>再之后遇到指向 <code>NULL</code> 的后退指针</strong>，<strong>于是访问结束</strong>。</p>
<p>
  <img src="../../../media/202107/2021-07-26_155255.png" alt="" /></p>
</li>
</ol>
</li>
<li>
<p><strong>分值和成员</strong>：</p>
<ol>
<li>
<p><strong>节点的分值是一个 <code>double</code> 类型的浮点数</strong>，<strong>跳表中的所有节点都按分值从小到大来排序</strong>。</p>
</li>
<li>
<p><strong>节点的成员是一个指针</strong>，<strong>他指向一个字符串对象</strong>，<strong>而字符串对象则保存着一个 SDS 值</strong>。</p>
</li>
<li>
<p><strong>在同一个跳表中</strong>，<strong>各个节点保存的成员对象必须是唯一的</strong>，<strong>但是多个节点保存的分值却是可以相同的</strong>，<strong>分值相同的节点将按照成员对象在字典中的大小来进行排序</strong>，<strong>成员对象较小的节点会排在前面</strong>（靠近表头的方向），<strong>而成员对象较大的节点则会排在后面</strong>（靠近表尾的方向）。</p>
</li>
<li>
<p>如下图所示，三个跳表节点都保存了相同的分值 10086.0，保存成员对象 $o1$ 的节点排在保存成员对象 $o2$ 和 $o3$ 节点之前，而保存成员对象 $o2$ 的节点又排在保存成员对象 $o3$ 的节点之前，由此可见，$o1$、$o2$、$o3$ 三个成员对象在字典中的排序为 $o1 \lt o2 \lt o3$。</p>
<p>
  <img src="../../../media/202107/2021-07-26_160619.png" alt="" /></p>
</li>
</ol>
</li>
</ol>
<h6 id="25422-跳表">
  2.5.4.2.2 跳表
  <a class="anchor" href="#25422-%e8%b7%b3%e8%a1%a8">#</a>
</h6>
<ol>
<li>
<p><strong>仅靠多个跳表节点就可以组成一个跳表</strong>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-26_160844.png" alt="" /></p>
</li>
<li>
<p><strong>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点</strong>，<strong>程序可以更方便地对整个跳表进行处理</strong>，比如<strong>快速访问跳表的表头结点和表尾节点</strong>，或者<strong>快速地获取跳表节点的数量</strong>（即跳表的长度）<strong>等信息</strong>，如下图所示：</p>
<p>
  <img src="../../../media/202107/2021-07-26_161226.png" alt="" /></p>
</li>
<li>
<p><code>zskiplist</code> 的结构定义如下：</p>
<pre><code>typedef struct zskiplist {
    struct zskiplistNode *header, *tail;    /*表头结点和表尾节点*/
    unsigned long length;   /*表中节点的数量*/
    int level;  /*表中层数最大的节点的层数*/
} zskiplist;
</code></pre></li>
</ol>
<h5 id="2543-跳表与平衡树哈希表的比较">
  2.5.4.3 跳表与平衡树、哈希表的比较
  <a class="anchor" href="#2543-%e8%b7%b3%e8%a1%a8%e4%b8%8e%e5%b9%b3%e8%a1%a1%e6%a0%91%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e6%af%94%e8%be%83">#</a>
</h5>
<ol>
<li><strong>跳表和各种平衡树</strong>（如 AVL、红黑树）<strong>的元素是有序排列的</strong>，而<strong>哈希表不是有序的</strong>，因此，<strong>在哈希表上只能做单个 <code>key</code> 的查找</strong>，<strong>不适宜做范围查找</strong>，所谓范围查找，指的是<strong>查找那些大小在指定的两个值之间的所有节点</strong>。</li>
<li><strong>在做范围查找的时候</strong>，<strong>平衡树比跳表操作要复杂</strong>，<strong>在平衡树上</strong>，<strong>我们找到指定范围的小值之后</strong>，<strong>还需要以中序遍历的顺序继续寻找其他不超过大值的节点</strong>，<strong>如果不对平衡树进行一定的改造</strong>，<strong>这里的中序遍历并不容易实现</strong>，<strong>而在跳表上进行范围查找就非常简单</strong>，<strong>只需要在找到小值之后</strong>，<strong>对第一层链表进行若干步的遍历就可以实现</strong>。</li>
<li><strong>平衡树的插入和删除操作可能引发子树的调整</strong>，<strong>逻辑复杂</strong>，<strong>而跳表的插入和删除只需要修改相邻接点的指针</strong>，<strong>操作简单又快速</strong>。</li>
<li><strong>从内存占用上来说</strong>，<strong>跳表比平衡树更灵活一些</strong>，<strong>一般来说</strong>，<strong>平衡树每个节点包含 2 个指针</strong>（分别指向左右子树），<strong>而跳表每个节点包含的指针数目平均为 $\frac{1}{1-p}$</strong>，<strong>具体取决于参数 $p$</strong>，<strong>如果向 Redis 里的实现一样</strong>，<strong>取 $p = \frac{1}{4}$</strong>，<strong>那么平均每个节点包含 1.33 个指针</strong>，<strong>比平衡树更有优势</strong>。</li>
<li><strong>查找单个 <code>key</code></strong>，<strong>跳表和平衡树的时间复杂度都为 $O(logn)$</strong>，<strong>大体相当</strong>，<strong>而哈希表在保持较低的哈希值冲突概率的前提下</strong>，<strong>查找时间复杂度接近 $O(1)$</strong>，<strong>性能更高一些</strong>，所以我们平常使用的各种<code>Map</code> 或<code>dictionary</code> 结构，大都是基于哈希表实现的。</li>
<li><strong>从算法实现难度上来比较</strong>，<strong>跳表比平衡树要简单的多</strong>。</li>
</ol>
<h5 id="2544-redis-为什么使用跳表而不用平衡树作为集合的实现">
  2.5.4.4 Redis 为什么使用跳表而不用平衡树作为集合的实现
  <a class="anchor" href="#2544-redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e8%b7%b3%e8%a1%a8%e8%80%8c%e4%b8%8d%e7%94%a8%e5%b9%b3%e8%a1%a1%e6%a0%91%e4%bd%9c%e4%b8%ba%e9%9b%86%e5%90%88%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<p>可以参考
  <a href="/school-recruitment/#2-5-4-3-%e8%b7%b3%e8%a1%a8%e4%b8%8e%e5%b9%b3%e8%a1%a1%e6%a0%91-%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e6%af%94%e8%be%83">2.5.4.3 跳表与平衡树、哈希表的比较</a>，然后从<strong>内存占用</strong>和<strong>算法复杂度</strong>两个角度来分析。</p>
<h2 id="参考文献">
  参考文献
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#</a>
</h2>
<ol>
<li>
  <a href="https://blog.csdn.net/Butterfly_resting/article/details/89668661">几率大的 Redis 面试题（含答案）</a>。</li>
<li>
  <a href="https://juejin.cn/post/6844904127055527950">Redis 面试题（总结最全面的面试题）</a>。</li>
<li>
  <a href="https://juejin.cn/post/6844903929545932808">Redis 基本类型及其数据结构</a>。</li>
<li>
  <a href="https://zhuanlan.zhihu.com/p/141184020">Redis 数据类型及使用场景</a>。</li>
<li>redis 设计与实现（第二版）。</li>
<li>
  <a href="https://juejin.cn/post/6844903446475177998">Redis 为什么用跳表而不用平衡树？</a></li>
<li>
  <a href="https://xiaorui2.github.io/2019/06/25/Hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">Hash 冲突的几种解决方法</a>。</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/graysonwp/ComputerCookbook-SchoolRecruitment/edit/main/exampleSite/content/docs/database/3%e3%80%81Redis/3.1%20%e6%a6%82%e8%bf%b0/3.1.2%20Redis%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b.md" target="_blank" rel="noopener">
      <img src="/school-recruitment/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


<div id="gitalk-container" style="width : 100%;"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '94880e59f97ce511eb59',
    clientSecret: '025de6989c2398fdb4bfc398994541421fe6d32b',
    repo: 'ComputerCookbook-SchoolRecruitment',
    owner: 'graysonwp',
    admin: ['graysonwp'],
    id: md5(location.pathname), 
    distractionFreeMode: false, 
    body: location.href, 
    proxy: 'https:\/\/shielded-brushlands-08810.herokuapp.com\/https:\/\/github.com\/login\/oauth\/access_token' 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-前言">1 前言</a></li>
        <li><a href="#2-数据类型">2 数据类型</a>
          <ul>
            <li><a href="#21-字符串">2.1 字符串</a>
              <ul>
                <li><a href="#211-存储数据">2.1.1 存储数据</a></li>
                <li><a href="#212-使用场景">2.1.2 使用场景</a></li>
                <li><a href="#213-数据结构">2.1.3 数据结构</a></li>
                <li><a href="#214-sds">2.1.4 SDS</a>
                  <ul>
                    <li><a href="#2141-前言">2.1.4.1 前言</a></li>
                    <li><a href="#2142-定义">2.1.4.2 定义</a></li>
                    <li><a href="#2143-sds-与-c-字符串的区别">2.1.4.3 SDS 与 C 字符串的区别</a>
                      <ul>
                        <li><a href="#21431-常数复杂度获取字符串长度">2.1.4.3.1 常数复杂度获取字符串长度</a></li>
                        <li><a href="#21432-杜绝缓冲区溢出">2.1.4.3.2 杜绝缓冲区溢出</a></li>
                        <li><a href="#21433-减少修改字符串时带来的内存重分配次数">2.1.4.3.3 减少修改字符串时带来的内存重分配次数</a></li>
                        <li><a href="#21434-二进制安全">2.1.4.3.4 二进制安全</a></li>
                        <li><a href="#21345-兼容部分-c-字符串函数">2.1.3.4.5 兼容部分 C 字符串函数</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#22-列表">2.2 列表</a>
              <ul>
                <li><a href="#221-存储数据">2.2.1 存储数据</a></li>
                <li><a href="#222-使用场景">2.2.2 使用场景</a></li>
                <li><a href="#223-数据结构">2.2.3 数据结构</a></li>
                <li><a href="#224-链表">2.2.4 链表</a>
                  <ul>
                    <li><a href="#2241-前言">2.2.4.1 前言</a></li>
                    <li><a href="#2242-实现">2.2.4.2 实现</a>
                      <ul>
                        <li><a href="#22421-链表节点">2.2.4.2.1 链表节点</a></li>
                        <li><a href="#22422-链表">2.2.4.2.2 链表</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><a href="#225-压缩列表">2.2.5 压缩列表</a>
                  <ul>
                    <li><a href="#2251-前言">2.2.5.1 前言</a></li>
                    <li><a href="#2252-实现">2.2.5.2 实现</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#23-哈希">2.3 哈希</a>
              <ul>
                <li><a href="#231-存储数据">2.3.1 存储数据</a></li>
                <li><a href="#232-使用场景">2.3.2 使用场景</a></li>
                <li><a href="#233-数据结构">2.3.3 数据结构</a></li>
                <li><a href="#234-字典">2.3.4 字典</a>
                  <ul>
                    <li><a href="#2341-前言">2.3.4.1 前言</a></li>
                    <li><a href="#2342-实现">2.3.4.2 实现</a>
                      <ul>
                        <li><a href="#23421-哈希表">2.3.4.2.1 哈希表</a></li>
                        <li><a href="#23422-哈希表节点">2.3.4.2.2 哈希表节点</a></li>
                        <li><a href="#23423-字典">2.3.4.2.3 字典</a></li>
                        <li><a href="#23424-哈希算法">2.3.4.2.4 哈希算法</a></li>
                        <li><a href="#23425-解决键值冲突">2.3.4.2.5 解决键值冲突</a></li>
                        <li><a href="#23426-rehash">2.3.4.2.6 rehash</a></li>
                        <li><a href="#23427-渐进式-rehash">2.3.4.2.7 渐进式 rehash</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#24-集合">2.4 集合</a>
              <ul>
                <li><a href="#241-存储数据">2.4.1 存储数据</a></li>
                <li><a href="#242-使用场景">2.4.2 使用场景</a></li>
                <li><a href="#243-数据结构">2.4.3 数据结构</a></li>
              </ul>
            </li>
            <li><a href="#25-有序集合">2.5 有序集合</a>
              <ul>
                <li><a href="#251-存储数据">2.5.1 存储数据</a></li>
                <li><a href="#252-使用场景">2.5.2 使用场景</a></li>
                <li><a href="#253-数据结构">2.5.3 数据结构</a></li>
                <li><a href="#254-跳表">2.5.4 跳表</a>
                  <ul>
                    <li><a href="#2541-前言">2.5.4.1 前言</a></li>
                    <li><a href="#2542-实现">2.5.4.2 实现</a>
                      <ul>
                        <li><a href="#25421-跳表节点">2.5.4.2.1 跳表节点</a></li>
                        <li><a href="#25422-跳表">2.5.4.2.2 跳表</a></li>
                      </ul>
                    </li>
                    <li><a href="#2543-跳表与平衡树哈希表的比较">2.5.4.3 跳表与平衡树、哈希表的比较</a></li>
                    <li><a href="#2544-redis-为什么使用跳表而不用平衡树作为集合的实现">2.5.4.4 Redis 为什么使用跳表而不用平衡树作为集合的实现</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












