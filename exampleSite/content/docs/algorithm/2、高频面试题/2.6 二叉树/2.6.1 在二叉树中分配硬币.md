# 在二叉树中分配硬币

## 1 题目

给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

**示例 1：**

![](../../../media/202104/2021-04-02_193340.png)

```
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
```

**示例 2：**

![tree2.png (368×348)](../../../media/202104/2021-04-02_193407.png)

```
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
```

**示例 3：**

![tree3.png (368×348)](../../../media/202104/2021-04-02_193421.png)

```
输入：[1,0,2]
输出：2
```

**示例 4：**

![tree4.png (498×500)](../../../media/202104/2021-04-02_193440.png)

```
输入：[1,0,0,null,3]
输出：4
```

** 提示：**

* 1<= N <= 100
* 0 <= node.val <= N

## 2 解题思路

这里我们引入一个 `过载量`，用 $O$ 表示，他表示当前节点需要移出的金币数。

例如一个节点 $T_1$ 有 2 枚金币，则他需要移出的金币数为 1，即该节点的过载量 $O(T_1)=1$。

假如一个树 $T$ 有 $k$ 个节点，其中 $m$ 个非叶节点，分别为 $T_1,T_2,T_3,...,T_m$，$k-m$ 个叶子节点，分别为 $T_{m+1},T_{m+2},T_{m+3},...,T_k$，则：

1. 叶子节点 $T_i$ 的过载量为：

$$
O(T_i)=N(T_i)-1
$$

其中 $N(T_i)$ 为该叶子节点含有的金币个数。

即**一个叶子节点的过载量等于其含有的金币数减 1，该值可能为正，也可能为负，如果为正的话表示移出的金币个数，如果为负的话表示移入的金币个数**。

2. 非叶节点 $T_j$ 的过载量为：

$$
O(T_j)=N(T_j)+O(T_{lj})+O(T_{rj})-1
$$

其中 $O(T_{lj})$ 和 $O(T_{rj})$ 分别为该非叶节点 $O(T_j)$ 的 `左孩子节点` 和 `右孩子节点` 对应的过载量。

即**一个非叶节点的过载量等于=自身的金币个数 + 左孩子节点的过载量 + 右孩子节点的过载量-1**。

3. 则该树对应的过载量为：

$$
O(T)=\sum_{i=1}^kabs(O(T_i))
$$

即**一棵树的过载量等于所有节点的过载量的绝对值之和**。

具体实例如下：

![](../../../media/202104/2021-04-02_201811.png)

1. 该树 $T$ 共有 7 个节点，其中 4 个叶子节点，分别为 `d、e、f、g`，有 3 个非叶节点，分别为 `a、b、c`。
2. 计算叶子节点的过载量：

$$
O(d)=N(d)-1=1-1=0
$$

$$
O(e)=O(e)-1=0-1=-1
$$

$$
O(f)=O(f)-1=1-1=0
$$

$$
o(g)=O(g)=0-1=-1
$$

3. 计算非叶节点的过载量：

$$
O(b)=N(b)+O(d)+O(e)-1=3+0-1-1=1
$$

$$
O(c)=N(c)+O(f)+O(g)-1=0+0-1-1=-2
$$

$$
O(a)=N(a)+O(b)+O(c)-1=2+1-2-1=0
$$

4. 计算整棵树 $T$ 的过载量：

$$
O(T)=abs(O(a))+abs(O(b))+abs(O(c))+abs(O(d))+abs(O(e))+abs(O(f))+abs(O(g))=0+1+2+0+1+0+1=5
$$

因此该树使每个结点上只有一枚硬币所需的移动次数为 5。

## 3 参考代码

```java
package com.grayson.top;

import apple.laf.JRSUIUtils;
import com.grayson.top.domain.TreeNode;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/1 21:54
 * @Description 在二叉树中分配硬币
 */
public class L979 {

    int ans;
  
    /**
     * 采用深度优先搜索获取当前二叉树的过载量
     * @param node  二叉树头结点
     * @return  二叉树的过载量
     */
    public int dfs(TreeNode node) {
        if (node == null) {return 0;}
        int left = dfs(node.left);
        int right = dfs(node.right);
        ans += Math.abs(left) + Math.abs(right);
        return (node.val - 1) + left + right;
    }

    /**
     * 979. 在二叉树中分配硬币
     * 给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
     * 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
     * 返回使每个结点上只有一枚硬币所需的移动次数。
     * @param root  二叉树根节点
     * @return  使二叉树每个结点上只有一枚硬币所需的移动次数
     */
    public int distributeCoins(TreeNode root) {
        ans = 0;
        dfs(root);
        return ans;
    }

}
```

## 4 参考文献

1. [979. 在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree)。
2. [在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/solution/zai-er-cha-shu-zhong-fen-pei-ying-bi-by-leetcode)。

