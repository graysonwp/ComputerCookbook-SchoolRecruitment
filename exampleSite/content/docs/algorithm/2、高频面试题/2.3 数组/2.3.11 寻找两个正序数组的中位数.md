---
weight: 1121
---

# 寻找两个正序数组的中位数

## 1 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**示例 1：**

```txt
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```txt
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**示例 3：**

```txt
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

**示例 4：**

```txt
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

**示例 5：**

```txt
输入：nums1 = [2], nums2 = []
输出：2.00000
```

**提示：**

* nums1.length == m
* nums2.length == n
* 0 <= m <= 1000
* 0 <= n <= 1000
* 1 <= m + n <= 2000
* -106 <= nums1[i], nums2[i] <= 106

**进阶：** 你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

## 2 解题思路

### 2.1 二分查找

#### 2.1.1 问题分析

1. 给定两个有序数组，要求**找到两个有序数组的中位数**，最直观的思路有以下两种：
   1. 使用**归并**的方式，**合并两个有序数组**，**得到一个大的有序数组**，**大的有序数组的中间位置的元素**，**即为中位数**。
   2. **不需要合并两个有序数组**，**只要找到中位数的位置即可**，由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的：
      1. 维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。
2. 假设两个有序数组的长度分别为 $m$ 和 $n$，上述两种思路的复杂度如下：
   1. 第一种思路的时间复杂度为 $O(m + n)$，空间复杂度是 $O(m + n)$。
   2. 第二种思路虽然可以将空间复杂度降到 $O(1)$，但是时间复杂度依然是 $O(m + n)$。
3. 本题也可以使用二分查找的方法来实现，具体思路如下：
   1. 根据中位数的定义，**当 $m + n$ 是奇数时**，**中位数是两个有序数组中的第 $(m + n) / 2$ 个元素**，**当 $m + n$ 是偶数时**，**中位数是两个有序数组中的第 $(m + n) / 2$ 个元素和第 $(m + n) / 2 + 1$ 个元素的平均值**，因此，这道题可以转化成**寻找两个有序数组中第 $k$ 小的数**，**其中 $k$ 为 $(m + n) / 2$ 或 $(m + n) / 2 + 1$。**
   2. 假设两个有序数组分别是 $A$ 和 $B$，要找到第 $k$ 个元素，我们可以**比较 $A[\frac{k}{2} - 1]$ 和 $B[\frac{k}{2} - 1]$**，由于 $A[\frac{k}{2} - 1]$ 的前面分别有 $A[0..\frac{k}{2} - 2]$ 和 $B[0..\frac{k}{2} - 2]$，即 $\frac{k}{2} - 1$ 个元素，对于 $A[\frac{k}{2} - 1]$**和 $B[\frac{k}{2} - 1]$ 中的最小值**，**最多只会有 $(\frac{k}{2} - 1) + (\frac{k}{2} - 1) = k - 2 < k - 1$ 个元素比他小**，**那么他就不能是第 $k$ 小的数了**（第 $k$ 小的数最多有 $k - 1$ 个数比他小）。
   3. 因此，我们可以归纳出三种情况：
      1. 如果$A[\frac{k}{2} - 1] < B[\frac{k}{2} - 1]$，则$A[0..\frac{k}{2} - 1]$不可能是不可能是第$k$个数，可以全部排除。
      2. 如果$A[\frac{k}{2} - 1] > B[\frac{k}{2} - 1]$，则$B[0..\frac{k}{2} - 1]$不可能是不可能是第$k$个数，可以全部排除。
      3. 如果$A[\frac{k}{2} - 1] = B[\frac{k}{2} - 1]$，归入第一种情况处理。

         ![fig1](../../../media/202108/2021-08-18_1941310.9842675918411851.png)
   4. 可以看到，**比较$A[\frac{k}{2} - 1]$之后**，**可以排除$\frac{k}{2}$个不可能是第$k$小的数**，**查找范围缩小了一半**，同时，**我们将在排除后的新数组上继续二分查找**，并且**根据我们排除数的个数**，**减少$k$的值**，这是**因为我们排除的数都是不大于$k$的数**。
   5. 有以下三种情况需要特殊处理：
      1. **如果$A[\frac{k}{2} - 1]$或$B[\frac{k}{2} - 1]$越界**，那么**我们可以选取对应数组中的最后一个元素**，在这种情况下，我们**必须根据排除数的个数减少$k$的值**，而**不能直接将$k$减去$\frac{k}{2}$**。
      2. **如果一个数组为空**，**说明该数组中的所有元素都被排除**，**我们可以直接返回另一个数组中第$k$小的元素**。
      3. **如果$k = 1$**，**我们只要返回两个数组中的未排除下标范围内的首元素的最小值即可**。
   6. 具体示例如下：
      1. 假设两个有序数组如下：

         ```txt
         A: 1 3 4 9
         B: 1 2 3 4 5 6 7 8 9
         ```
      2. 两个有序数组的长度分别是4和9，长度之和是13，中位数是两个有序数组中的第7个元素，因此需要找到第$k = 7$的元素。
      3. 比较两个有序数组中下标为$\frac{k}{2} - 1 = 2$的数，即$A[2]$和$B[2]$，如下面所示：

         ```txt
         A: 1 3 4 9
                ↑
         B: 1 2 3 4 5 6 7 8 9
                ↑
         ```
      4. 由于$A[2] > B[2]$，因此排除$B[0..2]$，即数组$B$的下标偏移（`offset`）变为3，同时更新$k$的值$k = k - \frac{k}{2} = 4$。
      5. 下一步寻找，比较两个有序数组中下标为$\frac{k}{2} - 1 = 1$的数，即$A[1]$和$B[4]$，如下面所示，其中，方括号部分表示已经被排除的数：

         ```txt
         A: 1 3 4 9
              ↑
         B: [1 2 3] 4 5 6 7 8 9
                      ↑
         ```
      6. 由于$A[1] < B[4]$，因此排除$A[0..1]$，即数组$A$的下标偏移变为2，同时更新$k$的值$k = k - \frac{k}{2} = 2$。
      7. 下一步寻找，比较两个有序数组中下标为$\frac{k}{2} - 1 = 0$的数，即比较$A[2]$和$B[3]$，如下面所示：

         ```
         A: [1 3] 4 9
                  ↑
         B: [1 2 3] 4 5 6 7 8 9
                    ↑
         ```
      8. 由于$A[2] = B[3]$，根据之前的规则，排除$A$中的元素，因此排除$A[2]$，即数组$A$的下标偏移变为3，同时更新$k$的值$k = k - \frac{k}{2} = 1$，由于$k$的值变为1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第$k$个数，由于$A[3] = 9 > B[3] = 4$，因此第$k$个数是$B[3] = 4$。

#### 2.1.2 参考代码

```java
/**
 * 4. 寻找两个正序数组的中位数
 * @param nums1 第一个正序数组
 * @param nums2 第二个正序数组
 * @return  两个正序数组的中位数
 */
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int length1 = nums1.length, length2 = nums2.length;
    int totalLength = length1 + length2;

    if (totalLength % 2 == 1) {
        //  数组长度之和为奇数，则中位数下标为 totalLength / 2
        int midIndex = totalLength / 2;
        double median = getKthElement(nums1, nums2, midIndex + 1);
        return median;
    } else {
        //  数组长度之和为偶数，则中位数下标分别为 totalLength / 2 - 1，totalLength / 2
        int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
        double median = (getKthElement(nums1, nums2, midIndex1 + 1)
                + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        return median;
    }
}

/**
 * 获取两个正序数组中第 k 小的元素
 * @param nums1 第一个正序数组
 * @param nums2 第二个正序数组
 * @param k k 值
 * @return  两个正序数组中第 k 小的元素
 */
public int getKthElement(int[] nums1, int[] nums2, int k) {
    int length1 = nums1.length, length2 = nums2.length;
    int index1 = 0, index2 = 0;

    while (true) {
        //  边界情况
        //  如果其中一个数组到达边界，则另一个数组中原来下标加上 k - 1 对应的下标即为两个数组中位数的下标
        if (index1 == length1) {return nums2[index2 + k - 1];}
        if (index2 == length2) {return nums1[index1 + k - 1];}
        //  如果 k == 1，则两个数组中的较小数即为两个数组的中位数
        if (k == 1) {return Math.min(nums1[index1], nums2[index2]);}

        //  正常情况
        int half = k / 2;
        int newIndex1 = Math.min(index1 + half, length1) - 1;
        int newIndex2 = Math.min(index2 + half, length2) - 1;
        int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
        if (pivot1 <= pivot2) {
            //  如果 pivot1 <= pivot2，则 nums1[0, newIndex1] 都不可能是第 k 小的元素，把这些元素全部删除，剩下的作为新的 nums1 数组
            k -= (newIndex1 - index1 + 1);
            //  由于我们删除了一些元素（这些元素都比第 k 小的元素小），因此需要修改 k 的值，减去删除的数的个数
            index1 = newIndex1 + 1;
        } else {
            //  如果 pivot1 > pivot2，则 nums2[0, newIndex2] 都不可能是第 k 小的元素，把这些元素全部删除，剩下的作为新的 nums2 数组
            k -= (newIndex2 - index2 + 1);
            //  由于我们删除了一些元素（这些元素都比第 k 小的元素小），因此需要修改 k 的值，减去删除的数的个数
            index2 = newIndex2 + 1;
        }
    }
}
```

## 参考文献

1. [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)。
2. [寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114)。
