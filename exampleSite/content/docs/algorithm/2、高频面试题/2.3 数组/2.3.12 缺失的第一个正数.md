---
weight: 1122
---

# 缺失的第一个正数

## 1 题目

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
**示例 1：**

```txt
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```txt
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```txt
输入：nums = [7,8,9,11,12]
输出：1
```

**提示：**

* 1 <= nums.length <= 5 * 105
* -231 <= nums[i] <= 231 - 1

## 2 解题思路

### 2.1 哈希表

#### 2.1.1 问题分析

1. 对于一个**长度为$N$的数组**，其中**没有出现的最小正整数只能在$[1, N + 1]$中**，这是因为**如果$[1, N]$都出现了**，**那么答案是$N + 1$**，**否则答案是$[1, N]$中没有出现的最小正整数**。
2. 因此，我们有了一种**将数组设计成哈希表**的思路：
   1. 我们**对数组进行遍历**，对于**遍历到的数$x$**，**如果他在$[1, N]$的范围内**，**那么就将数组中的第$x - 1$个位置**（数组下标从0开始）**打上标记**。
   2. 在**遍历结束之后**，**如果所有位置都被打了标记**，**那么答案是$N + 1$**，**否则答案是最小的没有打上标记的位置加1**。
3. 由于我们只在意$[1, N]$的数，因此我们可以**先对数组进行遍历**，**把不在$[1, N]$范围内的数修改成任意一个大于$N$的数**（例如$N + 1$），这样一来，**数组中的所有数就都是正数了**，因此，我们可以**将标记表示为负号**。
4. 具体的算法流程如下：
   1. **将数组中所有小于等于0的数修改为$N + 1$**。
   2. **遍历数组中的每一个数$x$**，他**可能已经被打了标记**，因此**原本对应的数为$|x|$**，**如果$|x| \in [1, N]$**，**并且**，**那么我们给数组中的第$|x| - 1$个位置的数添加一个负号**，**如果他已经有负号**，**不需要重复添加**。
   3. **在遍历完成之后**，**如果数组中的每一个数都是负数**，**那么答案是$N + 1$**，**否则答案是第一个正数的位置$+ 1$**。

      ![](../../../media/202108/2021-08-15_214948.png)

#### 2.1.2 参考代码

```java
/**
 * 41. 缺失的第一个正数（版本1：哈希表）
 * @param nums  数组
 * @return  数组中缺失的第一个正数
 */
public int firstMissingPositiveV1(int[] nums) {
    int m = nums.length;

    for (int i = 0; i < m; i++) {
        //  将数组中小于等于 0 的数修改为 m + 1
        if (nums[i] <= 0) {nums[i] = m + 1;}
    }

    for (int i = 0; i < m; i++) {
        //  假设遍历到的数的绝对值为 x，如果 nums[x] 为正数，则将其变为对应的相反数
        int x = Math.abs(nums[i]);
        if (x <= m) {nums[x - 1] = -Math.abs(nums[x - 1]);}
    }

    for (int i = 0; i < m; i++) {
        //  数组中第一个正数所在的位置 + 1 即为数组中缺失的第一个正数
        if (nums[i] > 0) {return i + 1;}
    }

    //  如果数组中全部都为负数，则数组中缺失的第一个正数为 m + 1
    return m + 1;
}
```

### 2.2 置换

#### 2.2.1 问题分析

1. 除了打标记外，我们还可以使用**置换**的方法，将给定的数组恢复成下面的形式：
   1. **如果数组中包含$x \in [1, N]$**，**那么恢复后**，**数组的第$x - 1$个元素为$x$**。
2. 在**恢复后**，**数组应当有$[1, 2,...,N]$的形式**，**但其中有若干个位置的数是错误的**，**每一个错误的位置就代表了一个缺失的正数**。
3. 我们可以按照如下的方式对数组进行恢复：
   1. **对数组进行遍历**，**对于遍历到的数$x = nums[i]$**，**如果$x \in [1, N]$**，我们就知道$x$**应当出现在数组中的$x - 1$的位置**，因此**交换$nums[i]$和$nums[x - 1]$**，**这样$x$就出现在了正确的位置**，**在完成交换后**，**新的$nums[i]$可能还在$[1, N]$的范围内**，**我们需要继续进行交换操作**，**直到$x \in [1, N]$**。
   2. 需要注意的是，上面的方法**可能陷入死循环**，**如果$nums[i]$恰好与$nums[x - 1]$相等**，**那么就会无限交换下去**，**此时我们有$nums[i] = x = nums[x - 1]$**，**说明$x$已经出现在了正确的位置**，**因此我们可以跳出循环**，**开始遍历下一个数**。![](../../../media/202108/41-缺失的第一个正数_1629036188.gif)

#### 2.2.2 参考代码

```java
/**
 * 41. 缺失的第一个正数（版本2：置换）
 * @param nums  数组
 * @return  数组中缺失的第一个正数
 */
public int firstMissingPositiveV2(int[] nums) {
    int m = nums.length;

    for (int i = 0; i < m; i++) {
        //  对于遍历到的数 x = nums[i]，如果 x 在 [1, m] 范围内，并且 x != nums[x - 1] （防止发生死循环），则交换 nums[i] 与 nums[x - 1]，如果交换后新的 nums[i] 还在 [1, m] 范围内，则继续执行交换操作，知道 x 不在 [1, m] 范围内
        while (nums[i] >= 1 && nums[i] <= m && nums[i] != nums[nums[i] - 1]) {
            int temp = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = temp;
        }
    }

    for (int i = 0; i < m; i++) {
        //  交换后完后的数组中第 i 个位置的元素 nums[i]，如果 nums[i] != i + 1，则该元素所在的下一个位置 i + 1 即为数组中缺失的第一个正数
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    //  如果数组中的元素 nums[i] 都等于 i + 1，则数组中缺失的第一个正数为 m + 1
    return m + 1;
}
```

## 参考文献

1. [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive)。
2. [缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution)。
