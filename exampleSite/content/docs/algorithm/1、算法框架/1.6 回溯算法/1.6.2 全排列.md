# 全排列

## 1 题目

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

**示例 1：**

```txt
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```txt
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```txt
输入：nums = [1]
输出：[[1]]
```

**提示：**

* 1 <= nums.length <= 6
* -10 <= nums[i] <= 10
* nums 中的所有整数互不相同

## 2 解题思路

### 2.1 回溯算法

#### 2.1.1 问题分析

1. 全排列对应的回溯树如下图所示，只要从根遍历这棵树，记录路径上的字，其实就是所有的全排列。![](./media/202106/2021-06-24_200134.png)
2. 我们可以把上面的树称为决策树，因为我们在每个节点上都在做决策，比如说我们站在下面的红色节点上，此时，我们就在做决策，因为 2 那条树枝在我们身后，这个选择我们已经做过了，所以我们只可以选择 1 那条树枝，或者选择 3 那条树枝。![](./media/202106/2021-06-24_200738.png)
3. 此时：

   1. 2 就是路径，记录我们已经做过的选择。
   2. $[1,3]$ 就是选择列表，表示当前我们可以做出的选择。
   3. 结束条件就是遍历到树的底层，在这里就是选择列表为空的时候。
4. 可以将路径、选择列表作为决策树上每个节点的属性，如下图所示：![](./media/202106/2021-06-24_201112.png)
5. 我们定义的 `backtrack` 函数其实就像一个指针，在上面那棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。
6. 各种搜索问题的实质都是树的遍历问题，多叉树的遍历框架如下：

   ```java
   void traverse(TreeNode root) {
       for (TreeNode child : root.childern)
           // 前序遍历需要的操作
           traverse(child);
           // 后序遍历需要的操作
   }
   ```

   所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，如下图所示：

   ![](./media/202106/2021-06-24_202925.png)

   前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。
7. 对于回溯算法来说，路径和选择列表是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作，具体如下图所示：

   ![](./media/202106/2021-06-24_203301.png)

   即我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径，对应的核心代码框架如下：

   ```java
   for 选择 in 选择列表:
       # 做选择
       将该选择从选择列表移除
       路径.add(选择)
       backtrack(路径, 选择列表)
       # 撤销选择
       路径.remove(选择)
       将该选择再加入选择列表
   ```

#### 2.1.2 参考代码

```java
List<List<Integer>> res = new LinkedList<>();

/**
 * 回溯算法
 * 【路径】：记录在 track 中
 * 【选择列表】：nums 中不存在 track 的那些元素
 * 【结束条件】：nums 中的元素全都在 track 中出现
 *
 * @param nums  数组
 * @param track 【路径】
 */
public void backtrack(int[] nums, LinkedList<Integer> track) {
    //  触发结束条件
    if (nums.length == track.size()) {
        res.add(new LinkedList<>(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        //  排除不合法的选择
        if (track.contains(nums[i])) {
            continue;
        }
        //  做选择
        track.add(nums[i]);
        //  进入下一层决策树
        backtrack(nums, track);
        //  取消选择
        track.removeLast();
    }
}

/**
 * 46. 全排列
 *
 * @param nums 数组
 * @return 数组元素的全排列
 */
public List<List<Integer>> permute(int[] nums) {
    //  记录【路径】
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}
```

## 3 参考文献

1. [46. 全排列](https://leetcode-cn.com/problems/permutations)。
2. [回溯算法解题套路框架](https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban)。
