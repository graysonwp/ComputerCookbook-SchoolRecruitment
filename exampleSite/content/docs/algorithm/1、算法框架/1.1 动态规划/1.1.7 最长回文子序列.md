---
weight: 117
---

# 最长回文子序列

## 1 题目

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
**示例 1:**
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**
输入:

```
"cbbd"
```

输出:

```
2
```

一个可能的最长回文子序列为 "bb"。

**提示：**

* 1 <= s.length <= 1000
* s 只包含小写英文字母

## 2 解题思路

### 2.1 子序列问题处理模板

对于这种子序列问题，我们一般需要使用**动态规划**的方法来解决：

1. **找状态关系（通过数学归纳获得）。**
2. **定义 dp 数组（根据状态转移方程获得）。**

dp 数组的定义主要有两种方式，一种是定义一个**一维数组**，另一种是定义一个**二维数组**。

#### 2.1.1 一维 dp 数组

例如，在[最长递增子序列](http://notebook.grayson.top/project-21/doc-266)中，我们就是定义了一个一维数组，其含义为：**在子数组 $array[0..i]$ 中，我们要求的子序列（最长递增子序列）的长度是 $dp[i]$。**

```java
int n = array.length;
int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

#### 2.1.2 二维 dp 数组

这种思路运用相对多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为**只涉及一个字符串**和**涉及两个字符串**两种情况。

1. **只涉及一个字符串/数组时：** 在子数组 $array[i..j]$ 中，我们要求的子序列（最长回文子序列）的长度为 $dp[i][j]$。
2. **涉及两个字符串/数组：在子数组 $arr1[0..i]$ 和 $arr2[0..j]$ 中，我们要求的子序列（最长公共子序列）长度为 $dp[i][j]$。**

### 2.2 问题解析

![](../../../media/202104/2021-04-08_163717.png)

dp 函数的定义为：**在子串 $s[i..j]$ 中，最长回文子序列的长度为 $dp[i][j]$**。

如果我们想求 $dp[i][j]$，假设我们已经知道了子问题 $dp[i+1][j-1]$ 的结果，即 $s[i+1..j-1]$ 中最长回文子序列的长度，那么我们就可以想办法算出 $dp[i][j]$ 的值，即 $s[i..j]$ 中最长回文子序列的长度，这主要取决于 $s[i]$ 和 $s[j]$ 的字符。

1. **如果 $s[i]==s[j]$：** 则他俩加上 $s[i+1..j-1]$ 中的最长回文子序列就是 $s[i..j]$ 的最长回文子序列。

![](../../../media/202104/2021-04-08_164936.png)

2. **如果 $s[i]!=s[j]$：** 说明他俩不可能同时出现在 $s[i..j]$ 的最长回文子序列中，那么把他俩分别加入 $s[i+1..j-1]$ 中，看看哪个子串产生的回文子序列更长即可。

![](../../../media/202104/2021-04-08_165224.png)

代码模板如下：

```c++
if (s[i] == s[j])
    // 它俩⼀定在最⻓回⽂⼦序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else
    //  s[i+1..j] 和 s[i..j-1] 谁的回⽂⼦序列更⻓？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

至此，状态转移方程就写出来了，根据**dp 数组**的定义，**我们要求的就是 $dp[0][n-1]$，也就是整个 s 的最长回文子序列的长度**。

### 2.3 参考代码

1. 首先明确一下 $base \space case$，如果只有一个字符，显然最长回文子序列的长度为 1，即 $dp[i][j]=1 \space (i==j)$。
2. 因为 $i$ 肯定小于 $j$，所以对于那些 $i>j$ 的位置，根本不存在什么子序列，应该初始化为 0。
3. 根据我们刚才的状态转移方程，想求 $dp[i][j]$ 需要知道 $dp[i+1][j-1]$，$dp[i+1][j]$，$dp[i][i-1]$ 这三个位置，将其填入 dp 数组后是这样：

![](../../../media/202104/2021-04-08_173451.png)

**为了保证每次计算 $dp[i][j]$，左、下、右方向的位置已经被计算出来了，只能斜着遍历或者反着遍历。**

![](../../../media/202104/2021-04-09_152953.png)

我选择**反着遍历**，参考代码如下：

```java
package com.grayson.top;

import java.util.Arrays;

/**
 * @author peng.wei
 * @version 1.0
 * @date 2021/4/8 14:50
 * @Description 最长回文子序列
 */
public class L516 {

    /**
     * 516. 最长回文子序列
     * 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
     * @param s 字符串
     * @return  最长回文子序列的长度
     */
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        //  dp table: s[i...j] 子串的回文子序列的最大长度
        //  最终的结果为 dp[0][n - 1]
        int[][] dp = new int[n][n];

        //  base case: 单个字符的回文子序列的最大长度为 1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    //  两个字符相等，将 dp[i + 1][j - 1] + 1
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    //  两个字符不相等，则 dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        // 返回最终的结果 dp[0][n - 1]
        return dp[0][n - 1];
    }

}
```

## 3 参考文献

1. [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)。
2. [动态规划之子序列问题解题模板](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zi-xu-lie-lei-xing-wen-ti/zi-xu-lie-wen-ti-mo-ban)。
