---
weight: 112
---

# 凑零钱问题

## 1 题目

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```txt
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```

**示例 2：**

```txt
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```txt
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```txt
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```txt
输入：coins = [1], amount = 2
输出：2
```

**提示：**

* 1 <= coins.length <= 12
* 1 <= coins[i] <= 231 - 1
* 0 <= amount <= 104

## 2 解题思路

### 2.1 暴力递归

如何列出动态转移方程：

* **先确定状态，也就是原问题和子问题中变化的变量：** 由于硬币数量无限，所以唯一的状态就是目标`amount`；
* **然后确定 `dp` 函数的定义：** 当前的目标金额是`n`，至少需要 dp(n)个硬币凑出该金额；
* **然后确定选择并择优：** 也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当日的目标金额是多少，就是选择从面额列表`coins` 中选择一个硬币，然后目标金额就会减少。
* **最后明确 base case：** 当目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回-1。

```python
def coinChange(coins: List[int], amount: int):
  
    def dp(n):
        # base case
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = db(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        return res if res != float('INF') else -1

    return dp(amount)
```

状态转移方程为：

![](../../../media/202103/2021-03-01_165041.png)

当 `amount = 11, coins = {1, 2, 5}` 时递归树为：

![](../../../media/202103/2021-03-01_165205.png)

### 2.2 带备忘录的递归

```python
def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()
    def dp(n):
        # 查备忘录，避免重复计算
        if n in memo: return memo[n]
  
        # base case
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = db(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        # 计入备忘录
        memo[n] = res if res != float('INF') else -1
        return memo[n]

    return dp(amount)
```

### 2.3 dp 数组的迭代解法

```c++
int coinChange(vector<int>& coins, int amount) {
  //  数组大小为 amount + 1，初始值也为 amount + 1
  vector<int> dp(amount + 1, amount + 1);
  //  base case
  dp[0] = 0
  for (int i = 0; i < dp.size(); i ++) {
    //  内层 for 循环求所有子问题 + 1 的最小值
    for (int coin: coins) {
      //  子问题无解，跳过
      if (i - coin < 0) continue;
      dp[i] = min(dp[i], 1 + dp[i - coin]);
    }
  }
  return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```

![](../../../media/202103/2021-03-01_173226.png)

**注：** dp 数组初始化为 `amount + 1` 是因为凑成 `amount` 金额的硬币最多只可能等于 `amount`（全用 1 元面值的硬币），所以初始化为 `amount + 1` 就相当于初始化为正无穷，便于后续取最小值。

## 3 参考文献

1. [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change)。
2. [动态规划解题核心框架](https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye/dong-tai-gui-hua-xiang-jie-jin-jie)。
