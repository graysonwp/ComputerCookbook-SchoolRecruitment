---
weight: 116
---

# 类加载器的种类

类加载过程可以描述为“通过一个类的全限定名 `a.b.c.XXClass`来获取描述此类的 `Class`对象”，这个过程由**类加载器（CLassLoader）** 来完成。这样的好处在于，**子类加载器可以复用父类加载器加载的类。** 类加载器主要分为三种：

![csrk7.png (651×444)]../../media/202105//1621914620.392762.png)

* **启动类加载器**（BootstrapClassLoader）：

  * 他用来加载Java的核心类，是用C++代码来实现的，并不继承自`java.lang.ClassLoader`（负责加载`JDK`中`jre/lib/tr.jar`里所有的`class`）。
  * 他可以看做是`JVM`自带的，我们在代码层面无法直接获取到启动类加载器的引用，所以不允许直接操作他，如果打印出来就是个`null`，但是后面可以通过命令行参数影响他加载什么。
* **扩展类加载器**（ExtCLassLoader）：

  * 他负责加载`JRE`的扩展目录，`lib/ext`或者由`java.ext.dirs`系统属性指定的目录中的`JAR`包的类。
  * 代码里直接获取他的**父类加载器**为`null`，因为无法拿到启动类加载器。
* **应用类加载器**（AppClassLoader）：

  * 他负责在`JVM`启动时加载来自`Java`命令的`-classpath`或者`-cp`选项、`java.class.path`系统属性指定的`jar`包和类路径。
  * 在应用程序代码里可以通过`ClassLoader`的静态方法`getSystemClassLoader()`来获取应用类加载器。
  * 如果没有特别指定，则在没有使用自定义类加载器情况下，用户自定义的类都由此类加载器加载。
* **自定义类加载器**（CustomClassLoader）：

  * 除了前面三种**系统自带的类加载器**，用户还可以自己定义类加载器，如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。
