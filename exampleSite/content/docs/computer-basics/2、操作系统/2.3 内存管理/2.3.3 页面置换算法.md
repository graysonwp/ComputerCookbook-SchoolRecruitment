---
weight: 3
---

# 页面置换算法

## 1 含义

1. 在程序运行过程中，如果要访问的页面不在内存中，就会发生缺页中断从而将该页调入内存中。
2. 此时如果内存中已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。
3. 页面置换算法的主要目标是**使页面置换频率最低**（也可以说缺页率最低）。

## 2 分类

### 2.1 最佳置换算法（Optimal Replacement Algorithm, OPT）

1. 最佳置换算法的基本思想是**置换以后不需要或者最远的将来才需要的页面，这样可以保证获得最低的缺页率**。
2. 但是由于人们目前**无法预知进程在内存下的若干页面中哪个是未来最长时间内不再访问的**，因而该算法是一种**理论上的算法**，也是**最优的一种算法**。

### 2.2 先进先出法（FIFO）

1. 先进先出法**会优先置换在内存中驻留时间最长的页面**。
2. 该算法会产生**贝拉迪（Belay）异常**，也就是**当所分配的物理块数增大而页故障数不减反增的异常现象**。
3. 该算法的缺点是**将那些经常被访问的页面置换出，从而使缺页率升高**。

### 2.3 第二次机会置换法（Second Chance Replacement, SCR）

1. 该算法是**对 FIFO 算法的改进**，每个页面**访问 2 次后再淘汰**。
2. 具体实现上是**设置页面访问位，每次检查队首的页面访问位：**
   1. 如果**该位为 0**，则**将该页置换出**。
   2. 如果**该位为 1**，将该位**设置为 0**，然后**将其移到队尾，看成新装入的页**。
3. 该算法的优点是**能在一定程度上避免把经常使用的页面置换出去**。

![](../../../media/202105/2021-05-22_171643.png)

### 2.4 时钟置换法（Clock）

1. 该算法是对第二次机会置换法的改进。
2. **第二次机会置换法需要在链表中移动页面**，而时钟置换法将页面保存在环形链表中，只需要**后移队头指针**，就相当于是**把原来的队头放队尾了**。
3. 该算法的优点是**避免了移动链表节点的开销**。

![](../../../media/202105/2021-05-22_172143.png)

### 2.5 最近最少使用法（Least Recently Used, LRU）

#### 2.5.1 原理

1. 优先置换**最久未被访问**的页面。
2. 根据局部性原理，一个进程**在一段时间内要访问的指令和数据都集中在一起**，如果一个页面**很久没有被访问**，那么**将来被访问的可能性也比较小**。

#### 2.5.2 实现

##### 2.5.2.1 单链表

1. 该算法最常见的实现是**使用一个链表保存缓存数据**，具体如下：
   1. 将**新数据插入到链表头部**。
   2. 每当**缓存命中**（即缓存数据被访问），则**将数据移到链表头部**。
   3. 当**链表满的时候**，将**链表尾部的数据丢弃**。

##### 2.5.2.2 基于HashMap和双向链表

1. 整体的设计思路是**使用HashMap存储 `key`**，这样**可以做到 `save(key)`和 `get(key)`的时间都是$O(1)$**，**HashMap的 `value`指向双向链表实现的LRU的Node节点**，如下图所示：![](../../../media/202107/2021-07-28_1039530.17124614514673764.png)
2. **LRU存储是基于双向链表的**，其中 `head`**代表双向链表的表头**，`tail`**代表双向链表的尾部**，**首先预先设置LRU的容量**，**如果存储满了**，**可以通过$O(1)$的时间淘汰掉双向链表的尾部**，**每次新增和访问数据**，**都可以通过$O(1)$的效率把新的节点增加到头部**，**或者把已经存在的节点移动到头部**。
3. **下图展示了预设大小为3的LRU存储和访问过程中的变化**，**为了简化图复杂度**，**图中没有展示HashMap的变化**，**仅仅展示了LRU中双向链表的变化**：![](../../../media/202107/2021-07-28_1112420.6409522974374684.png)

   > s = save，g = get
   >
4. 核心的操作步骤如下：

   1. `save(key, value)`：首先**在HashMap中找到 `key`对应的节点**，**如果节点存在**，**更新节点的值**，**并把这个节点移动到队头**，**如果不存在**，**需要构造新的节点**，**并且尝试把节点塞到队头**，**如果LRU空间不足**，**则通过 `tail`淘汰尾部的节点**，**同时在HashMap中移除 `key`**。
   2. `get(key)`：**通过HashMap找到LRU链表节点**，**因为根据LRU原理**，**这个节点是最新访问的**，**所以需要把节点插入到头部**，**然后返回缓存的值**。

#### 2.5.3 优缺点

##### 2.5.3.2 优点

1. 实验证明**LRU 的性能较好**，能够**降低置换频率**。

##### 2.5.3.1 缺点

1. 该算法的缺点是**存在缓存污染问题**，即**由于偶发性或周期性的冷数据批量查询，热点数据被挤出去，导致缓存命中率下降**。

### 2.6 LRU-K

#### 2.6.1 原理

1. LRU-K 中的**K 代表最近的使用次数**，因此 LRU 可以认为是 LRU-1。
2. LRU 算法中因为**仅访问一次就能替代别人**，可能会造成“**缓存污染**”问题，因此提出了 LRU-K 的概念，LRU-K 其主要目的就是**为了解决 LRU 算法“缓存污染”的问题**。
3. LRU-K 的**核心思想是将“最近使用过 1 次”的判断标准扩展为“最近使用过 K 次”**。
4. 与 LRU 算法不同，LRU-K 算法需要维护两个队列，分别是**历史队列**和**缓存队列**：
   1. **历史队列：**
      1. 历史队列**保存着每次访问的页面**，当**页面访问次数达到了 K 次**，该**页面出栈**，并**保存至缓存队列**。
      2. 若**尚未达到 K 次则继续保存**，**直至历史队列也满了**，那就**根据一定的缓存策略**（FIFO、LRU、LFU）**进行淘汰**。
   2. **缓存队列：**
      1. 缓存队列则是**保存已经访问 K 次的页面**，当该**队列满了之后**，则**淘汰最后一个页面**，也就是**第 K 次访问距离现在最久的那个页面**。

#### 2.6.2 实现

![](../../../media/202105/2021-05-23_162651.png)

1. 数据**第一次被访问**，**添加到历史队列中**。
2. 当**历史队列中的页面满了**，**根据一定的缓存策略**（FIFO、LRU、LFU）**淘汰老的页面**。
3. 当**历史队列中的某个页面第 K 次访问**时，该页面**从历史队列中出栈**，并**存放至缓存队列**。
4. **缓存队列中的页面再次被访问 K 次**时，**历史队列中该页面出栈**，并且**更新缓存队列中该页面的位置**。

#### 2.6.3 优缺点

##### 2.6.3.1 优点

1. LRU-K**降低了“缓存污染”带来的问题**，**命中率比 LRU 要高**。

##### 2.6.3.2 缺点

1. LRU-K 是一个**优先级队列**，**算法复杂度和代价比较高**。
2. 由于 LRU-K 还**需要记录那些被访问过、但还没有放入缓存的对象**，因此**内存消耗会比 LRU 要多**，当**数据量很大的时候**，**内存消耗会比较可观**。
3. LRU-K**需要基于时间进行排序**，**CPU 消耗比 LRU 要高**。

### 2.7 最不经常使用法（Least Frequently Used, LFU）

1. 最不经常使用法**使用一个计数器来记录条目被访问的频率**，当**队列满的时候**，**优先淘汰使用次数最少的元素**。
2. 该算法的优点是**能够避免缓存污染问题对 LRU 命中的影响**，因为在淘汰元素的时候是根据一定时间内的使用次数来决定的，所以短时间的冷数据查询不一定会导致热点数据被淘汰，进而避免缓存污染问题。
3. LFU 的缺点：在**短期的时间内，对某些缓存的访问频次很高**，这些缓存**会立刻晋升为热点数据**，而保证不会淘汰，这样**会驻留在系统内存里面**，而**实际上，这部分数据只是短暂的高频率访问**，之后**可能长期不会访问**，这样就会导致一些**新加入的缓存很容易被很快删除**，因为他们的**引用频率很低**。

> LRU 和 LFU 的区别？
>
> LRU 和 LFU 的侧重点不同，LRU 主要体现在对元素的**使用时间**上，LFU 主要体现在对元素的**使用频次**上。

![](../../../media/202105/2021-05-23_171217.png)

## 3 颠簸现象

### 3.1 原因

1. 颠簸本质上是指**频繁的页调度行为**。
2. **进程发生缺页中断时必须置换某一页**，然后，**其他所有的页都在使用**，他**置换一个页**，但**又立刻再次需要这个页**，因此会**不断产生缺页中断**，导致**整个系统的效率急剧下降**，这种现象称为颠簸。

### 3.2 解决方法

1. **修改页面置换算法**。
2. **降低同时运行的程序的数量**。
3. **终止该进程**或**增加物理内存容量**。

## 4 参考文献

1. [有哪些页面置换算法？](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
2. [操作系统学习(10)页面置换算法](https://houbb.github.io/2020/10/04/os-10-page-exchange)。
3. [LRU——缓存淘汰算法](https://www.cnblogs.com/X-knight/p/10650995.html)。
4. [【面试题】技术面试题汇总](https://imageslr.com/2020/07/08/tech-interview.html)。
5. [LRU 进阶之 LRU-K 和 2Q](https://segmentfault.com/a/1190000022558044)。
6. [LRU-K 和 2Q 缓存算法介绍](https://www.jianshu.com/p/c4e4d55706ff)。
7. [常用缓存淘汰算法（LFU、LRU、ARC、FIFO、MRU）](https://zhuanlan.zhihu.com/p/68733600)。
8. [LFU 的基本原理与实现](https://www.cnblogs.com/wyq178/p/11790015.html)。
9. [LRU原理和Redis实现——一个今日头条的面试题](https://zhuanlan.zhihu.com/p/34133067)。
