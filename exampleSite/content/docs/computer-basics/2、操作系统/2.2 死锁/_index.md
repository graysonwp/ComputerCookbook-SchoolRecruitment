---
weight: 11
---

# 死锁

## 1 什么是死锁

1. 在两个或者多个并发进程中，**每个进程持有某种资源而又等待其它进程释放他们现在保持着的资源，在未改变这种状态之前都不能向前推进**，称这一组进程产生了死锁。

## 2 死锁产生的必要条件

1. **互斥条件：** 一个资源每次只能被一个进程使用，即在**一段时间内某资源仅为一个进程所使用**，此时**如果有其它进程请求该资源**，则**请求进程只能等待**。
2. **请求与保持条件：** 进程中**已经保持了至少一个资源**，但**又提出新的资源请求**，而**该资源已经被其它进程占有**，此时**请求进程被阻塞**，但**对自己已经获得的资源保持不放**。
3. **不可剥夺条件：** 进程**未使用完的资源在未使用完毕之前**，**不能被其它进程强行夺走**，即**只能由获得该资源的进程自己来释放**。
4. **循环等待条件：** 若干进程间形成**首尾相接循环等待资源**的关系，在发生死锁时必然存在一个进程等待队列 $\{P_1,P_2,...,P_n\}$，其中 $P_1$ 等待 $P_2$ 占有的资源，$P_2$ 等待 $P_3$ 占有的资源，...，$P_n$ 等待 $P_1$ 占有的资源，形成一个进程等待环路，环路中**每一个进程所占有的资源同时被另一个申请**。

> 注意：
>
> 1. 上面的四个条件是死锁的**必要条件**，**只要发生死锁**，**这些条件必然成立**。
> 2. 但**只要**上述条件**有一条不满足**，**就不会发生死锁**。

## 3 死锁的处理方法

### 3.1 鸵鸟策略

1. 直接**忽略死锁**，因为**解决死锁问题的代价很高**，因此鸵鸟策略这种不采取任何措施的方案会**获得更高的性能**。
2. 当发生死锁时**不会对用户造成多大影响**，或**发生死锁的概率很低**，**可以采用鸵鸟策略**。

> 鸵鸟策略是指**当鸵鸟看到危险的时候，就把头埋在沙子里，装作看不到**。

### 3.2 死锁预防

死锁预防的基本思想是**破坏形成死锁的四个必要条件**。

1. **破坏互斥条件：** 允许某些资源同时被多个进程访问，但是有些资源本身并不具备这种属性，因此这种方案实用性有限。

   > * **只读数据文件**、**磁盘**等**软硬件资源**均**可采用这种办法管理**。
   > * **可写文件**、**键盘**等**独占性资源只能互斥的占有**，**不能采用这种办法管理**。
   >
2. **破坏请求与保持条件：**

   1. **实现资源预分配策略**，当一个进程**开始运行之前**，必须**一次性向系统申请他所需要的全部资源**，否则不运行。
   2. 这种方式的**缺点：**
      1. 很多时候**无法预知一个进程所需的全部资源**。
      2. 会**降低资源利用率**，**降低系统的并发性**，因为在每个进程占有的资源中，有些资源在**运行后期使用**，有些资源在**例外情况下使用**，所以可能造成进程**占有一些几乎用不到的资源**，而使**其它想使用这些资源的进程等待**。
3. **破坏不可剥夺条件：** 剥夺调度能够**防止死锁**，但是**只适用于内存和处理器资源**。

   1. **占有资源的进程**若要**申请新资源**，必须**主动释放已占有资源**，若**需要此资源**，应该**向系统重新申请**。
   2. 资源分配管理程序**为进程分配新资源**时，**若有则分配**，**否则**将**剥夺此进程已占有的全部资源**，并**让进程进入等待资源状态**，**资源充足后再唤醒它重新申请所需的资源**。
4. **破坏循环等待条件：**

   1. 给系统的**所有资源编号**，规定进程**请求所需资源的顺序必须按照资源的编号依次进行**。
      1. 一个进程得到某一层的资源后，只能申请较高一层的资源。
      2. 当进程释放某一层的资源时，必须先释放所占有的较高层的资源。
      3. 当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源。

### 3.3 死锁避免

1. 动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。
2. 所谓安全状态是指**即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕**。

### 3.4 死锁检测与死锁恢复

#### 3.4.1 死锁检测

1. 死锁检测是通过**检测有向图是否存在环**来实现，从**一个节点出发**进行**深度优先搜索**，对**访问过的节点进行标记**，如果**访问了已经标记的节点**，就表示**有向图存在环**，也就是**检测到死锁发生**。

#### 3.4.2 死锁恢复

1. **死锁剥夺法： 剥夺陷于死锁的进程所占用的资源**，但并**不撤销此进程**，直至**死锁解除。**
2. **进程回退法：** 根据系统保存的**检查点**让**所有的进程回退**，直到**足已解除死锁**，这种措施要求系统**建立保存检查点、回退及重启机制**。
3. **进程撤销法：**
   1. **撤销陷入死锁的所有进程**，**解除死锁，继续运行**。
   2. **逐个撤销陷入死锁的进程**，**回收其资源并重新分配**，**直至死锁解除**。
   3. 可选择符合下面条件之一的先撤销：
      1. **CPU消耗时间最少**者。
      2. 产生的**输出量最小**者。
      3. **预计剩余执行时间最长**者。
      4. **分得的资源数量最少**者。
      5. **优先级最低**者。
4. **系统重启法：** 结束所有进程的执行并**重新启动操作系统**，这种**方法很简单**，但先前的工作全部作废，**损失很大**。

## 4 参考文献

1. [什么是死锁？](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81)
2. [死锁概念，死锁产生的四个必要条件，如何避免和预防死锁](https://blog.csdn.net/ZWE7616175/article/details/79881236)。
3. [计算机操作系统 - 死锁](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md)。
4. [死锁的产生、防止、避免、检测和解除](https://zhuanlan.zhihu.com/p/61221667)。
